---
layout: post
title: "Elegant Object - 2장: 학습"
description: Elegant Object 2장
date: 2021-11-02 22:38:00 +09:00
categories: ElegantObject Study
---


# 학습

## 가능하면 적게 캡슐화 하라
- 유지보수성을 생각하다면 4개 또는 그 이하의 객체를 캡슐화 할것을 권장. 더 많은 객체를 캡슐화 해야 한다면 클래스에 문제가 있는것. 예외는 없음

```java
class Cash {
    private Integer digits;
    private Integer cents;
    private Integer currency;
}
```

- Cash 클래스는 digit, cents, currency 3개의 객체를 캡슐화하는데, 이 객체들 전체를 가리켜 상태 또는 식별자라 부름
- 이러한 식별자가 같은 객체들은 서로 동일한것. 하지만 Java언어의 특성상 식별자가 같더라도 다른 객체로 보기 떄문에 ```equals```를 오버라이드 하고 ```==```대신에 ```equals```를 사용 해야함
- 객체의 식별자는 기본적으로 세계 안에서 객체가 위치하는 좌표인데, 4개 이상의 좌표는 직관에 위배됨

## 최소한 뭔가는 캡슐화 하라
- 어떠한것도 캡슐화 하지 않는 객체가 존재하기도 함

```java
class Year {
    int read() {
        return System.currentTimeMillies() 
            / (1000 * 60 * 60 * 24 * 30 * 12) - 1970; // 알고리즘 오류는 무시하라
    }
}
```

- 어떤것도 캡슐화 하지 않기 때문에 이 클래스의 객체들은 모두 동일하나, 이 설계 역시 잘못됨. 너무 많은 캡슐화도 바람직 하지 않지만 아무것도 캡슐화 하지 않는것도 마찬가지
- 프로퍼티가 없는 클래스는 정적 메서드와 유사한데, 정적 메서드가 없고 인스턴스 생성과 실행을 엄격히 분리하는 순수OOP 에서는 기술적으로 프로퍼티가 없는 클래스는 만들 수 없음
- 실행으로부터 인스턴스 생성을 고립시켜야 하는데, 이는 생성자에서만 new연산자를 허용한다는 말
- Year에서 ```read()```메서드는 System의 정적 메서드를 사용하는데, 순수OOP에서는 정적 메서드가 존재하지 않기 떄문에, 어떤 클래스의 인스턴스를 생성한 후 이 인스턴스를 통해 시스템 클럭을 얻어야함

```java
class Year {
    private Millis millis;
    Year(Millis msec) {
        this.millis = msec;
    }
    int read() {
        return this.millis.read() 
            / (1000 * 60 * 60 * 24 * 30 * 12) - 1970; // 알고리즘 오류는 무시하라
    }
}
```

- 객체가 무(無)와 비슷한 무언가가 아니라면, 다른 무언가를 캡슐화 해야함. 이런 특징을 가진 엔티티만이 아무것도 캡슐화 하지 않을 수 있는데, 오직 하나만 존재하고 생존이나 자신의 좌표를 표현하기 위해 다른 엔티티를 필요로 하지 않기 때문
- 어떤 일을 수행하는 객체라면 다른 객체들과 공존하면서 이를 사용해야함. 자기 자신을 식별 할 수 있도록 다른 객체들을 캡슐화 해야함
- 다른 관점에서 살펴 본다면, 캡슐화된 상태는 세계안에서 객체의 위치를 지정하는 고유한 식별자로, 객체가 어떤것도 캡슐화 하지 않는단 말은 객체 자신이 세계 전체가 된다는 말
- 최종적으로 Year 클래스를 순수OOP의 형태로 만들면 다음과 같을것. 캡슐화에 관한 이야기는 이정도에서 마무리

```java
class Year {
    private Number num;
    Year(final Millis msec) {
        this.num = new Min(
            new Div(
                msec,
                new Mul(1000,60,60,24,30,12)
            ),
            1970
        );
    }
    int read() {
        return this.num.intValue();
    }
}
```

## 항상 인터페이스를 사용하라
- 객체는 다른 객체와 의사소통을 하면서 다른 객체의 작업을 지원하고, 다른 객체들 역시 이 객체에게 도움을 줌. 즉 서로를 필요로 하기 때문에 결합됨
- 애플리케이션이 성장하기 시작하고 객체들의 수가 수십개를 넘어간다면 객체들 사이의 강한 결합도가 심각한 문제로 떠오르는데, 이는 유지보수성에 영향을 미치기 때문
- 애플리케이션 전체를 유지보수가 가능하게 만들기 위해서는 최선을 다해서 객체를 분리해야 함. 이를 가능하게 해주는 가장 훌륭한 도구가 바로 인터페이스

```java
interface Cash {
    Cash multiply(float factor);
}
```

- Cash는 인터페이스로써, 다른 객체와 의사소통하기 위해 따라햐 하는 계약임

```java
class DefaultCash implements Cash {
    private int dollars;
    DefaultCash(int dlr) {
        this.dollars = dlr;
    }

    @Override
    Cash multiply(float factor) {
        return new DefaultCash(this.dollars * factor);
    }
}

class Employee {
    private Cash salary;
}
```

- 위와 같이 객체가 계약을 준수 할 수 있도록 만들 수 있으며, 금액이 필요하다면 실제 구현 대신 계약에 의존하면 됨
- Employee 클래스는 Cash 인터페이스의 구현 방법에 아무런 관심이 없고, ```multiply()```메서드가 어떻게 동작하는지 관심도 없고 알수도 없음. 그래서 Employee 클래스와 DefaultCash 클래스 사이를 느슨하게 분리가 가능
- 추가적으로 클래스 안의 모든 퍼블릭 메서드가 인터페이스를 구현하도록 만드는것을 권장. 올바르게 설계된 클래스라면 최소한 하나의 인터페이스라도 구현하지 않는 퍼블릭 메서드를 포함해서는 안됨. 클래스의 사용자로 하여금 이 클래스에 강하게 결합되도록 조장하기 때문
- 좀 더 철학적으로 보자면, 클래스가 존재하는 이유는 다른 누군가가 클래스의 서비스를 필요로 하기 떄문인데, 이 서비스는 계약이자 인터페이스이기 때문에 어딘가에는 문서화 되어야 하며, 서비스 제공자들은 서로 경쟁하기 때문에 각가의 경쟁자는 서로 다른 경쟁자로 쉽게 대체 할수 있어야함. 이것이 느슨한 결합도


