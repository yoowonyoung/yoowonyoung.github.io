---
layout: post
title: "Effective Java - 아이템85: 자바 직렬화의 대안을 찾으라"
description: 자바 직렬화의 대안을 찾으라
date: 2020-09-23 22:24:00 +09:00
categories: EffectiveJava Study
---


# 동시성

## 아이템 85 : 자바 직렬화의 대안을 찾으라

- 1997년, 자바에 처음으로 직렬화가 도입되었다. 프로그래머가 어렵지 않게 분산 객체를 만들 수 있다는 구호는 매력적이지만, 보이지 않는 생성자, API와 구현 사이의 모호한 경계, 잠재적인 정확성 문제, 성능, 보안 유지보수성 등 대가가 크다
    * 지지자들은 장점이 이러한 위험성을 압도한다고 생각했지만, 경험한바로는 반대다

- 직렬화의 근본적인 문제는 공격 범위가 너무 넓고, 지속적으로 더 넓어져 방어하기가 어렵다는점이다. ObjectInputStream의 readObject 메서드를 호출하면서 객체 그래프가 역직렬화 되기 때문이다. 
    * readObject 메서드는 클래스 패스 안의 거의 모든 타입의 객체를 만들어 낼 수 있는, 사실상 마법과 같은 생성자이다
    * 바이트 스트림을 역직렬화 하는 과정에서 이 메서드는 그 타입들 안의 모든 코드를 수행 할 수 있다. 그 타입들의 코드 전체가 공격 범위가 된다는것이다

- 자바의 표준 라이브러리나 Apache Commons 컬렉션과 같은 서드파티 라이브러리는 물론, 애플리케이션 자신의 클래스들도 공격 범위에 포함되는데, 관련한 모든 모범 사례를 따르고 모든 직렬화 가능 클래스들을 공격에 대비하도록 작성한다 해도, 애플리케이션은 여전히 취약 할 수 있다
- 다음은 CERT 조정 센터의 기술 관리자인 로버트 시커드가 한 말이다
    * 자바의 역직렬화는 명백하고 현존하는 위험이다. 이 기술은 지금도 어플리케이션에서 직접 혹은, 자바 하부 시스템(RMI, JMX, JMS)을 통해 간접적으로 쓰이고 있기 때문이다. 신뢰할 수 없는 스트림을 역직렬화 하면 원격 코드 실행, 서비스 거부등의 공격으로 이어질 수 있으며, 잘못한게 아무것도 없는 어플리케이션이라도 이런 공격에 취약 해 질 수 있다

- 공격자와 보안 전문가들은 자바 라이브러리와 널리 쓰이는 서드파티 라이브러리에서 직렬화 가능 타입들을 연구하여 역직렬화 과정에서 호출되어 잠재적으로 위험한 동작을 수행하는 메서드를 찾았는데, 이러한 메서드를 가젯이라 부르며 여러 가젯을 함께 사용하여 가젯 체인을 구성할 수도 있고, 가끔 공격자가 기반 하드웨어의 네이티브 코드를 마음대로 실행할 수 있는 가젯 체인이 발견되기도 한다
- 가젯까지 갈것도 없이, 역직렬화에 걸리는 시간이 오래 걸리는 짧은 스트림을 역직렬화 하는 것만으로도 서비스 거부 공격에 쉽게 노출 될 수 있다

```java
static byte[] bomb() {
    Set<Object> root = new HashSet<>();
    Set<Object> s1 = root;
    Set<Object> s2 = new HashSet<>();
    for(int i = 0; i < 100; i++) {
        Set<Object> t1 = new HashSet<>();
        Set<Object> t2 = new HashSet<>();
        t1.add("foo");//t1과 t2를 다르게 만듬
        s1.add(t1); s1.add(t2);
        s3.add(t1); s2.add(t2);
        s1 = t1;
        s2 = t2;
    }
    return serialize(root);
}
```

- 이 객체는 201개의 HashSet 인스턴스로 구성되며, 그 각각은 3개이하의 객체 참조를 갖는다. 스트림의 전체 크기는 5744바이트이지만, 역직렬화는 끝나지 않을것이다. HashSet 인스턴스를 역직렬화 하려면 그 원소들의 해시코드를 계산해야 한다는데 있다
    * 루트 HashSet에 담긴 두 원소는 다른 HashSet 2개씩을 원소로 갇는 HashSet이다. 그리고 반복문에 의해 이 깊이 구조가 100단계까지 만들어진다
    * 따라서 이 HashSet을 역직렬화 하려면 hashCode 메서드를 2^100넘게 호출해야 한다
    * 역직렬화가 끝나지 않는것도 문제이지만, 어디가 잘못되었다는 신호조차 주지 않는것이 문제이다

- 애초에 신뢰할 수 없는 바이트 스트림을 역직렬화 하는일 자체가 스스로를 공격에 노출하는 행위이다. 따라서 직렬화 위험을 회피하는 가장 좋은 방법은 아무것도 역직렬화 하지 않는것이다. 우리가 작성할 새로운 시스템에서 자바 직렬화를 써야할 이유는 전혀 없다. 다른 객체와 바이트 시퀀스를 변환하는 매커니즘이 많기 때문이다
- 이런 크로스-플랫폼 구조화된 데이터 표현들은 자바 직렬화보다 훨씬 간단하다. 이런 표현의 선두주자는 JSON과 프로토콜 버퍼이다
    * JSON은 자바스크립트용으로, 프로토콜 버퍼는 C++용으로 만들어지긴 하였다
    * JSON은 텍스트 기반이기 때문에 사람도 읽을 수 있고, 프로토콜 버퍼는 이진표현이라 효율이 훨씬 높다
    * JSON은 오직 데이터를 표현하는데에만 쓰이지만, 프로토콜 버퍼는 무서를 위한 스키마(타입)를 제공하고 올바로 쓰도록 강요한다

- 레거시 시스템 때문에 자바 직렬화를 완전히 배제 할 수 없을때 차선책은, 신뢰할 수 없는 데이터는 절대 역직렬화 하지 않는것이다. 특히 신뢰 할 수 없는 발신원으로부터의 RMI는 절대 수용 해서는 안된다
- 직렬화를 피할 수 없고, 역직렬화 한 데이터가 안전한지 완전히 확인 할 수 없다면 객체 역직렬화 필터링(java.io.ObjectInputFilter)를 사용하자. 객체 역직렬화 필터링은 데이터 스트림이 역직렬화 되기 이전에 필터를 설치하는 기능으로, 클래스 단위로 특정 클래스를 받아들이거나 거부 할 수 있다
    * 기본 수용 모드에서는 블랙리스트에 기록된 잠재적으로 위험한 클래스들을 거부하며, 기본 거부 모드에서는 화이트 리스트에 기록된 안전한 클래스들만 수용한다
    * 블랙리스트 방식보다는 화이트리스트 방식이 낫다

- 안타깝게도 역직렬화는 여전히 자바 생태계 곳곳에 쓰이고 있으며, 자바 직렬화를 사용하는 시스템을 관리해야 한다면 시간과 노력을 들여서라도 크로스-플랫폼 구조화된 데이터 표현으로 마이그레이션 하는것을 심각하게 고민 해보길 바란다