---
layout: post
title: "Kotlin Coroutine - 1, Hello Coroutine World!"
description: Kotlin Coroutine 1장
date: 2022-01-16 22:00:00 +09:00
categories: Kotlin Coroutine Study
---

# Hello Coroutine World!

## 코루틴
- 코틀린 문서에서는 코루틴을 경량 스레드라고 함. 대부분의 스레드와 마찬가지로 코루틴이 프로세서가 실행할 명령어 집합의 실행을 정의하며, 스레드와 비슷한 라이프 사이클을 갖고 있기 때문
- 스레드와 코루틴이 다른점은 코루틴이 빠르고 적은 비용으로 생성 할 수 있다는 것

```kotlin
suspend fun createCorutines(amount: Int) {
    val jobs = ArrayList<Jobs>()
    for(i int 1..amount) {
        jobs += launch {
            delay(1000)
        }
    }
    jobs.forEach {
        it.join()
    }
}

fun main(args: Array<String>) = runBlocking {
    val time = measureTimeMillis {
        createCoroutines(10000)
    }
    println(time)
}
```

- amount를 증가 시켜도 코틀린은 고정된 크기의 스레드 풀을 사용하고, 코루틴을 스레드들에 배포하기 떄문에 실행 시간은 매우 적게 증가한다
- 코루틴이 일시 중단 되는 동안(이 예제에서는 delay) 실행중인 스레드는 다른 코루틴을 실행하는데 사용되며 코루틴은 시작 또는 재개될 준비 상태가 된다
- 코루틴이 특정 스레드 안에서 실행 되더라도 스레드와 묶이지 않는다는점을 이해해야 한다. 코루틴의 일부를 특정 스레드에서 실행하고, 실행을 중지한 다음 다른 스레드에서 계속 실행하는것이 가능
- 스레드는 한번에 하나의 코루틴만 실행할 수 있기 때문에 프레임워크가 필요에 따라 코루틴을 스레드들 사이에서 옮기는 역할을 함

## 동시성에 대한 이해
- 올바른 동시성 코드는 결정론적 결과를 갖지만 실행 순서에서는 약간의 가변성을 허용하는 코드
- 순차적 코드의 문제점
    * 동시성 코드에 비해 성능이 저하될 가능성
    * 코드가 실행되는 하드웨어를 제대로 활용하지 못할 가능성

```kotlin
//순차적 코드
fun getProfile(id: Int) : Profile {
    val basicUserInfo = getUserInfo(id)
    val contactInfo = getContactInfo(id)

    return createProfile(basicUserInfo, contactInfo)
}


//동시성 코드
suspend fun getProfile(id: Int) {
    val basicUserInfo = asyncGetUserInfo(id)
    val contactInfo = asyncGetContactInfo(id)

    createProfile(basicUserInfo.await(), contactUserInfo.await())
}
```

- asyncGetUserInfo 와 asyncGetContactInfo의 실행이 서로 다른 스레드에서 실행 되고, asyncGetContactInfo의 실행이 asyncGetUserInfo의 완료에 좌우되지 않으므로 각 요청은 동시에 이뤄질수 있기 때문에 동시성 코드
- createProfile을 호출하면서 2개의 await을 함으로써 asyncGetUserInfo와 asyncGetUserInfo가 모두 완료될떄까지 getProfile의 실행을 일시 중단하고, 둘다 완료 됫을때만 createProfile을 수행. 어떤 동시성 호출이 먼저 종료 되던지간에 관계없이 getProfile의 결과가 결정론적임

## 동시성은 병렬성이 아니다
- 동시성은 두개 이상의 알고리즘의 실행 시간이 겹칠때 발생한다. 중첩이 발생하려면 2개 이상의 스레드가 필요하며, 이런 스레드들이 단일 코어에서 실행되면 병렬이 아니라 동시에 실행 되는데, 단일 코어가 서로 다른 스레드의 인스트럭션을 교차 배치 해서 스레드들의 실행을 효율적으로 겹쳐서 실행한다
- 병렬성은 2개의 알고리즘이 정확히 같은 시점에 실행 될때 발생 한다. 이것이 가능 하려면 2개 이상의 코어와 2개 이상의 스레드가 있어야 각 코어가 동시에 스레드의 인스트럭션을 실행할 수 있다
- 병렬은 동시성을 의미 하지만, 동시성은 병렬성이 없이도 발생할 수 있다

## CPU바운드와 I/O 바운드
- 동시성이나 병렬성이 CPU나 I/O연산에 바인딩 됬는지 여부에 따라 알고리즘의 성능에 어떻게 영향을 미치는지 알아야함
- CPU바운드: CPU만 완료하면 되는 작업. CPU성능에 좌우됨. 코드를 더 빠른 CPU에서 실행하면 코드의 변경 없이도 성능이 향상
- I/O바운드: 실행시간이 입출력장치의 속도에 따라 달라짐. 네트워킹이나 컴퓨터 주변기기로부터 입력을 받는 작업도 I/O작업. 최적화가 외부 시스템이나 장치에 의존
- CPU바운드 알고리즘에서의 동시성과 병렬성
    * 다중 코어에서 병렬성을 활용하면 성능을 향상 시킬수 있음: 각 스레드가 하나의 전용 코어에서 실행된다고 가정하면 실행 시간이 줄어듬
    * 단일 코어에서 동시성을 구현하면 성능이 저하: 하나의 코어가 여러개의 스레드 사이에서 매번 일정량의 작업을 하고 다음 스레드로 전환되기 때문에 컨텍스트 스위칭으로 인해 오버헤드 발생

- I/O바운드 아록리즘에서의 동시성대 병렬성
    * 동시성 알고리즘은 병렬이거나 단일코어에 상관없이 유사하게 수행. 항상 순차적 구현보다 동시성 구현에서 더 나은 성능을 발휘할것으로 예상됨

## 동시성이 어려운이유
- 레이스 컨디션: 코드를 동시적으로 작성했지만 순차적 코드처럼 동작할것이라고 예상할때 발생. 동시성 코드가 항상 특정한 순서대로 실행될것이라 가정하고 오해할때 발생
- 원자성 위반: 작업이 사용하는 데이터를 간섭 없이 접근 가능할때. 수정이 겹쳐서 데이터 손실이 발생할수도 있음
- 교착상태: 동시성 코드가 올바르게 동기화 되려면 다른 스레드에서의 작업이 완료되는동안 실행을 일시 중단하거나 차단할 필요가 있는데, 순환적 의존성으로 인해 전체 애플리케이션의 실행이 중단될수도 있음
- 라이브락: 애플리케이션이 올바르게 실행을 계속할 수 없을때 발생하는 교착 상태. 라이브락이 진행 될때 애플리케이션의 상태는 지속적으로 변하지만 애플리케이션이 정상 실행으로 돌아오지 못하게 하는 방향으로 상태가 변함


## 코틀린에서의 동시성
- 넌 블러킹: 스레드의 블로킹은 자원이 낭비되는것이니, 코틀린은 중단 가능한 연산을 통해 스레드의 실행을 블로킹하지 않으면서 실행을 잠시 중단함. channel, actor, mutual exclusions와 같은 기본형이 제공되어 스레드를 블록하지 않고 동시성 코드를 효과적으로 통신하고 동기화 하는 매커니즘 제공
- 명시적인 선언: 중단 가능한 연산은 기본적으로 순차적으로 실행(스레드가 블로킹 되지 않아 직접적인 단점은 아님). 필요에 따라 명시적으로 동시에 수행 가능
- 가독성: 동시성 코드가 순차 코드처럼 읽기 쉬움
- 기본형 활용
    * 스레드는 스레드 이름을 파라미터로 하는 newSingleThreadContext()를 호출하면 생성됨. 생성되면 필요한만큼 많은 코루틴을 수행하는데 사용할 수 있음
    * 스레드 풀은 크기와 이름을 파라미터로 하는 newFixedThreadPoolContext()를 호출하면 쉽게 생성 가능
    * CommonPool은 CPU바운드 작업에 최적인 스레드 풀. 최대 크기는 시스템의 코어 -1
    * 코루틴을 다른 스레드로 이동시키는 역할은 런타임이 담당
    * 채널, 뮤텍스 및 스레드 한정과 같은 코루틴의 통신과 동기화를 위해 필요한 많은 기본형과 기술이 제공

- 유연성
    * channel: 코루틴간에 데이터를 안전하게 보내고 받는데 사용할 수 있는 파이프
    * worker pools: 많은 스레드에서 연산 집합의 처리를 나눌 수 있는 코루틴의 풀
    * actor: 채널과 코루틴을 사용하는 상태를 감싼 래퍼로 여러 스레드에서 상태를 안전하게 수정하는 매커니즘 제공
    * mutexs: 크리티컬 존 영억을 정의해 한번에 하나의 스레드만 실행할 수 있도록 하는 동기화 매커니즘. 크리티컬존에 엑세스 하려는 코루틴은, 이전의 코루틴이 크리티컬존을 빠져나올때까지 대기
    * thread confinement: 코루틴의 실행을 제한해서 지정된 스레드에서만 실행 하도록 하는 기능
    * 생성자(반복자 및 시퀀스): 필요에따라 정보를 생성할 수 있고 새로운 정보가 필요하지 않을떄 일시 중단 될 수 있는 데이터 소스

## 코틀린 동시성 관련 개념과 용어
- 일시 중단 연산: 해당 스레드를 차단하지 않고 실행을 일시 중지 할 수 있는 연산
- 일시 중단 함수: 함수 형식의 일시 중단 연산. suspend로 쉽게 식별 가능
- 람다 일시 중단: 일시 중단 람다 역시 익명의 로컬 함수. 다른 일시 중단 함수를 호출 함으로써 자신의 실행을 중단할 수 있음
- 코루틴 디스패처: 코루틴을 시작하거나 재개할 스레드를 결정하기 위해 코루틴 디스패처 사용. CoroutineDispatcher 인터페이스의 구현체들
    * DefaultDispatcher: CommonPool과 동일(변경 될수도 있음)
    * CommonPool: 공유된 백그라운드 스레드풀에서 코루틴을 실행하고 다시 시작. 기본 크기는 CPU바운드 작업에 사용하기 적합
    * Unconfined: 코루틴이 호출된 스레드에서 코루틴을 시작하지만, 어떤 스레드에서도 코루틴이 다시 재개 될 수 있음. 디스패처에서 스레드 정책을 사용하지 않음
    * 필요에 따라 풀 또는 스레드를 정의하는데 사용할 수 있는 빌더들이 있음
        + newSingleThreadContext: 단일 스레드로 디스패처 생성. 코루틴이 항상 같은 스레드에서 시작되고 재개됨
        + newFixedThreadPoolContext: 지정된 크기의 스레드풀이 있는 디스패처. 런타임이 디스패처에서 실행된 코루틴을 시작하고 재개할 스레드를 결정

- 코루틴 빌더: 일시 중단 람다를 받아 그것을 실행시키는 코루틴을 생성하는 함수
    * async: 반환값이 있는 코루틴을 시작하는데 사용. 코루틴 내부에서 일어나는 모든 예외를 캡처해서 결과에 넣기 떄문에 조심 해야함. 결과 또는 예외를 포함하는 Defferred를 반환
    * launch: 결과를 반환하지 않는 코루틴을 시작. 자체 혹은 자식 코루틴의 실행을 취소하기 위해 사용할 수 있는 Job을 반환
    * runBlocking: 블로킹 코드를 일시 중단 가능한 코드로 연결하기 위해 작성. 보통 main이나 단위테스트에서 사용. 코루틴의 실행이 끝날떄까지 현재 스레드를 차단

## 요약
- 어플리케이션에는 하나 이상의 프로세스가 존재. 각각은 적어도 하나의 스레드를 갖고있고 코루틴은 스레드 안에서 실행
- 코루틴은 재개 될 때마다 다른 스레드에서 실행 될 수 있지만, 특정 스레드에서만 국한 될수도 있음
- 애플리케이션이 하나 이상의 스레드에 중첩되어 실행되는 경우는 동시적 실행
- 올바른 동시성 코드를 작성 하려면 서로 다른 스레드간의 통신과 동기화 방법을 배워야 하며, 코틀린에서는 코리틴의 통신과 동기화 방법을 학습 해야함
- 병렬 처리는 동시 처리 어플리케이션이 실행 되는동안 적어도 두개 이상의 스레드가 같이 실행 될 떄를 말함
- 동시 처리는 병렬 처리 없이 일어날 수 있음
- 동시성 코드를 작성하는데는 어려움이 많음. 레이스 컨디션, 원자성 위반, 교착 상태 및 라이브락이 가장 일반적인 문제
- 코틀린은 동시성에 대해 현대적인 접근방법을 사용해 넌블러킹으로 동작하며 가독성이 있고 유연하게 작성 가능