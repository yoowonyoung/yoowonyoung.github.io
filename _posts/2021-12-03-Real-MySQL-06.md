---
layout: post
title: "Real MySQL 09 : 옵티마이저와 힌트"
description: Real MySQL 9장 - 옵티마이저와 힌트
date: 2021-12-03 18:13:00 +09:00
categories: MySQL RealMySQL Study
---

# 옵티마이저와 힌트

## 개요

### 쿼리 실행 절차
- MySQL에서는 쿼리가 다음과 같은 과정으로 실행됨
    * SQL 파싱: 사용자로부터 요청된 SQL을 잘개 쪼개서 MySQL서버가 이해 할 수 있는 수준으로 분리(파스 트리). SQL파서 모듈이 처리하면 문법적으로 잘못된건 이 단계에서 걸러짐
    * 최적화 및 실행 계획 수립: SQL의 파싱 정보(파스 트리)를 확인 하면서 어떤 테이블부터 읽고 어떤 인덱스를 이용해 테이블을 읽을지 선택
        + 불필요한 조건 제거 및 복잡한 연산의 단순화
        + 여러 테이블의 조인이 있는 경우 어떤 순서로 테이블을 읽을지 결정
        + 각 테이블에 사용된 조건과 인덱스 통계 정보를 이용해 사용할 인덱스를 결정
        + 가쳐온 레코드들을 임시 테이블에 넣고 다시 한번 가공해야 하는지 결정
    * 두번째 단계에서 결정된 테이블의 읽기 순서나 선택된 인덱스를 이용해 스토리지엔진으로부터 데이터를 가져옴

### 옵티마이저의 종류
- 규칙 기반 최적화
    * 대상 테이블의 레코드 건수나 선택도 등을 고려하지 않고, 옵티마이저에 내장된 우선순위에 따라 실행 계획을 수립
    * 통계정보를 이용하지 않기 때문에 같은 쿼리에 대해서는 거의 항상 같은 실행 방법을 만들어냄
    * 거의 사용되지 않음

- 비용 기반 최적화
    * 쿼리를 처리하기위한 여러 가지 가능한 방법들을 만들고, 각 단위 작업의 비용(부하)정보와 대상 테이블의 예측된 통계 정보를 이용해 실행 계획별 비용 산출
    * 산출된 실행 방법 별로 최소로 소요되는 처리 방식을 선택해 최종적으로 쿼리를 실행


## 기본 데이터 처리

### 풀 테이블 스캔과 풀 인덱스 스캔
- 풀 테이블 스캔이란 인덱스를 사용하지 않고 테이블의 데이터를 처음부터 끝까지 읽어서 요청된 작업을 처리하는 작업
- 다음과 같은 조건이 일치하면 주로 풀 테이블 스캔
    * 테이블의 레코드 건수가 너무 작아서 인덱스를 통해 읽는것보다 풀 테이블 스캔이 빠른경우(테이블이 페이지 1개로 구성된 경우)
    * WHERE 절이나 ON절에 인덱스를 이용할 수 있는 적절한 조건이 없는경우
    * 인덱스 레인지 스캔을 사용할 수 있는 쿼리라 하더라도, 옵티마이저가 판단한 조건 일치 레코드 건수가 너무 많은 경우(인덱스의 B-Tree를 샘플링 해서 조사한 통계 정보 기준)

- InnoDB스토리지 엔진은 특정 테이블의 연속된 데이터 페이지가 읽히면 백그라운드 스레드에 의해 Read ahead 작업이 자동으로 실행
    * Read ahead란 어떤 영역의 데이터가 앞으로 필요해질것이라고 예측해서 요청이 오기전에 미리 디스크에서 읽어 InnoDB의 버퍼풀에 적재하는 것

- InnoDB에서 풀 테이블 스캔이 일어나면 처음 몇개의 데이터 페이지는 포그라운드 스레드가 페이지 읽기를 실행 하지만, 특정 시점 부터는 읽기 작업을 백그라운드 스레드로 넘김
- 백그라운드 스레드가 읽기를 넘겨 받는 시점부터 한번에 4개 또는 8개씩의 페이지를 읽으며 계속 그 수를 증가(한번에 64개 데이터 페이지까지). 포그라운드 스레드는 미리 버퍼 풀에 준비된 데이터를 가져다 사용하므로 쿼리가 상당히 빨리 처리
- innodb_read_ahead_threshold 시스템 변수를 이용해 언제 Read ahead를 시작 할지 임계값을 설정할 수 있음
- Read ahead는 풀 인덱스 스캔에서도 동일하게 적용

### 병렬 처리
- innodb_parallel_read_threads 시스템 변수를 이용해 하나의 쿼리를 최대 몇 개의 스레드를 이용해서 처리할지 변경 가능
- MySQL서버에서 쿼리를 여러개의 스레드를 이용해 병렬로 처리하는 힌트나 옵션은 없음. 아무런 WHERE 조건 없이 단순히 테이블 전체의 건수를 가져오는 쿼리만 병렬로 가능

### ORDER BY 처리(Using filesort)
- 정렬을 처리하는 방법은 인덱스를 이용하는 방법과 쿼리가 실행될 때 Filesort라는 별도의 처리를 이용하는 방법으로 나눌 수 있음
- 인덱스 이용
    * 장점: INSERT, UPDATE, DELETE 쿼리가 실행될 때 이미 인덱스가 정렬되있어 순서대로 읽기만 하면 되므로 매우 빠름
    * 단점: INSERT, UPDATE, DELETE 작업시 부가적인 인덱스 추가/삭제 작업이 필요. 인덱스 떄문에 디스크 공간이 더 필요. 인덱스의 개수가 늘어날수록 InnoDB 버퍼 풀을 위한 메모리가 많이 필요

- Filesort 이용
    * 장점: 인덱스를 생성하지 않아도 되므로 인덱스의 단점이 장점. 정렬해야할 레코드가 많지 않으면 메모리에서 Filesort가 되므로 충분히 빠름
    * 단점: 정렬 작업이 쿼리 실행시 처리되므로 레코드 대상 건수가 많을수록 쿼리 응답 속도가 느림

- 다음과 같은 경우에서는 정렬을 인덱스를 이용하도록 튜닝하기가 힘듬
    * 정렬 기준이 너무 많아서 요건별로 인덱스를 생성하기가 힘든 경우
    * GROUP BY 결과 또는 DISTINCT 같은 처리의 결과를 다시 정렬해야 하는경우
    * UNION의 결과와 같이 임시 테이블의 결과를 다시 정렬해야 하는경우
    * 랜덤하게 결과 레코드를 가져와야 하는 경우

- MySQL 서버에서 인덱스를 사용하지 않고 별도의 정렬 처리를 수행했는지는 실행 계획의 Extra칼럼의 Using Filesort 메시지가 표시되는지 여부로 판단
- 소트 버퍼
    * 정렬을 수행하기 위해 할당받는 별도의 메모리 공간. 정렬이 필요한 경우에만 할당되며, 버퍼의 크기는 정렬해야할 레코드의 크기에 따라서 가변적으로 증가. 쿼리의 실행이 완료되면 즉시 시스템으로 반납
    * 정렬해야할 레코드의 건수가 소트 버퍼로 할당된 공간보다 크다면 정렬해야할 레코드를 여러 조각으로 나눠서 처리하는데, 이때 임시 저장을 위해 디스크를 사용
    * 소트버퍼에서 정렬을 수행하고, 그 결과를 임시로 디스크에 기록하고, 다음 레코드를 가져와 다시 정렬해서 반복적으로 디스크에 저장하고, 정렬된 레코드들을 다시 병합하면서 정렬을 수행하는 멀티 머지 형태
    * 디스크의 읽기와 쓰기가 유발되며, 레코드의 건수가 많아질수록 이 반복작업의 횟수가 늘어남
    * 너무 큰 소트 버퍼 사이즈를 이용하는경우, 큰 메모리 공간 할당때문에 성능이 오히려 떨어질 수 있음

- 정렬 알고리즘
    * 레코드를 정렬할 때 전체 레코드를 소트 버퍼에 담을지 또는 정렬 기준 칼럼만 소트 버퍼에 담을지에 따라 싱글 패스와 투 패스 2가지 정렬 모드로 나눌 수 있음
    * ```<sort_key, rowid>```: 정렬 키와 레코드의 로우 아이디만 가져와서 정렬하는 방식(투패스 정렬)
    * ```<sort_key, additional_fields>```:  정렬 키와 레코드 전체를 가져와서 정렬하는 방식으로, 레코드의 칼럼들은 고정 사이즈 메모리로 저장(싱글패스 정렬)
    * ```<sort_key, packed_additional_fields>```: 정렬 키와 레코드 전체를 가져와서 정렬하는 방식으로, 레코드들의 칼럼들은 가변 사이즈 메모리로 저장(싱글패스 정렬)
    * 싱글패스 정렬방식: 소트 버퍼에 정렬 기준 칼럼을 포함해 SELECT 대상이 되는 칼럼 전부를 담아서 정렬을 수행하는 정렬 방식
    * 투패스 정렬방식: 정렬 대상 칼럼과 프라이머리 키값만 소트 버퍼에 담아서 정렬을 수행, 정렬된 순서대로 다시 프라이머리 키로 테이블들을 읽어서 SELECT할 칼럼을 가져오는 정렬방식
    * 투패스 방식은 테이블을 두번 읽어야 하기 떄문에 요 근래는 싱글 패스방식을 주로 사용. 반면 싱글 패스 정렬 방식은 더 많은 소트 버퍼 공간이 필요
    * 레코드의 크기가 max_length_for_sort_data 시스템 변수보다 크거나, BLOB나 TEXT타입의 칼럼이 SELECT 대상에 포함되면 투패스 정렬방식이 사용

- 정렬 처리 방법
    * 쿼리에 ORDER BY가 사용되면 다음 3가지 처리 방법중 하나로 정렬, 아래로 갈수록 처리 속도가 떨어짐
        + 인덱스를 사용한 정렬
        + 조인에서 드라이빙 테이블만 정렬: 실행 계획의 Extra 칼럼에 Usiing Filesort 메시지 표시
        + 조인에서 조인 결과를 임시 테이블로 저장 후 정렬: Using temporary; Using Filesort 메시지 표시
    
    * 옵티마이저는 정렬 처리를 위해 인덱스를 이용할 수 있을지를 검도. 인덱스를 이용할 수 있다면 별도의 Filesort과정 없이 인덱스를 순서대로 읽어서 결과 반환
    * 인덱스를 사용할 수 없다면 WHERE 조건에 일치하는 레코드를 검색해 정렬 버퍼에 저장하며 정렬을 처리(Filesort)할 것
    * MySQL 옵티마이저는 정렬 대상 레코드를 최소화 하기 위해 조인의 드라이빙 테이블만 정렬한 다음 조인을 수행하거나, 조인이 끝나고 일치하는 레코드를 모두 가져온후 정렬을 수행
    * 인덱스를 이용한 정렬
        + 인덱스를 이용한 정렬을 위해서 반드시 ORDER BY에 명시된 칼럼이 제일 먼저 읽는 테이블(드라이빙 테이블)에 속하고, ORDER BY의 순서대로 생성된 인덱스가 있어야함
        + WHERE절에 첫번째로 읽는 테이블의 칼럼에 대한 조건이 있다면, 그 조건과 ORDER BY는 같은 인덱스를 쓸 수 있어야함
        + B-Tree 계열의 인덱스가 아닌 다른 인덱스에서는 인덱스를 이용한 정렬을 할 수 없음(R-Tree도 불가)
        + 여러 테이블이 조인되는 경우 네스티드 루프 조인에서만 가능
        + 인덱스를 이용해 정렬이 처리되는 경우에는 실제 인덱스의 값이 정렬돼있기 떄문에 인덱스의 순서대로 읽기만 하면됨. 별도의 정렬을 위한 추가 작업은 수행하지 않음

    * 조인의 드라이빙 테이블만 정렬
        + 조인을 실행하기전에 첫번째 테이블의 레코드를 먼저 정렬 한 다음 조인을 실행하는것이 좋은데, 이 방법으로 정렬이 처리되려면 조인에서 첫번째로 읽히는 테이블(드라이빙 테이블)의 칼럼만으로 ORDER BY절을 작성 해야함

    * 임시 테이블을 이용한 정렬
        + 2개 이상의 테이블을 조인해서 그 결과를 정렬 해야 한다면 임시 테이블이 필요할 수도 있다
        + 조인의 드라이빙 테이블만 정렬은 2개 이상의 테이블이 조인되면서 정렬이 실행되지만 임시테이블을 사용하지 않음. 그 이외의 패턴의 쿼리에서는 항상 조인의 결과를 임시 테이블에 저장해야하고 그 결과를 정렬하는 과정을 거침
    
    * 정렬 처리 방법의 성능 비교
        + 스트리밍 처리: 서버쪽에서 처리할 데이터가 얼마인지에 관계 없이 조건에 일치하는 레코드가 검색될때마다 바로바로 클라이언트에 전송해주는 방식
        + 버퍼링 방식: ORDER BY나 GROUP BY와 같은 경우 조건에 일치하는 모든 레코드를 가져와 정렬하거나 그루핑 해서 보내야 하기 때문에 스트리밍 불가. 그래서 버퍼링이 걸린다 하여 버퍼링 방식
        + 인덱스를 사용한 정렬 방식만 스트리밍 형태의 처리이며, 나머지 처리 방식들은 버퍼링 이후 정렬
        
- 정렬 관련 상태 변수
    * sort_merge_passes: 멀티 머지 처리 횟수
    * sort_range: 인덱스 레인지 스캔을 통해 검색된 결과에 대한 정렬 횟수
    * sort_scan: 풀 테이블 스캔을 통해 검색된 결과에 대한 정렬 작업 횟수
    * sort_rows: 지금까지 정렬한 전체 레코드 건수

### GROUP BY 처리
- GROUP BY는 스트리밍 처리를 불가능하게 하며, GROUP BY에 사용된 조건을 인덱스를 사용해 처리될 수없으므로 HAVING절을 튜닝 하려고 인덱스를 생성하거나 다른 고민을 할 필요가 없음
- GROUP BY도 인덱스를 사용하는 경우와 그렇지 못한 경우로 나뉘는데, 인덱스를 사용하면 인덱스 스캔과 인덱스 루스 스캔이 가능하며, 인덱스를 사용하지 못하는 경우엔 임시테이블이 사용됨
- 인덱스 스캔을 이용하는 GROUP BY(타이트 인덱스 스캔)
    * ORDER BY와 마찬가지로 조인의 드라이빙 테이블에 속한 칼럼만 사용해 그루핑 할때
    * GROUP BY가 인덱스를 사용해서 처리된다 하더라도 그룹 함수등 그룹값을 처리해야 해서 임시 테이블이 필요 할 수도 있음
    * GROUP BY가 인덱스를 통해 처리되는 쿼리는 이미 정렬된 인덱스를 읽는 것이므로 쿼리 실행 시점에 추가 정렬작업이나 내부 인덱스 필요 X

- 루스 인덱스 스캔을 이용하는 GROUP BY
    * 루스 인덱스 스캔을 사용하면 실행 계획의 Extra 칼럼에 Using index for group-by가 표시
    * MySQL의 루스 인덱스 스캔 방식은 단일 테이블에 대해 수행되는 GROUP BY 처리에만 사용 가능
    * 프리픽스 인덱스는 루스 인덱스 스캔 사용 불가
    * 루스 인덱스 스캔은 분포도가 좋지 않은 인덱스일수록 더 빠른 결과를 만들어내며, 별도의 임시 테이블 필요 X

- 임시 테이블을 사용하는 GROUP BY
    * GROUP BY의 기준 칼럼이 드라이빙 테이블에 있던, 드리븐 테이블에 있든 상관 없이 인덱스를 전혀 사용하지 못할때
    * 실행 계획의 Extra 칼럼에 Using temporary만 표시됨. 묵시적인 정렬이 실행되지 않기 때문(MySQL 8.0 이후)
    * MySQL 8.0에서는 GROUP BY가 필요한경우 내부적으로 GROUP BY절의 칼럼들로 구성된 유니크 인덱스를 가진 임시 테이블을 만들어 중복제거와 집합 함수 연산을 수행. 별도의 정렬 작업이 필요 없음
    * MySQL 8.0에서도 GROUP BY와 ORDER BY가 같이 사용되면 명시적으로 정렬 작업 수행

### DISTINCT 처리
- SELECT DISTINCT
    * 단순 SELECT 되는 레코드중에서 유니크한 레코드만 가져오고자 하는 경우. GROUP BY와 동일한 방식
    * DISTINCT 사용시 주의 해야 할것이 SELECT하는 레코드를 유니크하게 SELECT하는것이지 특정 칼럼만 유니크하게 조회하는것은 아님
    * SELECT 절에 사용된 DISTINCT는 모든 조회되는 칼럼에 영향을 미침. 일부 칼럼만 유니크하게 조회하는것이 아니라는것에 주의

- 집합함수와 함께 사용된 DISTINCT
    * COUNT(), MIN(), MAX()와 같은 집합 함수 내에서 DSITINCT가 사용될 수 있는데, 이 경우 집합 함수 인자로 전달된 칼럼 값이 유니크한 것들을 가져옴
    * 내부적으로 DISTINCT를 처리 하기 위해 임시 테이블을 사용하지만, 실행 계획에서 Using temporary가 표시 되지는 않음
    * 임시테이블이 생성되기 때문에 레코드 건수가 많아진다면 상당히 느려질 수 있는 형태의 쿼리

### 내부 임시 테이블 활용
- MySQL 엔진이 스토리지 엔진으로부터 받아온 레코드를 정렬하거나 그루핑 할때는 내부적인 임시 데이터 테이블을 사용. CREATE TEMPORARY TABLE 명령과는 다른 임시 테이블이 생성됨
- MySQL 엔진이 내부적인 가공을 위해 생성하는 임시 테이블은 다른 세션이나 다른 쿼리에서는 볼 수 없으며 사용도 불가능하고, 쿼리의 처리가 완료되면 자동으로 삭제
- 메모리 임시 테이블과 디스크 임시 테이블
    * MySQL 8.0이전 까지는 원본 테이블의 스토리지 엔진과 상관 없이 임시 테이블이 메모리를 사용하는 MEMORY 스토리지 엔진을 사용하며, 디스크에 저장될때는 MyISAM 스토리지 엔진을 이용
    * MySQL 8.0부터는 메모리를 사용할 경우 TempTable이라는 스토리지 엔진을 사용하고, 디스크에 저장될때는 InnoDB 스토리지 엔진
    * MEMORY 스토리지 엔진은 가변 길이 타입을 지원하지 못하지만 TempTable은 지원
    * MyISAM은 트랜잭션이 지원되지 않지만 InnoDB는 트랜잭션이 지원
    * internal_tmp_mom_stroage_engine 시스템 변수로 메모리용 임시 테이블을 선택할수있음
    * tempable_max_ram 변수로 TempTable이 사용 가능한 메모리 공간을 지정하며 이 이상 커지면 디스크로 기록. 디스크에 기록 할떄는 MMAP파일로 디스크에 기록하거나 InnoDB 테이블로 기록
    * temptable_use_mmap의 기본값은 ON인데, ON되있으면 TempTable을 MMAP로 전환해서 저장. TempTable을 MMAP파일로 전환하는게 InnoDB 테이블로 전환하는것보다 오버헤드가 적기 떄문

- 임시 테이블이 필요한 쿼리
    * ORDER BY와 GROUP BY에 명시된 칼럼이 다른 쿼리
    * ORDER BY나 GROUP BY에 명시된 칼럼이 조인의 순서상 첫번째 테이블이 아닌 쿼리
    * DISTINCT와 ORDER BY가 동시에 쿼리에 존재하거나, DISTINCT가 인덱스로 처리되지 못하는 쿼리
    * UNION이나 UNION DISTINCT가 사용된 커리
    * 쿼리의 실행 계획에서 select_type이 DERIVED인 쿼리(유니크 인덱스가 없는 내부 임시 테이블이 생성되어 처리 성능이 느려짐)

- 임시 테이블이 디스크에 생성되는 경우
    * UNION이나 UNION ALL에서 SELECT되는 칼럼중에서 길이가 512바이트 이상인 크기의 칼럼이 있는 경우
    * GROUP BY나 DISTINCT 칼럼에서 512바이트 이상인 크기의 칼럼이 있는 경우
    * 메모리 임시 테이블의 크기가 tem_table_size또는 max_heap_table_size보다 크거나 temptable_max_ram보다 큰 경우

- 임시 테이블 관련 상태 변수
    * Created_tmp_disk_tables: 디스크 내부에 임시 태이블이 만들어진 개수를 누적
    * Created_tmp_tables: 쿼리의 처리를 위해 만들어진 내부 임시 테이블의 개수를 누적(메모리 or 디스크 상관없이)
    * 둘다 누적임으로 쿼리 실행 전에 FLUSH STATUS 명령으로 현재 세션값 초기화 하고 조회 할것 

## 고급 최적화
- MySQL 서버의 옵티마이저가 실행 계획을 수립할때 통계 정보와 옵티마이저 옵션을 결합해서 최적의 실행 계획을 수립
- 옵티마이저 옵션은 조인과 관련된 옵티마이저 옵션과 옵티마이저 스위옵션으로 구분됨

### 옵티마이저 스위치 옵션
- optimizer_switch 시스템 변수를 이용해 제어하는데, 여러개의 옵션은 세트로 묶어서 설정하는 방식
- 옵티마이저 스위치 옵션은 글로벌과 세션별 모두 설정할 수 있는 시스템 변수 이므로, MySQL서버 전체저긍로 또는 현재 커넥션에 대해서만도 설정 가능
- MRR과 배치 키 엑세스
    * MRR은 Multi Range Read를 줄여서 부르는 이름
    * MySQL 서버에서 지금까지 지원하던 조인 방식은 드라이빙 테이블의 레코드를 한건 읽어서 드리븐 테이블의 일치하는 레코드를 찾아서 조인을 수행. 이것을 Nested Loop Join이라고 함. 스토리지 엔진에서 최적화 수행 불가
    * MRR은 드라이빙 테이블의 레코드를 읽어서 드리븐 테이블과의 조인을 즉시 실행하지 않고, 조인 대상을 버퍼링 하고 조인 버퍼에 레코드가 가득 차면 비로소 MySQL엔진은 버퍼링된 레코드를 스토리지 엔진으로 한번에 요청
    * MRR을 응용해서 실행되는 조인 방식을 BKA(Batched Key Access)조인이라고 함. BKA는 기본적으로 비활성화. 부가적인 정렬작업이 필요해서 오히려 성능에 안좋을수 있기 때문

- 블록 네스티드 루프 조인
    * 네스티드 루프 조인과 블록 네스티드 루프 조인의 가장 큰 차이는 조인 버퍼가 사용되는지 여부와 조인에서 드라이빙 테이블과 드리븐 테이블이 어떤 순서로 조인 되느냐임
    * 어떤 방식으로든 드리븐 테이블의 풀 테이블 스캔이나 인덱스 풀 스캔을 피할수 없다면 옵티마이저는 드라이빙 테이블에서 읽은 레코드를 메ㅗ리에 캐시한 후, 드리븐 테이블과 이 메모리 캐시를 조인하는 형태로 처리. 이때 사용되는 메모리의 캐시를 조인 버퍼라고 함
    * 조인 버퍼가 사용되는 쿼리에서는 조인의 순서가 거꾸로인것처럼 수행. 드라이빙 테이블의 결과는 조인 버퍼에 담아두고, 드리븐 테이블을 먼저 읽고 조인 버퍼에서 일치하는 레코드를 찾는 방식으로 처리
    * 일반적으로 조인이 수행된후 가져오는 결과는 드라이빙 테이블의 순서에 의해 결정되지만, 조인 버퍼가 사용되는 조인에서는 결과의 정렬 순서가 흐트러질 수 있음을 기억 해야함

- 인덱스 컨디션 푸시다운
    * MySQL 5.6 부터는 인덱스를 범위 제한 조건으로 사용하지 못한다고 하더라도 인덱스에 포함된 칼럼의 조건이 있다면 모드 같이 모아서 스토리지 엔진으로 전달할 수 있게 핸들러 API가 개선됨

- 인덱스 확장
    * use_index_extensions 옵티마이저 옵션은 InnoDB 스토리지 엔진을 사용하는 테이블에서 세컨더리 인덱스에 자동으로 추가된 프라이머리 키를 활용할 수 있게 할지를 결정하는 옵션
    * 세컨더리 인덱스는 데이터 레코드를 찾아가기 위해 프라이머리키에 명시된 칼럼을 프라이머리 키에 명시된 순서대로 포함하는데, MySQL서버가 업데이트 됨에 따라 옵티마이저가 세컨더리 인덱스에 숨어있는 프라이머리 키에 있는 칼럼들을 인지하고 실행 계획을 수립 가능

- 인덱스 머지
    * 인덱스 머지 실행 계획을 사용하면 하나의 테이블에 대해 2개 이상의 인덱스를 이용해 쿼리를 처리
    * 하나의 인덱스만을 사용해서 작업 범위를 줄일 수 있는 경우라면 테이블별로 하나의 인덱스만 사용하는것이 효율적

- 인덱스 머지 - 교집합
    * 실행 계획의 Extra 칼럼에 Using intersect라고 표시되면 이 쿼리가 여러개의 인덱스를 각각 검색해서 그 결과의 교집합만 반환했다는 뜻
    * 여러 인덱스중 하나만 사용해도 충분히 효율적이라면 옵티마이저는 이런 실행 계획을 사용하지 않음

- 인덱스 머지 - 합집합
    * Where절에 사용된 2개 이상의 조건이 각각의 인덱스를 사용하되 OR연산자로 연결된 경우에 사용하는 최적화
    * 쿼리의 실행 계획에 Extra칼럼에 Using union이라고 표시되는것
    * 인덱스 머지 최적화의 Union 알고리즘은 MySQL 서버가 두 집합에서 하나씩 가져와서 서로 비교하면서 프라이머리키의 칼럼이 중복된 레코드들을 정렬없이 걸러내는데, 이때 사용되는 알고리즘이 우선순위 큐
    * 2개의 WHERE조건이 OR연산자로 연결된 경우에는 둘 중 하나라도 제대로 인덱스를 사용하지 못한다면 항상 풀 테이블 스캔으로밖에 처리하지 못함

- 인덱스 머지 - 정렬 후 합집합
    * 인덱스 머지 작업을 사용하는 도중 결과의 정렬이 필요한 경우
    * 두 쿼리의 정렬이 일치하지 않는 경우 중복을 제거하기 위해 우선순위 큐를 사용하는것이 불가능 하기 때문에 MySQL 서버는 두 집합의 결과에서 중복을 제거하기 위해 각 집합을 정렬한 후 중복 제거를 수행

- 세미 조인
    * 다른 테이블과 실제 조인을 수행하지는 않고, 단지 다른 테이블에서 조건에 일치하는 레코드가 있는지만 체크하는 형태의 쿼리를 세미 조인이라고 함
    * =, IN 형태의 세미 조인 쿼리는 세미 조인 최적화, IN-to-EXIST 최적화, MATERIALIZATION 최적화를 사용 가능
    * <>, NOT IN 형태의 안티 세미 조인 쿼리는 IN-to-EXIST 최적화, MATERIALIZATION 최적화를 사용 가능
    * 세미조인 쿼리의 성능을 개선하기 위한 최적화 전략을 세미 조인 최적화라고 하며 Table Pull-out, Duplicated Weed-out, Fist Match, Loose Scan, Materialization 이 있음

- 테이블 풀 아웃
    * 세미 조인의 서브쿼리에 사용된 테이블을 아우터 쿼리로 끄집어 낸 후에 쿼리를 조인 쿼리로 재작성 하는 형태의 최적화
    * Table pullout 최적화가 사용됬는지는 실행 계획에서 해당 테이블들의 id컬럼값이 같은지를 비교 해보면서 Extra 칼럼에 아무것도 출력되지 않는지를 확인하면 됨
    * Table pullout 최적화는 모든 형태의 서브쿼리에서 사용될 수 있는것은 아님

- 퍼스트 매치
    * IN형태의 세미 조인을 EXISTS 형태로 튜닝한것과 비슷한 방법으로 실행
    * FistMatch는 서브쿼리가 아니라 조인으로 풀어서 실행하면서 일치하는 첫번째 레코드만 검색하는 최적화를 실행한것

- 루스 스캔
    * 인덱스를 사용하는 GROUP BY 최적화 방법에서 살펴본 Using index for group-by의 루스 인덱스 스캔과 비슷한 읽기 방식
    * LooseScan 최적화는 루스 인덱스 스캔으로 서브쿼리 테이블을 일고, 그 다음으로 아우터 테이블을 드리븐으로 사용해서 조인을 수행. 그래서 서브쿼리 대부분이 루스 인덱스 스캔을 사용할 수 있는 조건이 갖춰져야 사용할 수 있는 최적화

- 구체화
    * 세미조인에 사용된 서브쿼리를 통채로 구체화 해서 쿼리를 최적화 하는것인데, 내부 임시 테이블을 생성해서 하는것임
    * IN에서 서브쿼리는 상관 서브쿼리가 아니여야 하며, 서브쿼리는 GROUP BY나 집합 함수들이 사용되도 구체화를 사용할 수 있어야 하며, 구체화가 사용된 경우에는 내부 임시테이블이 사용됨

- 중복 제거
    * 세미조인 서브쿼리를 일반적인 INNER JOIN 쿼리로 바꿔서 실행하고 마지막에 중복된 레코드를 제거하는 방법으로 처리되는 최적화 알고리즘
    * Extra칼럼에 Start temporary와 End temporary 문구가 별도로 표기된것을 확인

- 컨디션 팬아웃
    * 조인을 실행할 때 테이블의 순서는 쿼리의 성능에 매우 큰 영향을 미치므로, MySQL 옵티마이저는 여러 테이블이 조인되는 경우 가능하다면 일치하는 레코드 건수가 적은 순서대로 조인을 실행

- 파생 테이블 머지
    * 파생 테이블로 만들어지는 서브쿼리를 외부 쿼리와 병합해서 서브쿼리 부분을 제거하는 최적화
    * 다음의 경우 가능하다면 서브 쿼리는 외부 쿼리로 수동으로 병합해서 작성하는것이 쿼리의 성능 향상에 도움
        + SUM, MIN, MAX같은 집계 함수와 윈도우 함수가 사용된 서브쿼리
        + DISTINCT가 사용된 서브쿼리
        + GROUP BY나 HAVING이 사용된 서브쿼리
        + LIMIT이 사용된 서브쿼리
        + UNION 또는 UNION ALL을 포함하는 서브쿼리
        + SELECT절에 사용된 서브쿼리
        + 값이 변경되는 사용자 변수가 사용된 서브쿼리

- 인비저블 인덱스
    * MySQL 8.0 부터는 인덱스를 삭제하지 않고, 해당 인덱스를 사용하지 못하게 제어하는 기능을 제공

- 스킵 스캔
    * 인덱스의 핵심은 값이 정렬되어있다는것이며, 이로 인해 인덱스를 구성하는 칼럼의 순서가 매우 중요
    * MySQL 8.0버전부터는 인덱스 스킵 스캔 최적화가 도입되어서, 인덱스의 선행 칼럼이 조건절에 사용되지 않더라도 후행 칼럼의 조건만으로도 인덱스를 사용한 쿼리 성능 개선이 가능함

- 해시 조인
    * 해시 조인이 항상 네스티드 루프 조인보다 빠른것은 아님
    * 해시 조인 ㅝ리는 최고 스루풋 전략에 적합하며, 네스티드 루프 조인은 최고 응답 속도 전략에 적합
    * MySQL 8.0.20 버전부터는 블록 네스티드 루프 조인이 사용되지 않고, 네스티드 루프 조인을 사용할 수 없는경우에는 항상 해시 조인이 사용됨
    * 해시 조인은 빌드 단계와 프로브 단계로 나뉘어 처리
    * 빌드 단계에서는 조인 대상 테이블중에서 레코드 건수가 적어서 해시 테이블로 만들기 용이한 데이터 테이블들을 골라서 메모리에 해시 테이블을 생성하는 작업을 수행
    * 프로브 단계에서는 나머지 테이블의 레코드를 읽어서 해시 테이블의 일치 레코드를 찾음
    * 해시 테이블을 메모리에 저장할때 조인버퍼를 쓰는데, 조인 버퍼의 공간이 부족 할경우 MySQL 서버는 빌드 테이블과 프로브 테이블을 적장한 크기의 청크로 분리한다음, 청크별로 해시 조인 메모리와 동일한 방식으로 해시 조인을 처리
    * MySQL 옵티마이저는 빌드 테이블의 크기에 따라 해시 조인이 모두 메모리에서 처리 가능한경우 클래식 해시 조인 알고리즘을 사용하고, 해시 테이블의 조인 버퍼 메모리보다 큰경우 그레이스 해시 조인 알고리즘을 하리브리드 하게 활용하도록 구현

- 인덱스 정렬 선호
    * MySQL 옵티마이저는 ORDER BY 또는 GROUP BY를 인덱스를 사용해 처리 가능한경우 쿼리의 실행 계획에서 이 인덱스의 가중치를 높이 설정해서 실행

### 조인 최적화 알고리즘
- Exhaustive 검색 알고리즘
    * MySQL 5.0과 그 이전버전에사 사용되던 조인 최적화 기법으로 FROM 절에 명시된 모든 테이블의 조합에 대해 실행 계획의 비용을 계산해서 최적의 조합 1개를 찾는 방법
    * 테이블이 10개만 넘어도 실행 계획을 수립하는데 몇분이 걸릴정도로 오래걸림

- Greedy 검색 알고리즘
    * Exhaustive 검색 알고리즘의 시간 소모적인 문제점을 해결하기 위해 도입된 조인 최적화 기법
    * 전체 N개의 테이블 중에서 optimizer_search_depth 시스템 변수에 정의된 개수의 테이블로 가능한 조인 조합을 생성
    * 생성된 조인 조합중 최소 비용의 실행 계획 하나를 선정
    * 선정된 실행 계획의 첫번째 테이블을 부분 실행 계획의 첫번째 테이블로 선정
    * 전체 N-1개 테이블중 위에서 선택덴 테이블을 제외하고 optimizer_search_depth 시스템 변수에 정의된 개수의 테이블로 가능한 조인 조합을 생성
    * 위에서 생성된 조인 조합들을 하나씩 부분 실행 계획에 대입해 실행 비용 계산
    * 비용 계산 결과 최적의 실행계획에서 2번쨰 테이블을 부분 실행 계획의 두번째 테이블로 선정
    * 남은 테이블이 모두 없어질때까지 반복하며 부분 실행 계획에서 테이블의 조인 순서를 기록
    * 최종적으로 부분 실행 계획이 테이블의 조인 순서로 결정
    
## 쿼리 힌트
- MySQL서버에서 사용 가능한 쿼리 힌트는 인덱스 힌트와 옵티마이저 힌트

### 인덱스 힌트
- STRAIGHT_JOIN과 USE INDEX등을 포함한 인덱스 힌트들
- SQL문법에 맞춰 사용해야 하기 때문에 ANSI-SQL 표준 문법을 준수하지 못하게 되는 단점(옵티마이저 힌트는 ANSI-SQL 표준을 준수)
- 인덱스 힌트는 SELECT절과 UPDATE명령에서만 가능
- STRAIGHT_JOIN
    * STRAIGHT_JOIN은 옵티마이저 힌트인 동시에 조인 키워드이기도함. SELECT, UPDATE, DELETE 쿼리에서 여러 테이블이 조인되는 경우 조인 순서를 고정하는 역할
    * SELECT 키워드 바로 뒤에 사용되어야함(인덱스 힌트는 사용해야하는 위치가 이미 결정되있음). FROM절에 명시된 테이블의 순서대로 조인을 수행하도록 유도
    * 아래 기준에 맞게 조인 순서가 결정되지 않는 경우에만 사용하는게 좋음
        + 임시 테이블(인라인 뷰 또는 파생된 테이블)과 일반 테이블의 조인: 임시테이블을 드라이빙 테이블로 선정
        + 임시 테이블끼리 조인: 임시 테이블은 항상 인덱스가 없으므로 크기가 작은 드라이빙 테이블을 선텍
        + 일반 테이블끼리 조인: 양쪽 모두 조인 칼럼에 인덱스가 있거나, 모두 조인 칼럼에 인덱스가 없는 경우는 레코드 건수가 작은 테이블을 드라이빙 테이블, 그 이외의 경우엔느 인덱스가 없는 테이블을 드라이빙 테이블
    
    * JOIN_FIXED_ORDER, JOIN_ORDER, JOIN_PREFIX, JOIN_SUFFIX 등이 비슷한 역할

- USE INDEX/ FORCE INDEX/ INGORE INDEX
    * STRAGHIT_JOIN 힌트와 달리 인덱스 힌트는 인덱스를 가지는 테이블 뒤에 힌트를 명시
    * 인덱스 힌트는 키워드 뒤에 사용할 인덱스를 괄호로 묶어서 사용. 별도로 사용자가 부여한 이름이 없는 프라이머리키는 PRIMARY라고 명시하면 됨
    * USE_INDEX: MySQL 옵티마이저에게 특정 테이블의 인덱스를 사용하도록 권장하는 힌트 정도로 생각. 대부분의 경우 인덱스 힌트가 주어지면 옵티마이저는 사용자의 힌트를 채택하지만 항상 그 인덱스를 사용하는건 아님
    * FORCE_INDEX: USE_INDEX와 다른점은 없지만 옵티마이저에게 미치는 영향이 더 강한 힌트. USE_INDEX힌트를 부여했는데도 그 인덱스를 사용하지 않는경우 FORCE_INDEX를 써도 결과는 비슷
    * IGNORE_INDEX: USE_INDEX와는 반대로 특정 인덱스를 사용하지 못하게 하는 용도. 옵티마이저가 풀 테이블 스캔을 사용하도록 유도하기 위해서도 가능
    * 인덱스 힌트의 용도를 명시해주는것도 가능
        + USE INDEX FOR JOIN: 테이블간의 조인 뿐만 아니라 레코드를 검색하기 위한 용도까지 포함
        + USE INDEX FOR ORDER BY: 명시된 인덱스를 ORDER BY 용도로만 사용할수있게
        + USE INDEX FOR GROUP BY: 명시된 인덱스를 GROUP BY 용도로만 사용할수있게

- SQL_CALC_FOUND_ROWS
    * LIMIT을 만족하는 수만큼의 레코드를 찾았다 하더라도 끝까지 검색을 수행 하도록. 해당 힌트가 사용된 쿼리가 실행된 경우에는 FOUND_ROWS라는 함수를 이용해 LIMIT을 제외한 조건을 만족하는 레코드가 전체 몇건이였는지 알 수 있음
    * SQL_CALC_FOUND_ROWS와 ```COUNT(*)``` 쿼리를 사용 하는 경우를 비교해보면 ```COUNT(*)```를 쓰는쪽이 더 빠르므로, 그냥 COUNT를 사용하는게 나을수도있음
    * SELECT 쿼리 문장이 UNOIN(또는 UNOIN_DISTINCT)으로 연결된 경우에는 힌트를 사용해도 FOUND_ROWS로 정확한 레코드 건수를 가져올 수 없다는것도 문제
    * SQL_CALC_FOUND_ROWS는 성능 향상을 위해 만들어진게 아니라 개발자의 편의를 위해 만들어진것이라 그럼

### 옵티마이저 힌트
- 옵티마이저 힌트는 인덱스, 테이블, 쿼리블록, 쿼리 전체(글로벌)의 영향 범위를 가짐
- 특정 쿼리 블록에 영향을 미치는 옵티마이저 힌트는 그 쿼리 블록 내에서 사용될수도 있지만, 외부에서도 사용될수있고 외부에서 사용하려면 QB_NAME 힌트를 통해 해당 쿼리 블록에 이름을 부여해야함
- MAX_EXECUTION_TIME: 쿼리의 실행 계획에 영향 X, 쿼리의 최대 실행 시간만 지정
- SET_VAR: MySQL 시스템 변수를 변경하여서 쿼리의 실행 계획에 영향을 주기 위함. 조인 버퍼나 정렬용 버퍼(소트 버퍼)의 크기를 일시적으로 증가시켜 대용량 처리 쿼리의 성능을 향상시킬수도 있음. 모든 시스템 변수를 바꿀수 있는건 아님
- SEMIJOIN & NO_SEMIJOIN
    * SEMIJOUIN은 세미 조인에서 어떤 최적화 세부 전략을 사용할것인지 제어, Table Pull-out 전략은 별도 힌트 사용할수 없음. 그 전략을 사용할 수 있다면 항상 더 나은 성능이 보장되기 때문
    * Table Pull-out 이외의 다른 최적화 전략은 상황에 따라서 다른 최적화 전략으로 우회하는게 더 나은 성능을 사용할 수 있기 때문에 NO_SEMIJOIN도 제공됨
    * 세미조인 최적화 힌트는 외부 쿼리가 아니라 서브쿼리에 명시 해야함

- SUBQUERY: 세미조인 최적화를 사용하지 못할때, 사용하는 최적화 방법
- BNL & NO_BNL & HASHJOIN & NO_HASHJOIN
    * MySQL 8.0.20 이후 버전에서 BNL힌트를 이용하면 Block Nested Loop 조인 알고리즘을 사용. HASHJOIN 과 NO_HASHJOIN은 8.0.18 버전에서만 유효

- JOIN_FIXED_ORDER & JOIN_ORDER & JOIN_PREFIX & JOIN_SUFFIX
    * JOIN_FIXED_ORDER: STRAIGHT_JOIN힌트와 동일하게 FROM절의 순서대로 조인을 실행
    * JOIN_ORDER: FROM절에 사용된 테이블의 순서가 아니라 힌트에 명시된 테이블의 순서대로 조인
    * JOIN_PREFIX: 조인에서 드라이빙 테이블만 강제하는 힌트
    * JOIN_SUFFIX: 조인에서 드리븐 테이블만 강제하는 힌트

- MERGE * NO_MERGE
    * MySQL 옵티마이저가 내부 쿼리를 외부 쿼리와 병합하는게 더 낫거나, 때로는 내부 임시 테이블을 생성하는게 더 나을경우 MERGE, NO_MERGE를 사용

- INDEX_MERGE & NO_INDEX_MERGE
    * 하나의 테이블에 대해 여러개의 인덱스를 동시에 사용하는것을 인덱스 머지라고 하는데, 인덱스 머지 실행 계획이 항상 성능 향상에 도움이 되지 않음. 그래서 인덱스 머지 실행 계획의 사용 여부를 제어할떄 INDEX_MEREGE, NO_INDEX_MERGE를 사용

- NO_ICP
    * 인덱스 컨디션 푸시다운(ICP)최적화는 사용 가능하다면 항상 성능 향상에 도움이 되므로 MySQL 옵티마이저는 최대한 인덱스 컨디션 푸시다운 기능을 사용하는 방향으로 실행 계획을 수립. 그래서 ICP 힌트는 제공되지 않음
    * 인덱스 컨디션 푸시다운으로 인해 여러 실행 계획의 비용 계산이 잘못된다면 결과적으로 잘못된 실행 계획이 수립될수 있는데, 이경우 인덱스 컨디션 푸시다운 비활성화를 위해 NO_ICP 

- SKIP_SCAN & NO_SKIP_SCAN
    * 인덱스 스킵 스캔은 인덱스의 선행 칼럼에 대한 조건 없이도 옵티마이저가 해당 인덱스를 사용할 수 있게 해주는 매우 훙륭한 최적화기능. 하지만 조건이 누락된 선행 칼럼이 가지는 유니크한 값의 개수가 많아진다면 인덱스 스킵 스캔의 성능이 오히려 더 떨어짐
    * NO_SKIP_SCAN으로 비효율적인 인덱스 스킵 스캔을 막도록 함

- INDEX & NO_INDEX
    * 인덱스 힌트인 USE INDEX와 IGNORE INDEX를 대체하는 용도로 제공
    * 인덱스 힌트는 특정테이블 뒤에서 사용했기 때문에 힌트 내에 테이블 이름 없이 인덱스 이름만 쓰면 되지만, 옵티마이 저힌트에는 테이블 명과 인덱스 이름을 함께 명시 해야함
    