---
layout: post
title: "Real MySQL 09 : 옵티마이저와 힌트"
description: Real MySQL 9장 - 옵티마이저와 힌트
date: 2021-12-03 18:13:00 +09:00
categories: MySQL RealMySQL Study
---

# 옵티마이저와 힌트

## 개요

### 쿼리 실행 절차
- MySQL에서는 쿼리가 다음과 같은 과정으로 실행됨
    * SQL 파싱: 사용자로부터 요청된 SQL을 잘개 쪼개서 MySQL서버가 이해 할 수 있는 수준으로 분리(파스 트리). SQL파서 모듈이 처리하면 문법적으로 잘못된건 이 단계에서 걸러짐
    * 최적화 및 실행 계획 수립: SQL의 파싱 정보(파스 트리)를 확인 하면서 어떤 테이블부터 읽고 어떤 인덱스를 이용해 테이블을 읽을지 선택
        + 불필요한 조건 제거 및 복잡한 연산의 단순화
        + 여러 테이블의 조인이 있는 경우 어떤 순서로 테이블을 읽을지 결정
        + 각 테이블에 사용된 조건과 인덱스 통계 정보를 이용해 사용할 인덱스를 결정
        + 가쳐온 레코드들을 임시 테이블에 넣고 다시 한번 가공해야 하는지 결정
    * 두번째 단계에서 결정된 테이블의 읽기 순서나 선택된 인덱스를 이용해 스토리지엔진으로부터 데이터를 가져옴

### 옵티마이저의 종류
- 규칙 기반 최적화
    * 대상 테이블의 레코드 건수나 선택도 등을 고려하지 않고, 옵티마이저에 내장된 우선순위에 따라 실행 계획을 수립
    * 통계정보를 이용하지 않기 때문에 같은 쿼리에 대해서는 거의 항상 같은 실행 방법을 만들어냄
    * 거의 사용되지 않음

- 비용 기반 최적화
    * 쿼리를 처리하기위한 여러 가지 가능한 방법들을 만들고, 각 단위 작업의 비용(부하)정보와 대상 테이블의 예측된 통계 정보를 이용해 실행 계획별 비용 산출
    * 산출된 실행 방법 별로 최소로 소요되는 처리 방식을 선택해 최종적으로 쿼리를 실행


## 기본 데이터 처리

### 풀 테이블 스캔과 풀 인덱스 스캔
- 풀 테이블 스캔이란 인덱스를 사용하지 않고 테이블의 데이터를 처음부터 끝까지 읽어서 요청된 작업을 처리하는 작업
- 다음과 같은 조건이 일치하면 주로 풀 테이블 스캔
    * 테이블의 레코드 건수가 너무 작아서 인덱스를 통해 읽는것보다 풀 테이블 스캔이 빠른경우(테이블이 페이지 1개로 구성된 경우)
    * WHERE 절이나 ON절에 인덱스를 이용할 수 있는 적절한 조건이 없는경우
    * 인덱스 레인지 스캔을 사용할 수 있는 쿼리라 하더라도, 옵티마이저가 판단한 조건 일치 레코드 건수가 너무 많은 경우(인덱스의 B-Tree를 샘플링 해서 조사한 통계 정보 기준)

- InnoDB스토리지 엔진은 특정 테이블의 연속된 데이터 페이지가 읽히면 백그라운드 스레드에 의해 Read ahead 작업이 자동으로 실행
    * Read ahead란 어떤 영역의 데이터가 앞으로 필요해질것이라고 예측해서 요청이 오기전에 미리 디스크에서 읽어 InnoDB의 버퍼풀에 적재하는 것

- InnoDB에서 풀 테이블 스캔이 일어나면 처음 몇개의 데이터 페이지는 포그라운드 스레드가 페이지 읽기를 실행 하지만, 특정 시점 부터는 읽기 작업을 백그라운드 스레드로 넘김
- 백그라운드 스레드가 읽기를 넘겨 받는 시점부터 한번에 4개 또는 8개씩의 페이지를 읽으며 계속 그 수를 증가(한번에 64개 데이터 페이지까지). 포그라운드 스레드는 미리 버퍼 풀에 준비된 데이터를 가져다 사용하므로 쿼리가 상당히 빨리 처리
- innodb_read_ahead_threshold 시스템 변수를 이용해 언제 Read ahead를 시작 할지 임계값을 설정할 수 있음
- Read ahead는 풀 인덱스 스캔에서도 동일하게 적용

### 병렬 처리
- innodb_parallel_read_threads 시스템 변수를 이용해 하나의 쿼리를 최대 몇 개의 스레드를 이용해서 처리할지 변경 가능
- MySQL서버에서 쿼리를 여러개의 스레드를 이용해 병렬로 처리하는 힌트나 옵션은 없음. 아무런 WHERE 조건 없이 단순히 테이블 전체의 건수를 가져오는 쿼리만 병렬로 가능

### ORDER BY 처리(Using filesort)
- 정렬을 처리하는 방법은 인덱스를 이용하는 방법과 쿼리가 실행될 때 Filesort라는 별도의 처리를 이용하는 방법으로 나눌 수 있음
- 인덱스 이용
    * 장점: INSERT, UPDATE, DELETE 쿼리가 실행될 때 이미 인덱스가 정렬되있어 순서대로 읽기만 하면 되므로 매우 빠름
    * 단점: INSERT, UPDATE, DELETE 작업시 부가적인 인덱스 추가/삭제 작업이 필요. 인덱스 떄문에 디스크 공간이 더 필요. 인덱스의 개수가 늘어날수록 InnoDB 버퍼 풀을 위한 메모리가 많이 필요

- Filesort 이용
    * 장점: 인덱스를 생성하지 않아도 되므로 인덱스의 단점이 장점. 정렬해야할 레코드가 많지 않으면 메모리에서 Filesort가 되므로 충분히 빠름
    * 단점: 정렬 작업이 쿼리 실행시 처리되므로 레코드 대상 건수가 많을수록 쿼리 응답 속도가 느림

- 다음과 같은 경우에서는 정렬을 인덱스를 이용하도록 튜닝하기가 힘듬
    * 정렬 기준이 너무 많아서 요건별로 인덱스를 생성하기가 힘든 경우
    * GROUP BY 결과 또는 DISTINCT 같은 처리의 결과를 다시 정렬해야 하는경우
    * UNION의 결과와 같이 임시 테이블의 결과를 다시 정렬해야 하는경우
    * 랜덤하게 결과 레코드를 가져와야 하는 경우

- MySQL 서버에서 인덱스를 사용하지 않고 별도의 정렬 처리를 수행했는지는 실행 계획의 Extra칼럼의 Using Filesort 메시지가 표시되는지 여부로 판단
- 소트 버퍼
    * 정렬을 수행하기 위해 할당받는 별도의 메모리 공간. 정렬이 필요한 경우에만 할당되며, 버퍼의 크기는 정렬해야할 레코드의 크기에 따라서 가변적으로 증가. 쿼리의 실행이 완료되면 즉시 시스템으로 반납
    * 정렬해야할 레코드의 건수가 소트 버퍼로 할당된 공간보다 크다면 정렬해야할 레코드를 여러 조각으로 나눠서 처리하는데, 이때 임시 저장을 위해 디스크를 사용
    * 소트버퍼에서 정렬을 수행하고, 그 결과를 임시로 디스크에 기록하고, 다음 레코드를 가져와 다시 정렬해서 반복적으로 디스크에 저장하고, 정렬된 레코드들을 다시 병합하면서 정렬을 수행하는 멀티 머지 형태
    * 디스크의 읽기와 쓰기가 유발되며, 레코드의 건수가 많아질수록 이 반복작업의 횟수가 늘어남
    * 너무 큰 소트 버퍼 사이즈를 이용하는경우, 큰 메모리 공간 할당때문에 성능이 오히려 떨어질 수 있음

- 정렬 알고리즘
    * 레코드를 정렬할 때 전체 레코드를 소트 버퍼에 담을지 또는 정렬 기준 칼럼만 소트 버퍼에 담을지에 따라 싱글 패스와 투 패스 2가지 정렬 모드로 나눌 수 있음
    * ```<sort_key, rowid>```: 정렬 키와 레코드의 로우 아이디만 가져와서 정렬하는 방식(투패스 정렬)
    * ```<sort_key, additional_fields>```:  정렬 키와 레코드 전체를 가져와서 정렬하는 방식으로, 레코드의 칼럼들은 고정 사이즈 메모리로 저장(싱글패스 정렬)
    * ```<sort_key, packed_additional_fields>```: 정렬 키와 레코드 전체를 가져와서 정렬하는 방식으로, 레코드들의 칼럼들은 가변 사이즈 메모리로 저장(싱글패스 정렬)
    * 싱글패스 정렬방식: 소트 버퍼에 정렬 기준 칼럼을 포함해 SELECT 대상이 되는 칼럼 전부를 담아서 정렬을 수행하는 정렬 방식
    * 투패스 정렬방식: 정렬 대상 칼럼과 프라이머리 키값만 소트 버퍼에 담아서 정렬을 수행, 정렬된 순서대로 다시 프라이머리 키로 테이블들을 읽어서 SELECT할 칼럼을 가져오는 정렬방식
    * 투패스 방식은 테이블을 두번 읽어야 하기 떄문에 요 근래는 싱글 패스방식을 주로 사용. 반면 싱글 패스 정렬 방식은 더 많은 소트 버퍼 공간이 필요
    * 레코드의 크기가 max_length_for_sort_data 시스템 변수보다 크거나, BLOB나 TEXT타입의 칼럼이 SELECT 대상에 포함되면 투패스 정렬방식이 사용

- 정렬 처리 방법
    * 쿼리에 ORDER BY가 사용되면 다음 3가지 처리 방법중 하나로 정렬, 아래로 갈수록 처리 속도가 떨어짐
        + 인덱스를 사용한 정렬
        + 조인에서 드라이빙 테이블만 정렬: 실행 계획의 Extra 칼럼에 Usiing Filesort 메시지 표시
        + 조인에서 조인 결과를 임시 테이블로 저장 후 정렬: Using temporary; Using Filesort 메시지 표시
    
    * 옵티마이저는 정렬 처리를 위해 인덱스를 이용할 수 있을지를 검도. 인덱스를 이용할 수 있다면 별도의 Filesort과정 없이 인덱스를 순서대로 읽어서 결과 반환
    * 인덱스를 사용할 수 없다면 WHERE 조건에 일치하는 레코드를 검색해 정렬 버퍼에 저장하며 정렬을 처리(Filesort)할 것
    * MySQL 옵티마이저는 정렬 대상 레코드를 최소화 하기 위해 조인의 드라이빙 테이블만 정렬한 다음 조인을 수행하거나, 조인이 끝나고 일치하는 레코드를 모두 가져온후 정렬을 수행
    * 인덱스를 이용한 정렬
        + 인덱스를 이용한 정렬을 위해서 반드시 ORDER BY에 명시된 칼럼이 제일 먼저 읽는 테이블(드라이빙 테이블)에 속하고, ORDER BY의 순서대로 생성된 인덱스가 있어야함
        + WHERE절에 첫번째로 읽는 테이블의 칼럼에 대한 조건이 있다면, 그 조건과 ORDER BY는 같은 인덱스를 쓸 수 있어야함
        + B-Tree 계열의 인덱스가 아닌 다른 인덱스에서는 인덱스를 이용한 정렬을 할 수 없음(R-Tree도 불가)
        + 여러 테이블이 조인되는 경우 네스티드 루프 조인에서만 가능
        + 인덱스를 이용해 정렬이 처리되는 경우에는 실제 인덱스의 값이 정렬돼있기 떄문에 인덱스의 순서대로 읽기만 하면됨. 별도의 정렬을 위한 추가 작업은 수행하지 않음

    * 조인의 드라이빙 테이블만 정렬
        + 조인을 실행하기전에 첫번째 테이블의 레코드를 먼저 정렬 한 다음 조인을 실행하는것이 좋은데, 이 방법으로 정렬이 처리되려면 조인에서 첫번째로 읽히는 테이블(드라이빙 테이블)의 칼럼만으로 ORDER BY절을 작성 해야함

    * 임시 테이블을 이용한 정렬
        + 2개 이상의 테이블을 조인해서 그 결과를 정렬 해야 한다면 임시 테이블이 필요할 수도 있다
        + 조인의 드라이빙 테이블만 정렬은 2개 이상의 테이블이 조인되면서 정렬이 실행되지만 임시테이블을 사용하지 않음. 그 이외의 패턴의 쿼리에서는 항상 조인의 결과를 임시 테이블에 저장해야하고 그 결과를 정렬하는 과정을 거침
    
    * 정렬 처리 방법의 성능 비교
        + 스트리밍 처리: 서버쪽에서 처리할 데이터가 얼마인지에 관계 없이 조건에 일치하는 레코드가 검색될때마다 바로바로 클라이언트에 전송해주는 방식
        + 버퍼링 방식: ORDER BY나 GROUP BY와 같은 경우 조건에 일치하는 모든 레코드를 가져와 정렬하거나 그루핑 해서 보내야 하기 때문에 스트리밍 불가. 그래서 버퍼링이 걸린다 하여 버퍼링 방식
        + 인덱스를 사용한 정렬 방식만 스트리밍 형태의 처리이며, 나머지 처리 방식들은 버퍼링 이후 정렬
        
- 정렬 관련 상태 변수
    * sort_merge_passes: 멀티 머지 처리 횟수
    * sort_range: 인덱스 레인지 스캔을 통해 검색된 결과에 대한 정렬 횟수
    * sort_scan: 풀 테이블 스캔을 통해 검색된 결과에 대한 정렬 작업 횟수
    * sort_rows: 지금까지 정렬한 전체 레코드 건수

### GROUP BY 처리
- GROUP BY는 스트리밍 처리를 불가능하게 하며, GROUP BY에 사용된 조건을 인덱스를 사용해 처리될 수없으므로 HAVING절을 튜닝 하려고 인덱스를 생성하거나 다른 고민을 할 필요가 없음
- GROUP BY도 인덱스를 사용하는 경우와 그렇지 못한 경우로 나뉘는데, 인덱스를 사용하면 인덱스 스캔과 인덱스 루스 스캔이 가능하며, 인덱스를 사용하지 못하는 경우엔 임시테이블이 사용됨
- 인덱스 스캔을 이용하는 GROUP BY(타이트 인덱스 스캔)
    * ORDER BY와 마찬가지로 조인의 드라이빙 테이블에 속한 칼럼만 사용해 그루핑 할때
    * GROUP BY가 인덱스를 사용해서 처리된다 하더라도 그룹 함수등 그룹값을 처리해야 해서 임시 테이블이 필요 할 수도 있음
    * GROUP BY가 인덱스를 통해 처리되는 쿼리는 이미 정렬된 인덱스를 읽는 것이므로 쿼리 실행 시점에 추가 정렬작업이나 내부 인덱스 필요 X

- 루스 인덱스 스캔을 이용하는 GROUP BY
    * 루스 인덱스 스캔을 사용하면 실행 계획의 Extra 칼럼에 Using index for group-by가 표시
    * MySQL의 루스 인덱스 스캔 방식은 단일 테이블에 대해 수행되는 GROUP BY 처리에만 사용 가능
    * 프리픽스 인덱스는 루스 인덱스 스캔 사용 불가
    * 루스 인덱스 스캔은 분포도가 좋지 않은 인덱스일수록 더 빠른 결과를 만들어내며, 별도의 임시 테이블 필요 X

- 임시 테이블을 사용하는 GROUP BY
    * GROUP BY의 기준 칼럼이 드라이빙 테이블에 있던, 드리븐 테이블에 있든 상관 없이 인덱스를 전혀 사용하지 못할때
    * 실행 계획의 Extra 칼럼에 Using temporary만 표시됨. 묵시적인 정렬이 실행되지 않기 때문(MySQL 8.0 이후)
    * MySQL 8.0에서는 GROUP BY가 필요한경우 내부적으로 GROUP BY절의 칼럼들로 구성된 유니크 인덱스를 가진 임시 테이블을 만들어 중복제거와 집합 함수 연산을 수행. 별도의 정렬 작업이 필요 없음
    * MySQL 8.0에서도 GROUP BY와 ORDER BY가 같이 사용되면 명시적으로 정렬 작업 수행

### DISTINCT 처리
- SELECT DISTINCT
    * 단순 SELECT 되는 레코드중에서 유니크한 레코드만 가져오고자 하는 경우. GROUP BY와 동일한 방식
    * DISTINCT 사용시 주의 해야 할것이 SELECT하는 레코드를 유니크하게 SELECT하는것이지 특정 칼럼만 유니크하게 조회하는것은 아님
    * SELECT 절에 사용된 DISTINCT는 모든 조회되는 칼럼에 영향을 미침. 일부 칼럼만 유니크하게 조회하는것이 아니라는것에 주의

- 집합함수와 함께 사용된 DISTINCT
    * COUNT(), MIN(), MAX()와 같은 집합 함수 내에서 DSITINCT가 사용될 수 있는데, 이 경우 집합 함수 인자로 전달된 칼럼 값이 유니크한 것들을 가져옴
    * 내부적으로 DISTINCT를 처리 하기 위해 임시 테이블을 사용하지만, 실행 계획에서 Using temporary가 표시 되지는 않음
    * 임시테이블이 생성되기 때문에 레코드 건수가 많아진다면 상당히 느려질 수 있는 형태의 쿼리

### 내부 임시 테이블 활용
- MySQL 엔진이 스토리지 엔진으로부터 받아온 레코드를 정렬하거나 그루핑 할때는 내부적인 임시 데이터 테이블을 사용. CREATE TEMPORARY TABLE 명령과는 다른 임시 테이블이 생성됨
- MySQL 엔진이 내부적인 가공을 위해 생성하는 임시 테이블은 다른 세션이나 다른 쿼리에서는 볼 수 없으며 사용도 불가능하고, 쿼리의 처리가 완료되면 자동으로 삭제
- 메모리 임시 테이블과 디스크 임시 테이블
    * MySQL 8.0이전 까지는 원본 테이블의 스토리지 엔진과 상관 없이 임시 테이블이 메모리를 사용하는 MEMORY 스토리지 엔진을 사용하며, 디스크에 저장될때는 MyISAM 스토리지 엔진을 이용
    * MySQL 8.0부터는 메모리를 사용할 경우 TempTable이라는 스토리지 엔진을 사용하고, 디스크에 저장될때는 InnoDB 스토리지 엔진
    * MEMORY 스토리지 엔진은 가변 길이 타입을 지원하지 못하지만 TempTable은 지원
    * MyISAM은 트랜잭션이 지원되지 않지만 InnoDB는 트랜잭션이 지원
    * internal_tmp_mom_stroage_engine 시스템 변수로 메모리용 임시 테이블을 선택할수있음
    * tempable_max_ram 변수로 TempTable이 사용 가능한 메모리 공간을 지정하며 이 이상 커지면 디스크로 기록. 디스크에 기록 할떄는 MMAP파일로 디스크에 기록하거나 InnoDB 테이블로 기록
    * temptable_use_mmap의 기본값은 ON인데, ON되있으면 TempTable을 MMAP로 전환해서 저장. TempTable을 MMAP파일로 전환하는게 InnoDB 테이블로 전환하는것보다 오버헤드가 적기 떄문

- 임시 테이블이 필요한 쿼리
    * ORDER BY와 GROUP BY에 명시된 칼럼이 다른 쿼리
    * ORDER BY나 GROUP BY에 명시된 칼럼이 조인의 순서상 첫번째 테이블이 아닌 쿼리
    * DISTINCT와 ORDER BY가 동시에 쿼리에 존재하거나, DISTINCT가 인덱스로 처리되지 못하는 쿼리
    * UNION이나 UNION DISTINCT가 사용된 커리
    * 쿼리의 실행 계획에서 select_type이 DERIVED인 쿼리(유니크 인덱스가 없는 내부 임시 테이블이 생성되어 처리 성능이 느려짐)

- 임시 테이블이 디스크에 생성되는 경우
    * UNION이나 UNION ALL에서 SELECT되는 칼럼중에서 길이가 512바이트 이상인 크기의 칼럼이 있는 경우
    * GROUP BY나 DISTINCT 칼럼에서 512바이트 이상인 크기의 칼럼이 있는 경우
    * 메모리 임시 테이블의 크기가 tem_table_size또는 max_heap_table_size보다 크거나 temptable_max_ram보다 큰 경우

- 임시 테이블 관련 상태 변수
    * Created_tmp_disk_tables: 디스크 내부에 임시 태이블이 만들어진 개수를 누적
    * Created_tmp_tables: 쿼리의 처리를 위해 만들어진 내부 임시 테이블의 개수를 누적(메모리 or 디스크 상관없이)
    * 둘다 누적임으로 쿼리 실행 전에 FLUSH STATUS 명령으로 현재 세션값 초기화 하고 조회 할것 

## 고급 최적화
- MySQL 서버의 옵티마이저가 실행 계획을 수립할때 통계 정보와 옵티마이저 옵션을 결합해서 최적의 실행 계획을 수립
- 옵티마이저 옵션은 조인과 관련된 옵티마이저 옵션과 옵티마이저 스위옵션으로 구분됨

### 옵티마이저 스위치 옵션
- optimizer_switch 시스템 변수를 이용해 제어하는데, 여러개의 옵션은 세트로 묶어서 설정하는 방식
    * batched_key_access: 기본값 off, BKA 조인 알고리즘을 사용할지 여부
    * blo