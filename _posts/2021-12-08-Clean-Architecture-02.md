---
layout: post
title: "Clean Architecture 2장 - 의존성 역전하기"
description: Clean Architecture 2장 
date: 2021-12-08 21:30:00 +09:00
categories: Clean Architecture Study
---

# 의존성 역전하기

## 단일 책임의 원칙
- 단일 책임의 원칙에 일반적인 해석은 "하나의 컴포넌트는 오로지 한가지 일을 해야 하고, 그것을 올바르게 수행해야 한다" 인데, 사실 "컴포넌트를 변경하는 이유는 오직 하나 뿐이어야 한다" 가 맞는 해석이다
- 만약 컴포넌트를 변경할 이유가 한가지라면, 우리가 어떤 다른 이유로 소프트웨어를 변경하더라도 이 컴포넌트에 대해서는 전혀 신경 쓸 필요가 없다
- 하지만 변경할 이유라는것은 컴포넌트간의 의존성을 통해 너무도 쉽게 전파되기 마련이다
- 많은 코드는 단일 책임의 원칙을 위반하기 때문에 시간이 갈수록 변경하기가 더 어려워 지고 그로 인해 변경 비용도 증가한다. 변경할 이유가 많이 쌓인 후에는 한 컴포넌트를 바꾸는것이 다른 컴포넌트가 실패하는 원인으로 작용할 수 있다

## 부수효과에 관한 이야기
- 저자의 실제 사례
- 다른 소프트웨어 회사에서 개발한 10년된 코드를 받아서 진행하는 프로젝트에 참여하게 되었는데, 클라이언트느 향후에 더 나은 품질과 더 적은 비용으로 유지보수와 개발을 진행하기 위해 개발 팀을 교체하기로 결정했다
- 예상대로 코드가 실제로 어떤 일을 하는지 이해하기가 쉽지 않았고, 코드의 한 영역을 변경해썯니 다른 영역에서 부수효과가 생겨나기 일쑤였다. 저자는 이를 철저하게 테스트를 하고, 자동화된 테스트를 추가하며, 리팩터링을 많이 하는것으로 대응 해나갓다
- 코드가 성공적으로 유지보수하고 확장된 후, 클라이언트가 사용자 입장에서 이상한 방식으로 동작하는 새로운 기능을 구현해달라고 요청해서, 조금 더 사용자 친화적인 방법을 제안 했지만 클라이언트는 새로운 방법이 변경하는 컴포넌트에 대한 부수효과를 두려워해 거절했다
- 이 사례에서 부수효과는 클라이언트로 하려금 잘못 구조화된 소프트웨어를 변경하는데 더 많은 비용을 지불하도록 만드는 경우를 보여준다

## 의존성 역전 원칙
- 계층형 아키텍처에서 계층간 의존성은 항상 다음 계층인 아래 방향을 가리킨다. 단일 책임 원칙을 고 수준에서 적용할 때, 상위 계층들이 하위 계층에 비해 변경할 이유가 더 많다는것을 알 수 있다
- 그러므로 영속성 계층에 대한 도메인 계층의 의존성 때문에, 영속성 계층이 변경될 때 마다 도메인 계층도 변경되야 한다. 이러한 의존성은 어떻게 제거 할 수 있을까? 이것은 의존성 역전의 원칙이 그 답이다
- 의존성 역전의 원칙은 "코드상의 어떤 의존성이든 그 방향을 역전할 수 있다" 로 해석하면되는데, 사실 의존성의 양쪽 코드를 모두 제어할 수 있을때만 의존성을 역전 시킬 수 있다
- 의존성 역전은 어떻게 동작할까? 도메인 코드와 영속성 코드간의 의존성을 역전시켜 영속성 코드가 도메인 코드에 의존하고, 도메인 코드를 '변경할 이유'의 갯수를 줄이면 된다

## 클린 아키텍처
- 로버트 C 마틴의 저서 '클린 아키텍처'에서 클린 아키텍처란 설계가 비즈니스 규칙의 테스트를 용이하게 만들고, 비즈니스 규칙은 프레임워크, 데이터베이스, UI기술, 그 밖의 외부 애플리케이션이나 인터페이스로부터 독립적이여야 한다고 말한다
- 이는 도메인 코드가 바깥으로 향하는 어떤 의존성도 없어야함을 말하며, 의존성 역전의 원칙의 도움으로 모든 의존성이 도메인 코드를 향하고있음을 말한다
- 이 아키텍처에서 계층들은 동심원으로 둘러쌓여 있는데, 이때 가장 중요한 의존성 규칙으로 계층간의 모든 의존성이 안쪽으로 향해야 한다는 규칙이 있다
- 이렇게 되면 도메인 코드에서는 어떤 영속성 프레임워크나 UI프레임 워크가 사용되는지 알 수 없어서, 특정 프레임 워크에 특화된 코드를 가질 수 없고, 비즈니스 규칙에 집중할 수 있다. 한가지 예시로 DDD를 가장 순수한 형태로 적용 한다면, 영속성이나 UI에 특화된 문제를 신경쓰지 않아도 된다
- 하지만 여기에서도 대가는 따른다. 도메인 계층이 영속성이나 UI와 같은 외부 계층과 철저히 분리되야 하므로, 애플리케이션의 엔티티에 대한 모델을 각 계층에서 유지보수 해야 한다
- 가령 영속성 계층에서 ORM을 사용하면, 도메인 계층에서는 영속성 계층을 모르기에 도메인 계층에서 사용한 엔티티 클래스를 영속성 계층에서 함께 사용할 수 없고, 두 계층에서 각각 엔티티를 만들어야 한다. 이는 도메인 계층과 다른 계층 사이에서도 마찬가지이다
- 하지만 이것이 오히려 바람직한것이며, 이것이 바로 도메인 코드를 프레임워크에 특화된 문제로부터 해방시키고자 했던 결합이 제거된 상태이다

## 육각형 아키텍처(헥사고날 아키텍처)
- 육각형 아키텍처는 애플리케이션 코어가 육각형으로 표현되어 있는데, 사실 이 육각형 모양엔 의미가 없고 애플리케이션이 다른 시스템이나 어댑터와 연결되는 4개 이상의 면을 가질수 있음을 보여주기 위해 일반적인 사각형 대신 육각형으로 표현한것일 뿐이다
- 육각형 안에는 도메인 엔티티와 이와 상호작용하는 유스케이스가 있다. 육각형에서 외부로 향하는 의존성이 없기 때문에 클린아키텍처에서 제시한 의존성 규칙이 그대로 적용되고, 모든 의존성은 코어를 향한다
- 육각형 바깥에는 애플리케이션과 상호작용하는 다양한 어댑터들이 있다. 웹 브라우저와 상호작용 하는 어댑터도 있고, 외부 시스템과 상호작용하는 어댑터, 데이터베이스와 상호작용 하는 어댑터도 있다
- 웹 어댑터나 외부 시스템 어댑터는 애플리케이션 코어를 호출하기 때문에 애플리케이션을 주도하는 어댑터 이지만, 영속성 어댑터나 외부 시스템으로 출력하는 어댑터는 어플리케이션 코어에 의해 호출되는 어댑터로 어플리케이션에 의해 주도되는 어댑터들이다
- 애플리케이션 코어와 어댑터들 사이의 통신이 가능하려면 각각의 포트가 제공되야 하는데 이들은 인터페이스이다
- 이런 핵심 개념으로 인해 헥사고날 아키텍처는 포트와 어댑터 아키텍처로도 알려져 있으며, 클린 아키텍처 처럼 헥사고날 아키텍처도 계층으로 구성이 가능하다. 가장 바깥쪽 계층은 다른 시스템과의 번역을 담당하는 어댑터, 그다음 포트와 유스케이스 구현체를 합친 애플리케이션 계층, 그리고 도메인 엔티티가 위치한 계층으로 구성할 수 있다

## 유지보수가 가능한 소프트웨어를 만드는데 어떻게 도움이 될까?
- 클린아키텍처든 헥사고날 아키텍처든 의존성을 역전시켜 도메인 코드가 다른 바깥쪽 코드에 의존하지 않게 함으로써 영속성과 UI에 특화된 모든 문제로부터 도메인 로직의 결합을 제거하고 변경할 이유의 숫자를 줄일 수 있다
- 도메인 코드는 비즈니스 문제에 딱 맞도록 자유롭게 모델링 될 수 있고, 영속성 코드와 UI코드도 영속성 문제와 UI문제에 맞게 자유롭게 모델링 될 수 있다