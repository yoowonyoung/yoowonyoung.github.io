---
layout: post
title: "Effective Java - 아이템80: 스레드 보다는 실행자, 태스크, 스트림을 애용하라"
description: 스레드 보다는 실행자, 태스크, 스트림을 애용하라
date: 2020-09-20 22:59:00 +09:00
categories: EffectiveJava Study
---


# 동시성

## 아이템 80 : 스레드 보다는 실행자, 태스크, 스트림을 애용하라

- 자바의 java.util.concurrent 패키지는 실행자 프레임워크라고 하는 인터페이스 기반읜 유연한 태스크 실행 기능을 제공한다. 다음의 단 한줄로 작업 큐를 생성할 수 있다

```java
ExecutorService exec = Executors.newSingleThreadExcutor();
```

- 실행자에 실행할 태스크를 넘기는 방법은 다음과 같다

```java
exec.execute(runnable);
```

- 실행자를 우아하게 종료시키는 방법은 다음과 같다

```java
exec.shutdown();
```

- 실행자 서비스의 기능은 이외에도 많다. 다음은 실행자 서비스의 주요 기능이다
    * 특정 태스크가 완료되기를 기다린다
    * 태스크 모음중 아무것 하나(invokeAny) 혹은 모든 태스크(invokeAll)가 완료되기를 기다린다
    * 실행자 서비스가 종료하기를 기다린다(awaitTerminate)
    * 완료된 태스크들의 결과를 차례로 받는다(ExecutorCompletionService 이용)
    * 태스크를 특정 시간에 혹은 주기적으로 실행하게 한다(ScheduledThreadPoolExecutor 이용)

- 큐를 둘 이상의 스레드가 처리하게 하고싶다면 간단히 다른 정적 팩터리를 이용하여 다른 종류의 실행자 서비스(스레드 풀)을 생성하면 된다
- 스레드 풀의 개수는 고정 할 수도 있고, 필요에따라 늘어나거나 줄어들게 설정 할 수 있다
- 우리에게 필요한 실행자 대부분은 java.util.concurrent.Executors의 정적 팩터리를 이용해 생성 할 수 있으며, 평범하지 않은 실행자를 원한다면 ThreadPoolExecutor클래스를 직접 사용해도 된다. 이 클래스로는 스레드 풀 동작을 결정하는 거의 모든 속성을 설정 할 수 있다
- 실행자 서비스를 사용하기에 까다로운 애플리케이션도 있는데, 작은 프로그램이나 가벼운 서버라면 Executors.newCachedThreadPool이 일반적으로 좋은 선택이며, 이는 특별히 설정할 게 없고 일반적인 용도에 적합하게 동작한다
- 하지만 CachedThreadPool은 무거운 프로덕션 서버에는 좋지 못하다. CachedThreadPool에서는 요청받은 태스크들이 큐에 쌓이지 않고 즉시 스레드에 위임돼 실행되며, 가용한 스레드가 없다면 즉시 하나를 생성한다. 서버가 아주 무겁다면 CPU이용률이 100%로 치닫을것이고, 새로운 태스크가 도착하는 즉시 새 르세드가 생성되며 더 악화될것이다
    * 따라서 무거운 프로덕션 서버에서는 스레드 개수를 고정한 Executors.newFixedThreadPool을 선택하거나, 완전히 통제할 수 있는 ThreadPoolExecutor를 직접 사용하는편이 훨씬 낫다

- 작업 큐를 손수 만드는일은 삼가야 하고, 스레드를 직접 다루는 일도 일반적으로 삼가해야 한다
- 스레드를 직접 다루면 Thread가 작업 단위와 수행 매커니즘 역할을 모두 수행하게 되지만, 실행자 프레임워크에서는 작업단위와 실행 메커니즘이 분리된다
- 작업 단위를 나타내는 핵심 추상 개념이 태스크이며, 태스크에는 Runnable과 Callable(Runnable과 비슷하지만 값을 반환하고 임의의 예외를 던질수있음)이 있다. 그리고 태스크를 수행하는 일반적인 매커니즘이 실행자 서비스이다
- 태스크 수행을 실행자 서비스에게 맡기면 원하는 태스크 수행 정책을 선택 할 수 있고, 생각이 바뀌면 언제든지 변경할 수 있다. 핵심은 실행자 프레임워크가 작업 수행을 담당해준다는것이다
- 자바7부터는 실행자 프레임워크가 포크조인 태스크를 지원하도록 확장되었다. 포크조인 태스크는 포크조인 풀이라는 특별한 실행자 서비스가 실행해주는데, 포크조인 태스크의 인스턴스는 작은 하위 태스크로 나뉠 수 있고, 포크조인풀을 구성하는 스레드들이 이 태스크들을 처리하며, 일을 먼저 끝마친 스레드는 다른 스레드의 남은 태스크를 가져와 대신 처리할 수 있다
    * 이렇게 하여 모든 스레드가 바끄게 움직여 CPU를 최대한 활용하면서 높은 처리량과 낮은 지연시간을 달성한다
    * 이러한 포크조인 태스크를 직접 작성하고 튜닝하기란 어렵지만, 포크조인풀을 이용해 만든 병렬스트림을 이용하면 적은 노력으로 그 이점을 얻을 수 있다. 물론 포크조인에 적합한 작업의 형태여야 한다
