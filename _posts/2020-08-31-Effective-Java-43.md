---
layout: post
title: "Effective Java - 아이템43: 람다보다는 메서드 참조를 이용하라"
description: 람다보다는 메서드 참조를 이용하라
date: 2020-08-30 21:31:00 +09:00
categories: EffectiveJava Study
---


# 람다와 스트림

## 아이템 43 : 람다보다는 메서드 참조를 이용하라

- 람다가 익명클래스보다 나은점중 가장 큰 특징은 간결함이다. 하지만 자바에는 함수 객체를 람다보다도 더 간결하게 만드는 방법이 있는데 그것이 메서드 참조이다

```java
map.merge(key, 1, (count,incr) -> count + incr);
```

- 위 코드는 임의의 키와 Integer값의 매핑을 관리하는 참조 프로그램의 일부이다. 이 코드는 자바8에 추가된 merge 메서드를 사용했다. merge 메서드는 키, 값, 함수를 인자로 받으며 주어진 키가 맵 안에 아직 없다면 주어진 키,값 쌍을 저장하며 키가 있다면 인수로 받은 함수를 현재값과 주어진값에 적용한 후 이를 덮어쓴다
- 깔끔해보이는 이 코드는 아직 거추장스러운 부분이 있는데, 매개변수인 count 와 incr은 크게 하는일 없이 공간을 꽤 차지하고 있는것이다
- 사실 이 람다는 두 인수의 합을 간단히 반환할 뿐이며, 자바8의 Integer(와 모든 기본 박싱타입)은 이 람다와 기능이 같은 sum 정적 메서드를 제공하기 시작했다

```java
map.merge(key,1,Integer::sum);
```

- 따라서 위와 같이 람다 대신 이 메서드의 참조를 전달하면 똑같은 결과를 더 보기좋게 얻을 수 있다
- 매개변수 수가 늘어날수록 메서드 참조로 제거할 수 있는 코드량도 늘어난다
- 하지만 어떤 람다에서는 매개변수의 이름 자체가 프로그래머에게 좋은 가이드가 되기도 한다. 이런 람다는 길이는 더 길지만 메서드 참조보다 읽기 쉽고 유지보수도 쉬울 수 있다
- 람다로 할 수 없는일이라면 메서드 참조로도 할 수 없는데(한가지 예외를 빼고), 보통 메서드 참조를 사용하는편이 보통은 더 짧고 간결하므로 람다로 구현했을때 너무 길거나 복잡하다면 메서드 참조가 좋은 대안이 되어준다. 즉 람다로 작성할 코드를 새로운 메섣에 담은 다음, 람다 대신 그 메서드 참조를 사용하는 식이다
    * 이때 메서드 참조에는 기능을 잘 드러내는 이름을 지어줄 수 있고, 친절한 설명을 문서로 남길 수 있다

- IDE들은 람다를 메서드 참조로 대체할것을 권할텐데, IDE의 권고를 따르는게 보통은 이득이지만 그렇지 않을때도 있다. 주로 메서드와 람다가 같은 클래스에 있을때에 그렇다

```java
service.execute(GoshThisClassNameIsHumongous::action);

service.execute(() -> action());
```

- 이런 경우 메서드 참조쪽은 더 짧지도 명확하지도 않다. 따라서 람다쪽이 더 낫다
    * 같은선상에서 java.util.function 패키지가 제공하는 제너릭 정적 팩터리 메서드인 Function.identify()를 사용하기보다는 똑같은 기능의 람다(x -> x)를 사용하는편이 코드도 짧고 더 명확하다

- 메서드 참조의 유형은 5가지로 가장 흔한 유형은 앞의 예에서 본것처럼 정적 메서드를 가리키는 메서드 참조이다
- 인스턴스 메서드를 참조하는 유형이 2가지가 있는데, 그중 하나는 수신 객체를 특정하는 한정적인 인스턴스 메서드 참조이고, 다른 하나는 수신 객체를 특정하지 않는 비한정적 인스턴스 메서드 참조이다
    * 한정적 참조는 근본적으로 정적 참조와 비슷하다. 즉 함수 객체가 받는 인수와 참조되는 메서드가 받는 인수가 똑가다
    * 비한정적 참조에서는 함수 객체를 적용하는 시점에 수신 객체를 알려준다. 이를 위해 수신객체 전달용 매개변수가 매개변수 목록의 첫번째로 추가되며, 그 뒤로는 참조되는 메서드 선언에 정의된 매개변수들이 뒤따른다. 비한정적 참조는 주로 스트림 파이프라인에서의 매핑과 필터에 쓰인다

- 클래스 생성자를 가리키는 메서드 참조와 배열 생성자를 가리키는 메서드 참조도 있는데, 생성자 참조는 팩터리 객체로 사용된다
- 이를 정리하자면 다음과 같다

|메서드 참조 유형|예시|같은 기능을 하는 람다|
|------|---|------|
|정적|Integer::parseInt|str -> Integer.parseInt(str)|
|한정적(인스턴스)|Instant.now()::isAfter|Instant then = Instant.now(); t -> then.isAfter(t)|
|비한정적(인스턴스)|String::toLowerCase()|str -> str.toLowerCase()|
|클래스 생성자|TreeMap<K,V>::new|() -> new TeeeMap<K,V>()|
|배열 생성자|int[]::new|len -> new int[len]|

- 람다로는 불가능하나 메서드 참조로는 가능한 유일한 예는 바로 제너릭 함수 타입 구현이다. 함수형 인터페이스의 추상메서드가 제너릭일 수 있읐이, 함수 타입도 제너릭 일 수 있다

```java
interface G1 {
    <E extends Exception> Object m() throws E;
}

interface G2 {
    <F extends Exception> String m() throws Exception;
}

interface G extends G1,G2 {}
```

- 이때 함수형 인터페이스 G를 함수 타입으로 표현하면 다음과 같다

```java
<F extends Exception>() -> String throws F
```

- 이처럼 함수형 인터페이스를 위한 제너릭 함수 타입은 메서드 참조 표현식으로는 구현 할 수 있지만, 람다로는 불가능하다. 제너릭 람다식이라는 문법은 존재하지 않기 때문이다
