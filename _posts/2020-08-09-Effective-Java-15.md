---
layout: post
title: "Effective Java - 아이템15: 클래스와 멤버의 접근권환을 최소화하라"
description: 클래스와 멤버의 접근권환을 최소화하라
date: 2020-08-09 16:20:00 +09:00
categories: EffectiveJava Study
---


# 모든 객체의 공통 메서드

## 아이템 15 : 클래스와 멤버의 접근권환을 최소화하라

- 어설프게 설계된 컴포넌트와 잘 설계된 컴포넌트의 가장 큰 차이는 바로 클래스 내부 데이터와 내부 구현 정보를 외부 컴포넌트로부터 얼마나 잘 숨겼느냐 이다
- 잘 설게퇸 컴포넌트는 모든 내부 구현을 완벽히 숨겨, 구현과 API를 깔끔히 분리한다
- 오직 API를 통해서만 다른 컴포넌트와 소통하며 서로의 내부 동작 방식에는 전혀 개의치 안흔ㄴ다. 이 정보은닉 혹은 캡슐화라고 하는 개념이 소프트웨어 설계의 근간이 되는 원리이다
- 정보은닉의 장점은 다음과 같다
    * 시스템 개발 속도를 높인다. 여러 병렬 컴포넌트를 개발할 수 있기 떄문이다
    * 시스템 관리 비용을 낮춘다. 각 컴포넌트를 더 빨리 파악하여 디버깅 할 수 있고, 다른 컴포넌트로 교체하는 부담도 적기 떄문이다
    * 정보 은닉 자체가 성능을 높여주지는 않지만, 성능 최적화에 도움을 준다. 다른 컴포넌트에 영향을 주지 않으며, 해당 컴포넌트만 최적화 할 수 있기 때문이다
    * 소프트웨어의 재사용성이 증가된다. 외부에 거의 의존하지 않고 독자적으로 동작 할 수 있는 컴포넌트라면, 그 컴포넌트와 같이 개발 되지 않은 낯선 환경에서도 유용하게 쓰일 가능성이 크기 때문이다
    * 큰 시스템을 제작하는 난이도를 낮춰준다. 시스템 전체가 아직 완성되지 않은 상태에서도 개별 컴포넌트의 동작을 검증 할 수 있기 때문이다

- 자바는 정보 은닉을 위한 다양한 장치를 제공하는데, 그중 접근 제어 메커니즘은 클래스, 인터페이스, 멤버의 접근성을 명시한다
- 각 요소의 접근성은 그 요소가 선언된 위치와 접근 제한자로 정해지는데, 이 접근 제한자를 제대로 활용하는것이 정보 은닉의 핵심이다
- 기본원칙은 매우 간단하다. 모든 클래스와 멤버의 접근성을 가능한 좁혀야 한다. 달리 말하면 소프트웨어가 올바로 동작 하는 한 가장 낮은 접근 수준을 부여해야 한다는 뜻이다
- 톱 레벨 클래스와 인터페이스에 부여 할 수 있는 접근 수준은 package-private와 public 두가지 이다
- 톱 레벨 클래스에서 public으로 선언하면 공개 API가 되는 것이며, package-private로 선언하면 패키지 안에서만 사용 할 수 있다
- 패키지 외부에서 쓸 이유가 없다면 package-private가 좋다. 그러면 이들은 API가 아닌 내부 구현이 되어 언제든지 수정할 수 있다. 반면 public으로 선언 한다면 API가 되므로 하위 호환을 위해 영원히 관리해줘야 한다
- 한 클래스에서만 사용하는 package-private 톱레벨 클래스나 인터페이스는 이를 사용하는 클래스 안에 private static으로 중첩 시켜보자. 톱레벨로 두면 같읜 패키지의 모든 클래스가 접근 가능하지만,
private static으로 중첩시키면 바깥 클래스 하나에서만 접근 할 수 있다
- 이보다 중요한것이 있는데, 바로 public일 필요가 없는 클래스의 접근 수준을 package-private 톱레벨 클래스로 좁히는 일이다. public 클래스는 그 패키지의 API인 반면, package-private 톱레벨 클래스는 내부구현 이기 때문이다
- 멤버에 부여할 수 있는 접근수준은 4가지 이다
    * private: 멤버를 선언한 톱레벨 클래스에서만 접근 할 수 있다
    * package-private: 멤버가 소속된 패키지 안의 모든 클래스에서 접근할 수 있다. 접근제한자를 명시하지 않았을때 적용되는 패키지 접근 수준이다(인터페이스는 public이다)
    * protected: package-private의 접근범위를 포함하며, 이 멤버를 선언한 클래스의 하위 클래스에서도 접근 할수 있다
    * public: 모든 곳에서 접근 할 수 있다

- 클래스의 공개 API를 세심히 설계한 후, 그외의 모든 멤버는 private로 만든다. 그 이후 오직 같은 패키지의 다른 클래스가 접근해야하는 멤버에 한해 package-private로 바꿔준다
- private와 pacakge-private 멤버는 모두 해당 클래스의 구현이므로 보통은 공개 API에 영향을 주지 않지만, Serializable을 구현한 클래스에서는 그 필드들도 의도치 않게 공개 API가 될 수도 있다
- public 클레스에서는 멤버의 접근 수준을 package-private에서 protected로 바꾸는 순간 접근할 수 있는 대상의 범위가 엄청나게 넓어진다. public의 protected멤버는 공개 API이므로 영원히 지원해야 한다
- 멤버의 접근성을 좁히지 못하게 방해하는 제약이 하나 있는데, 상위 클래스의 메서드를 제정의 할 떄에는 그 접근수준을 상위 클래스에서보다 좁게 살정 할 수 없다는 것이다
- 이 제약은 상위 클래스의 인스턴스는 하위 클래스의 인스턴스로 대체해 사용 할 수 있어야 한다(리스코프 치환원칙)을 지키기 위해 필요하다
- 클래스가 인터페이스를 구현하는것은, 리스코프 치환원칙의 특별한 에로 볼 수 있고, 이때 클래스는 인터페이스가 정의한 모든 메서드를 public으로 선언 해야한다
- 단지 코드를 테스트하려는 목적으로 클래스, 인터페이스, 멤버의 접근 범휘를 넓히려 할 떄가 있는데, 적당한 수준까지는 넓혀도 되지만 그 이상은 안된다. 즉, 테스트 만을 위해 공개 API를 만들면 안되는것이다
- public 클래스의 인스턴스 필드는 되도록 public이 아니어야 한다. 필드가 가변 객체를 참조하거나, final이 아닌 인스턴스 필드를 public으로 선언하면 그 필드에 담을 수 잆는 값을 제한할 힘을 잃게 된다
- 또한 그 필드가 수정될 때(락 획득같은) 다른 작업을 할 수 없게 되므로 public 가변필드를 갖는 클래스는 일반적으로 스레드 안전하지 않다
- 이러한 문제는 정적 필드에서도 마찬가지이나, 해당 클래스가 표현하는 추상개념을 완성하는데 꼭 필요한 구성요소로써의 상수라면 public static final필드로 공개해도 좋다.
보통 이런 상수의 이름은 대문자 알파벳으로 쓰이며, 각 단어 사이에 밑줄을 넣는다
- 클래스에서 public static final 필드를 두거나 이 필드를 반환하는 접근자 메서드를 제공해서는 안된다. 길이가 0이 아닌 배열은 모두 변경 가능하기 떄문이다

```java
public static final Thing[] VALUES = { ... };
```

- 위와 같은 코드는 보안 헛점이 존재하며, public 불변 리스트로 반환하거나, 방어적 복사를 통해 복사본을 반환하는 방법이다

```java
private static final Thing[] PRIVATE_VALUES = { ... };
public static final List<Thing> VALUES = Collections.unmodifiableList(Arrays.asList(PRIVATE_VALUES));

private static final Thing[] PRIVATE_VALUES = { ... };
public static final Thing[] values() {
    return PRIVATE_VALUES.clone();
}
```

- 자바9 에서는 모듈 시스템이라는 개념이 도입되면서 두가지 압묵적 접근 수준이 추가되었는데, 패키지가 클래스들의 묶음이듯, 모듈은 패키지들의 묶음을 말한다
- 모듈은 자신에 속하는 패키지중 공개(export) 할것을 관례상 moduleinfo.java 에 선언한다
- protected 혹은 public 멤버라도 해당 패키지를 공개 하지 않았더라면 모듈 외부에서는 접근 할 수 없다. 물론 모듈 안에서는 아무련 영향을 받지 않는다
- 이 모듈 내부에서 선언된 public클래스의 public 혹은 protected 멤버들의 경우, 접근 수준은 public / protected와 동일 하지만 그 효과가 모듈 내부로 제한되는것이다
- 만약 모듈의 jar파일을 클래스패스에 두면, 그 모듈안의 모든 패키지는 마치 모듈이 없는 것처럼 행동한다. 즉 모듈이 공개했는지 여부와 상관없이 public 클래스가 선언언한 모든 public 혹은 proteted멤버를 모듈 밖에서 접근할수있다
- 이런것을 제일 잘 활용한것이 JDK 그 자체이다. 자바 라이브러리에서 공개하지 않은 패키지들은 해당 모듈 밖에서는 접근 할 수 없다
- 접근 보호 방식이 추가된 것 말고도, 모듈은 여러면에서 자바 프로그래밍에 영향을 준다. 하지만 모듈의 장점을 제대로 누리려면 해야할것이 많다. 패키지를 모듈단위로 묶고, 모듈 선언에 패키지들의 모든 의존성을 명시하고,
소스 트리를 재배치 하고, 모듈 안으로부터 일반 패키지로의 모든 접근에 특별한 조치를 취해야 한다  
