---
layout: post
title: "Kotlin Study - 06 코틀린의 타입 시스템 -2"
description: 6장 코틀린의 타입 시스템 2번째
date: 2019-08-15 13:47:00 +09:00
categories: kotlin study
---

# 코틀린의 타입 시스템

## 코틀린의 원시 타입

### 원시타입: Int, Boolean 등
* java에서는 원시타입(int 등)과 참조타입(String 등)을 구분 하며, 원시 타입에 대해서는 메소드 호출이나 컬렉션에 값으로 담을 수 없다
* 이러한 문제를 해결 하기 위해 래퍼타입(Integer 등)이 있고, 원시타입을 래퍼타입으로 감싸서 사용한다
* 하지만 코틀린에서는 이러한 원시타입과 래퍼타입을 구분하지 않고 항상 같은 타입을 사용한다
* 원시타입과 참조타입이 같다고 해서 항상 그들을 객체로 표현하는 것이 아니라, 실행 시점에 가장 효율적인 방식으로 표현된다

### 널이 될 수 있는 원시타입: Int?, Boolean? 등
* null 참조를 java의 참조 타입의 변수에만 대입 할 수 있기 때문에, 코틀린의 널이 될수 있는 타입은 java의 원시 타입으로 표현 할 수 없다

### 숫자 변환
* 코틀린과 java의 큰 차이중 하나가 숫자 변환 방식이다. 코틀린은 한 타입의 숫자를 타른 타입의 숫자로 자동 변환 하지 않는다
* 그 대신 코틀린은 모든 원시 타입에 대한 변환 함수를 제공 한다(toByte(), toShort(), toChar())
* 양방향의 변환 함수가 모두 제공 된다(표현 범위가 넒은 타입에서 좁은 타입으로 바꿀 경우 일부를 잘라낸다)

### Any,Any?: 최 상위 타입
* java에서 Object가 클래스 계층의 최상위 타입이듯, 코틀린에서는 Any타입이 모든 널이 될수 없는 타입의 조상이다
* java에서 원시타입은 Object 클래스 계층에 들어가지 않지만, 코틀린의 원시타입들은 Any 클래스 계층에 들어간다
* Any는 널이 될 수 없는 타입 이므로, 널이 될수 있는 타입을 포함하려면 Any?를 사용 하여야 한다.

### Unit 타입: 코틀린의 void
* 코틀린의 Unit은 java의 void와 같은 기능을 한다
* 하지만 Unit은 모든 기능을 갖는 일반적인 타입이며, void 와 달리 Unit타입을 인자로 쓸 수 없다
* Unit타입에 속한 값은 단 하나 뿐이며 그 이름도 Unit 이다

### Nothing타입: 이 함수는 결코 정상적으로 끝나지 않는다
* Nothing은 아무 값도 포함하지 않는다
* Nothing은 함수의 반환 타입으로 쓰일 분 파라미터로 쓰일 수는 없다

## 컬렉션과 배열

## 널 가능성과 컬렉션
* List<Int?> : Int? 타입의 값을 저장 할 수 있다. 리스트에는 Int나 null이 들어가지만 리스트 자체는 항상 널이 아니다
* List<Int>? : Int 타입의 값을 저장 하지만, 리스트 자체가 널일 수 도 있다
* List<Int?>? : Int? 타입의 값을 저장 하며, 리스트 자체가 널일 수 도 있다

### 읽기 전용과 변경 가능한 컬렉션
* 코틀린에서는 컬렉션 안의 데이터에 접근하는 인터페이스와 컨렉션 안의 데이터를 변경하는 인터페이스를 분리 하였다
* 컬렉션 안의 데이터에 접근하는 인터페이스는 Collection 이며, 이를 확장하여 데이터를 변경 하는 인터페이스가 MutableCollection 이다
* 이로 인해 어떤 함수가 Collection을 파라미터로 받을 경우, 그 함수는 컬렉션에 대해 읽기 연산만 가능하다
* 하지만 항상 염두를 해둬야 하는것이, 읽기 전용 컬렉션이라고 하여 꼭 변경 불가능한 컬렉션 일 필요는 없다
* 또한 읽기 전용 컬렉션은 항상 스레드 안전하지않기 떄문에 주의 해야 한다

### 코틀린 컬렉션과 자바
* 코틀린은 모든 자바의 컬렉션 인터페이스마다 읽기 전용 인터페이스와, 변경 가능한 인터페이스를 제공한다
* 코틀린에서 자바 메소드를 호출하되 컬렉션을 인자로 넘겨야 한다면 따로 변환 하거나 복사하는 등의 추가 작업 없이 직접 컬렉션을 넘기면 된다
* 하지만 자바에서는 읽기 전용 컬렉션과 변경 가능한 컬렉션을 구분하지 않기 때문에, 코틀린에서는 읽기 전용이여도 자바에서는 변경이 될 수 있다

### 컬렉션을 플랫폼 타입으로 다루기
* 자바 컬렉션을 코틀린에서 다루기 위해서는 다음 3가지를 사용할 코틀린 컬렉션 타입에 반영을 해야 한다
  - 컬렉션이 널이 될 수 있는가
  - 컬렉션의 원소가 널이 될 수 있는가
  - 오버라이드 하는 메소드가 컬렉션을 변경 할 수 있는가
* 이러한 특성 떄문에 자바 인터페이스가 어떤 맥락에서 사용되는지에 대해 명확히 알아야 한다

### 객체의 배열과 원시타입의 배열
* 코틀린의 배열은 타입 파라미터를 받는 클래스 이다.
* 코틀린에서의 배열을 만드는 방법은 다양하다
  - arrayOf 함수에 원소를 넘기면 배열을 만들 수 있다
  - arrayOfNulls 함수에 정수값을 인자로 넘기면, 그 크기만큼의 null을 가진 배열을 만들 수 있다
  - Array 생성자는 배열 크기와 람다를 인자로 받아, 람다를 호출하여 각 배열의 원소를 초기화 해준다
* 코틀린은 원시 타입의 배열을 표현하는 별도 클래스를 각 원시타입마다 하나씩 제공한다(IntArray, ByteArray 등)
* 원시 타입의 배열을 만드는 방법은 다음과 같다
  - 각 배열 타입의 생성자는 size인자를 받아 해당 원시타입의 디폴트값(0) 으로 초기화된 size크기의 배열을 반환한다
  - 팩토리 함수(intArrayOf 등)은 여러 값을 가변인자로 받아서 그런 값이 들어간 배열을 반환한다
  - 일반 배열과 마찬가지로 크기와 람다를 인자로 받는 생성자를 사용한다
  
## 요약
* 코틀린은 널이 될 수 있는 타입을 지원해 NullPointerExcepion 오류를 컴파일 시점에 감지 할 수 있다
* 코틀린의 ?. ?: !! let 함수등을 사용하면 널이 될 수 있는 타입을 간결한 코드로 다룰 수 있다
* as? 연산자를 사용하면 값을 다른 타입으로 변환하는 것과, 변환이 불가능 한 경우를 모두 처리 할 수 있다
* 자바에서 가져온 타입은 코틀린에서 플랫폼 타입으로 취급된다
* 개발자는 플랫폼 타입을 널이 될 수 있는 타입으로도, 널이 될 수 없는 타입으로도 사용 할 수 있다
* 코틀린에서 수를 표현 하는 타입이 일반 클래스와 똑같이 동작한다
* 널이 될 수 있는 원시타입은 자바의 박싱한 원시타입에 대응한다
* Any타입은 다른 모든 타입의 조상이며 자바의 Object에 해당한다
* 정상적으로 끝나지 않는 함수의 반환타입을 지정할 때 Nothing 타입을 사용한다
* 코틀린은 표준 자바 컬렉션 클래스를사용한다
* 자바의 컬렉션을 개선하기 위해 읽기 전용 컬렉션과 변경 가능한 컬렉션을 구별해 제공 한다
* 자바 클래스를 코틀린에서 확장하거나 자바 인터페이스를 코틀린에서 구현 할 경우 메소드 파라미터의 널 가능성과 변경 가능성에 유의 해야 한다
* 코틀린의 Array 클래스는 일반 제너릭 클래스처럼 보이지만, Array는 자바 배열로 컴파일 된다
* 원시 타입의 배열은 IntArray와 같이 각 타입에 대한 특별한 배열로 표현
