---
layout: post
title: "Effective Java - 아이템56: 공개된 API요소에는 항상 문서화 주석을 작성하라"
description: 공개된 API요소에는 항상 문서화 주석을 작성하라
date: 2020-09-06 20:41:00 +09:00
categories: EffectiveJava Study
---


# 메서드

## 아이템 56 : 공개된 API요소에는 항상 문서화 주석을 작성하라

- API를 쓸모있게 하려면 잘 작성된 문서도 곁들여야한다
- 전통적으로 API문서는 사람이 직접 작성하므로 코드가 변경되면 매번 함께 수정해줘야 하는데, 자바에서는 자바독이라는 유틸리티가 이 귀찬은 작업을 도와준다
- 자바독은 소스코드 파일에서 문서화 주석이라는 특수한 형태로 기술된 설명을 추려 API문서로 변환해둔자
- 문서화 주석을 작성하는 규칙은 공식 언어 명세에 속하지는 않지만 자바 프로그래머라명 응당 알아야 하는 업계 표준 API라 할 수 있다
    * 이 규칙은 How to Write Doc Comments 웹페이지에 기술되어 있다. 자바4 이후 갱신되지는 않았지만 그 가치는 여전히 중요하다

- 자바의 버전이 올라가면서 추가된 중요한 자바독 태그로는 자바5의 ```@literal```과 ```@code```, 자바8의 ```@implSpec```, 자바9의 ```@index```를 꼽을수 있다
- 여러분의 API를 올바로 운서화 하려면 공개된 모든 클래스, 인터페이스, 메서드, 필드선언에 문서화 주석을 달아야 한다. 직렬화 할 수 있는 클래스라면 직렬화 형태에 관해서도 적어야 한다
    * 문서화 주석이 없다면 자바독도 그저 공개 API의 요소들의 선언만 나열해주는게 전부이다. 문서가 잘 갖춰지지 않은 API는 쓰기 헷갈려서 오류의 원인이 되기 쉽다. 기본 생성자에는 문서화 주석을 달 방법이 없으니, 공개 클래스는 절대 기본 생성자를 사용하면 안된다
    * 유지보수까지 고려한다면 대다수의 공개되지 않은 클래스, 인터페이스, 생성자, 메서드, 필드에도 문서화 주석을 달아야 할것이다

- 메서드용 문서화 주석에는 해당 메서드와 클라이언트 사이의 규약을 명료하게 기술해야 한다
    * 상속용으로 설계된 클래스의 메서드가 아니라면, 그 메서드가 어떻게 동작하는지(how)가 아닌 무엇을 하는지(what)를 기술해야 한다
    * 문서화 주석에는 클라이언트가 해당 메서드를 호출하기 위한 전제조건을 모두 나열해야 한다
    * 또한 메서드가 성공적으로 수행된 후에 만족해야하는 사후조건도 모두 나열해야 한다
    * 일반적으로 전제조건은 ```@throws```태그로 비검사 예외를 선언하여 암묵적으로 기술한다. 비검사 예외 하나가 전제조건 하나와 연결되는것이다
    * ```@param``` 태그를 이용해 그 조건에 영향받는 매개변수를 기술 할 수도 있다
    * 전제조건과 사후조건 뿐만아니라 부작용도 문서화 해야 한다. 부작용이란 사후조건으로는 명확히 나타나지는 않지만 시스템의 상태에 어떠한 변화를 가져오는 것을 뜻한다. 예컨대 백그라운드 스레드를 시작시키는 메서드라면 그 사실을 문서에 밝혀야 한다

- 메서드의 계약을 완벽히 기술하려면 모든 매개변수에 ```@param``` 태그를, 반환타입이 void가 아니라면 ```@return```태그를, 발생할 가능성이 있는 모든 예외에 ```@throws``` 태그를 달아야 한다
    * 여러분이 따르는 코딩 표준에서 허락한다면 ```@return```태그의 설명이 메서드 설명과 같을경우에는 ```@return```을 생략해도 좋다

- 관례상 ```@param``` 태그와 ```@return``` 태그의 설명은 해당 매개변수가 뜻하는 값이나 반환값을 설명하는 명사구를 쓴다. 드물게는 명사구 대신 산술 표현식을 쓰기도 하는데 BigInteger의 예시가 그렇다
    * 또한 관례상 ```@param```, ```@return```, ```@throws``` 태그의 설명에는 마침표를 붙이지 않는다

```java
/**
* 이 리스트에서 지정한 위치의 원소를 반환한다.
*
*<p>이 메서드는 상수 시간에 수행됨을 보장하지 <i>않는다</i>.
* 구현에 따라 원소위치에 따라 비례해 시간이 걸릴수도 있다
*
* @param index 반환할 원소의 인덱스; 0 이상이고 리스크 크기보다 작아야한다.
* @return 이 리스트에서 지정한 위치의 원소
* @throws IndexOutOfBoundException index가 범위가 벗어나면, 즉, ({@code index < 0 || index >= this.size()})이면 발생한다
*/
E get(int index);
```

- 문서화 주석에 HTML태그를 쓴점에 주목해야한다. 자바독 유틸리티는 문서화 주석을 HTML로 변환하므로 문서화 주석안의 HTML요소들이 최종 HTML문서에도 반영된다
- ```@throws```절에 사용한 ```{@code}``` 태그도 유의해서 봐야한다. 이 태그의 효과는 2가지인데, 태그로 감싼 내용을 코드용 폰트로  렌더링하며, 태그로 감싼 내용에 포함된 HTML요소나 다른 자바독 태그를 무시한다. 두번째 효과 덕에 HTML 메타문자인 < 등을 별다른 처리 없이 바로 사용할 수 있다
- 문서화 주석에 여러줄로 된 코드 예시를 넣으려면 ```{@code}```를 다시 ```<pre>```태그로 감싸면 된다 ```<pre>{@code}</pre>```의 형태로 쓰면 된다
    * 단 @기호에는 무조건 탈출문자를 붙여야 하니 문서화 주석 안의 코드에서 어노테이션을 사용한다면 주의해야 한다

- 마지막으로 "이 리스트"를 주목해야 한다. 관례상 인스턴스 메서드의 문서화 주석에 쓰인 "이" 는 호출된 메서드가 자리하는 객체를 가리킨다
- 클래스를 상속용으로 설계할때는 자기사용 패턴에 대해서도 문서에 남겨, 다른 프로그래머에게 그 메서드를 올바로 재정의하는 방법을 알려줘야 한다. 자기사용 패턴은 ```@implSpec``` 태그로문서화 한다
    * 일반적인 문서화 주석은 해당 메서드와 클라이언트 사이의 계약을 설명한다
    * ```@implSpec``` 주석은 해당 메서드와 하위 클래스 사이의 계약을 설명하여, 하위 클래스들이 그 메서드를 상속하거나 super를 통해 호출할때 그 메서드가 어떻게 동작하는지를 명확히 인지시키고 사용하도록 해줘야 한다

```java
/**
* 이 컬렉션이 비어있다면 true를 반환한다.
*
* @implSpec 이 구현은 {@code this.size() == 0}의 결과를 반환한다.
*
* @return 이 컬렉션이 비어있다면 true, 그렇지 않으면 false
*/
public boolean imEmpty() { ... }
```

- API 설명에 <, >, & 등의 HTML메타 문자를 포함하려면 특별한 처리를 해줘야 함이다. 가장 좋은 방법은 ```{@literal}``` 태그로 감싸는것이며, 이는 ```{@code}```와 비슷하지만 코드 폰트로 렌더링 하지는 않는다

```java
* {@literal |r| < 1}이면 기하 수열이 수렴한다
```
- 이 주석은 "|r| < 1 이면 기하 수열이 수렴한다"로 변혼된다. 사실 < 기호만 감싸줘도 되지만, 그렇게하면 코드에서 문서화 주석을 읽기 어려워진다. 문서화 주석은 코드에서건 변환돤 API에서건 읽기 쉬워야 한다는게 일반 원칙이다. 양쪽다 만족할 수 없다면 API문서에서의 가독성이 먼저이다
- 각 문서화 주석의 첫번째 문장은 해당 요소의 요약 설명으로 간주된다. 요약 설명은 반드시 대상의 기능을 고유하게 기술해야 한다. 헷갈리지 않으려면 한 클래스(혹은 인터페이스)안에서 요약 설명이 똑같은 멤버(혹은 생성자)가 둘 이상이면 안된다
- 다중정의된 메서드가 있으면 특히 더 조심해야한다. 다중정의된 메서드들의 설명은 같은 문장으로 시작하는게 자연스럽겟지만, 문서화 주석에서는 허용하지 않는다
- 요약 설명에서는 마침표에 주의해야 한다. 예컨대 문서화 주석의 첫 문장이 "머스터드 대령이나 Mrs. 피콕 같은 용의자."라면 요약 설명은 "머스터드 대령이나 Mrs."까지만이다
    * 요약 설명이 끝나는 판단의 기준은 처음 발견되는 {<마침표><공백><다음 문장 시작>} 패턴의 <마침표>까지이다
    * 여기서 <공백>은 스페이스, 탭, 줄바꿈 이며 <다음 문장 시작>은 소문자가 아닌 문자이다
    * 가장 좋은 해결책은 의도치 않은 마침표를 포함한 텍스트를 ```{@literal}```로 감싸주는 것이다
    * 자바10부터는 ```{@summary}```라는 요약 설며 전용태그가 추가되었다

- 요약 설명이란 문서화 주석의 첫 문장이다 라고 말하면 살짝 오해의 소지가 있다. 주석 작성 규약에 따르면 요약 설명은 완전한 문장이 되는 경우가 드물기 떄문에, 메서드와 생성자의 요약설명은 해당 메서드가 생성자의 동작을 설명해주는 주어가 없는 동사구여야 한다
    * 클래스, 인터페이스, 필드의 요약 설명은 대상을 설명하는 명사절이여야 한다

- 자바9부터는 자바독이 생성한 HTML 문서에 검색기능이 추가되어 광대한 API문서들을 누비는 일이 한결 수월해졌다. 클레스, 메서드, 필드같은 API요소의 색인은 자동으로 만들어지며, 원한다면 ```{@index}``` 태그를 사용해 API에서 중요한 용어를 추가로 색인화 할 수 있다
- 문서화 주석에서 제너릭, 열거타입, 어노테이션은 특별히 주의해야 한다
    * 제너릭 타입이나 제너릭 메서드를 문서화 할 때는 모든 타입 매개변수에 주석을 달아야 한다
    * 열거 타입을 문서화 할때에는 상수들에도 주석을 달아야 한다. 열거타입 자체와 그 열거타입의 public 메서드도 물론이다
    * 어노테이션 타입을 문서화 할 떄에는 멤버들에도 모두 주석을 달아야 한다. 어노테이션 타입 자체도 물론이며, 필드 설명은 명사구로 한다. 어노테이션 타입의 요약 설명은 프로그램 요소에 이 어노테이션을 단다는것이 어떤 의미인지를 설명하는 동사구로 한다

- 패키지를 설명하는 문서화 주석은 package-info.java 파일에 작성한다. 이 파일은 패키지 선언을 반드시 포함해야 하며, 패키지 선언 관련에 어노테이션을 추가로 포함 할 수도 있다
- 모듈 시스템을 사용한다면 모듈 관련 설명은 module-info.java 파일에 작성하면 된다
- API문서화에서 자주 누락되는 설명이 2가지 있는데, 스레드 안정성과 직렬화 가능성이다. 클래스 혹은 정적 메서드가 스레드 안전하든 그렇지 않든, 스레드 안전 수준을 반드시 API 설명에 포함해야 한다. 직렬화 할 수 있는 클래스라면 직렬화 형태도 API설명에 기술해야 한다
- 자바독은 메서드 주석을 '상속'시킬수 있다. 문서화 주석이 없는 API 요소를 발견하면 자바독이 가장 가까운 문서화 주석을 찾아준다. 이때 상위 '클래스' 보다, 그 클래스가 구현한 '인터페이스'를 먼저 찾는다
- 또한 ```{@inheritDoc}``` 태그를 사용해 상위 타입의 문서화 주석 일부를 상속 할 수도 있다. 클래스는 자신이 구현한 인터페이스의 문서화 주석을 재사용할 수 있는 것이다. 이 기능을 사용하면 거의 똑같은 문서화 주석 여러개를 유지보수 하는 부담을 줄일 수 있지만, 사용하기 까다롭고 제약도 조금 있다
- 문서화 주석에 관해 언급해둘 주의사항이 하나 더 있는데, 모든 공개 API 요소에 문서화 주석을 달았더라도, 이것만으로는 충분하지 않을때가 있다. 여러 클래스가 상호작용하는 복잡한 API라면 문서화 주석 외에도 전체 아키텍처를 설명하는 별도의 설명이 필요할 때가 왕왕있다. 이러한 설명 문서가 있다면 관련 클래스나 패키지의 문서화 주석에서 그 문서의 링크를 제공 해주면 좋다
- 자바독은 프로그래머가 자바독 문서를 올바르게 작성했는지 확인하는 기능을 제공하며, 이번 아이템에서 소개한 권장사항중 상당수를 검사해준다
- 자바8 부터는 기본으로 동작하며 checkstyle같은 IDE 플로그인을 사용하면 더 완벽하게 검사할 수 있으며, 자바독이 생성한 HTML파일을 HTML유효성 검사기로 돌리면 문서와 주석의 오류를 한층 더 줄일 수 있다
- 이번 아이템에서 설명한 지침을 잘 따른다면 여러분의 API를 깔끔히 설명하는 문서를 작성할 수 있다. 하지만 정말 잘 쓰인 문서인지를 확인하는 유틸한 방법은 자바독 유틸리티가 생성한 웹페이지를 읽어보는 길 뿐이다