---
layout: post
title: "Real MySQL 10 : 실행 계획"
description: Real MySQL 10장 - 실행 계획
date: 2021-12-26 19:23:00 +09:00
categories: MySQL RealMySQL Study
---

# 실행 계획

## 통계 정보
- MySQL 서버 5.7까지는 테이블과 인덱스에 대한 개괄적 정보를 가지고 실행 계획을 수립. 따라서 정확도가 떨어지는 경우가 많았음
- MySQL 서버 8.0 부터는 인덱스되지 않은 칼럼들에 대해서도 데이터 분포도를 수집해서 저장하는 히스토그램 정보가 도입

### 테이블 및 인덱스 통계 정보
- MySQL도 다른 DBMS처럼 비용 기반의 최적화를 사용 하지만, 다른 DBMS보다 통계 정보의 정확도가 높지 않고 통계 정보의 휘발성이 강함. 크래서 쿼리의 실행 계획을 수립할때 실제 테이블의 데이터를 일부 분석해서 통계 정보를 보완해서 사용
- MySQL 서버의 통계 정보
    * MySQL 5.6부터는 InnoDB 스토리지 엔진을 사용하는 테이블에 대한 통계 정보를영구적으로 관리할 수 있게 개선
    * 각 테이블의 통계 정보를 mysql 데이터베이스의 innodb_index_stats 테이블과 innodb_table_stats 테이블로 관리. 통계 정보가 테이블로 관리됨으로써 서버가 재시작되도 기존의 통계 정보 유지 가능
    * 각 테이블의 통계 정보를 영구적, 또는 단기적으로 변경하는것은 ALTETR TABLE을 통해서 가능(STATS_PERSISTENT=0,1 이용)
    * 통계 정보의 각 칼럼은 인덱스가 가진 유니크 값의 갯수, 인덱스의 리프 노드 페이지 개수, 인덱스 트리의 전체 페이지 개수, 테이블의 전체 레코드 건수등이 있음
    * MySQL 5.5까지는 테이블의 통계 정보가 메모리에만 저장되며 테이블이 새로 오픈되는경우, 테이블의 레코드가 대량(테이블 전체 레코드 중에서 1/16)으로 변경, ANALYZE TABLE 명령 등의 이벤트가 발생하면 자동으로 통계정보가 갱신
    * innodb_stats_auto_recalc 시스템 변수를 OFF로 변경하여서 자동 갱신되는걸 막고, STATS_AUTO_RECALC 옵션을 이용해 통계 정보를 자동으로 수집할지 여부도 테이블 생성할때 테이블 단위로 가능
    * innodb_stats_transient_sample_pages와 innodb_stats_persistent_sample_pages 변수로 자동으로 통계 정보 수집이 실행될때 몇개의 페이지만 임의로 샘플링해서 분석할지와, ANALYZE TABLE 명령에서 몇개의 페이지를 샘플링해서 분석할지 결정
    * 정확한 통계 정보를 수집하고자 하면 innodb_stats_persistent_sample_pages 변수의 값을 높이면 되나 너무 높이면 통계 정보 수집 기간이 길어지므로 주의

### 히스토그랭
- 히스토그램 정보 수집 및 삭제
    * MySQL 8.0 버전에서 히스토그램 정보는 칼럼 단위로 관리(수동), 수집된 히스코드램 정보는 시스템 딕셔너리에 함께 저장
    * Singleton 히스토그램(칼럼값 개별로 레코드 건수를 관리하는 히스토그램, 도수분포표), Equi-Height 히스토그램(칼럼값의 범위를 균등한 개수로 구분해서 관리하는 히스토그램)
    * 히스토그램은 버킷 단위로 구분되어 레코드 건수나 칼럼값의 범위가 관리(싱글톤 - 칼럼값과 발생 빈도의 비율 2개, 높이 균형 히스토그램 - 범위 시작값, 마지막값, 발생빈도율, 버킷별 유니크한 값의 갯수)
    * 히스토그램 삭제 작업은 테이블의 데이터를 참조하는것이 아니라 딕셔너리 내용만 삭제하기 때문에 다른 쿼리 처리의 성능에 영햐ㅐㅇ을 주지 않고 즉시 완료. 하지만 히스토그램이 사라지면 쿼리의 실행 계획이 바뀔수있으니 주의
    * 히스토그램을 삭제하지 않고 MySQL 옵티마이저가 히스토그램을 사용하지 않게 할수도 있음(optimizer_switch 시스템 변수값 변경)

- 히스토그램의 용도
    * 테이블과 인덱스에 대한 통계 정보는 항상 균등한 분포도를 가지고 있지 않기 때문에, 이러한 단점을 보완하기 위해서 히스토그램이 도입
    * 히스토그램은 특정 칼럼이 가지는 모든 값에 대한 분포도 정보를 가지지는 않지만 각 범위별 레코드 건수와 유니크한 값의 개수 정보를 가지고 있기 때문에 훨씬 더 정확한 예측 가능
    * 히스토그램이 없으면 옵티마이저는 데이터가 균등하게 분포돼 있을것으로 예측. 하지만 히스토그램이 있으면 특정 범위의 데이터가 많고 적음을 식별 가능

- 히스토그램과 인덱스
    * 히스토그램과 인덱스는 완전히 다른 객체이기 때문에 서로 비교할 대상은 아니지만, 부족한 통계 정보를 수집하기 위해 사용된다는 측면에서는 공통점이 있음
    * MySQL서버에서는 쿼리의 실행 계획을 수립할때 사용 가능한 인덱스들로 부터 조건절에 일치하는 레코드 건수를 대략 파악하고 최종적으로 가장 나은 실행 계획을 선택하는데, 조건절에 일치하는 레코드 건수를 예측하기 위해 실제 인덱스의 B-Tree를 샘플링해서 살펴봄(인덱스 다이브)
    * MySQL서버에서는 인덱스된 칼럼을 검색 조건으로 사용하는 경우, 그 칼럼의 히스토그램은 사용하지 않고 실제 인덱스 다이브를 통해 직접 수집한 정보를 활용(히스토그램은 주로 인덱스 되지 않은 칼럼에 대한 데이터 분포도를 참조)
    * 인덱스 다이브 작업은 어느정도 비용이 필요하며 떄로는 실행 계획 수립만으로도 상당한 인덱스 다이브를 실행하기도 함

### 코스트 모델
- MySQL서버가 쿼리를 처리하려면 디스크로부터 페이지 읽기, 메모리로부터 데이터 페이지 읽기, 인덱스 키 비교, 레코드 펴악, 메모리 임시 테이블 작업, 디스크 임시 테이블 작업 등 다양한 작업을 필요로 함
- MySQL서버는 사용자의 쿼리에 대해 이러한 다양한 작업이 얼마나 필요한지 예측하고, 전체 작업 비용을 계산한 결과를 바탕으로 최적의 실행 계획을 찾음. 이렇게 쿼리의 비용을 계산하는데 필요한 작업들의 비용을 코스트 모델이라고 함
- MySQL 5.7 이전까지는 이런 작업들의 비용이 서버 소스코드에 상수화 되어 있었지만, 5.7버전부터 DBMS 관리자가 조정할수있게 개선되었음. 8.0 부터는 히스토그램이나 메모리에 상주중인 페이지의 비율 계산 등의 정보도 추가됨
- MySQL 8.0 서버의 코스트 모델은 mysql DB에 있는 server_cost, engine_cost 테이블에 저장돼있는 설정값을 사용
- 스토리지 엔진별로 각 단위 작업의 비용을 설정할수 있음
- 코스트 모델에서 중요한것은 각 단위 작업에 설정되는 비용 값이 커지면 어떤 실행 계획들이 고비용/저비용으로 바뀌는지를 파악하는것
    * key_compare_cost를 높임 -> 가능하면 정렬을 수행하지 않는 방향의 실행계획
    * row_evaluate_cost를 높임 -> 풀스캔을 실행하는 쿼리들의 비용이 높아짐. 가능하면 인덱스 레인지 스캔을 사용하는 실행계획
    * dist_temptable_create_cost/disk_temptable_row_cost를 높임 -> 디스크에 임시 테이블을 만들지 않는 방향의 실행 계획
    * memory_temptable_create_cost/memory_temptable_row_cost를 높임 -> 메모리 임시테이블을 만들지 않는 방향의 실행 계획
    * io_block_read_cost를 높임 -> InnoDB 버퍼 풀에 데이터 페이지가 많이 적재돼 있는 인덱스를 사용하는 실행 계획
    * momory_block_read_cost 높임 -> InnoDB 버퍼 풀에 적재된 데이터 페이지가 상대적으로 적더라도 그 인덱스를 사용할 가능성이 높음


## 실행 계획 확인
- 실행 계획은 DESC 또는 EXPLAIN 명령으로 확인 가능

### 실행 계획 출력 포맷
- FORMAT옵션을 사용해 실행 계획의 표시 방법을 JSON이나 TREE, 단순 테이블 형태로 선택 가능
- EXPLAIN ANALYZE 기능으로 쿼리의 실행 계획과 단계별 소요된 시간 정보를 확인할수있음

