---
layout: post
title: "Real MySQL 10 : 실행 계획"
description: Real MySQL 10장 - 실행 계획
date: 2021-12-26 19:23:00 +09:00
categories: MySQL RealMySQL Study
---

# 실행 계획

## 통계 정보
- MySQL 서버 5.7까지는 테이블과 인덱스에 대한 개괄적 정보를 가지고 실행 계획을 수립. 따라서 정확도가 떨어지는 경우가 많았음
- MySQL 서버 8.0 부터는 인덱스되지 않은 칼럼들에 대해서도 데이터 분포도를 수집해서 저장하는 히스토그램 정보가 도입

### 테이블 및 인덱스 통계 정보
- MySQL도 다른 DBMS처럼 비용 기반의 최적화를 사용 하지만, 다른 DBMS보다 통계 정보의 정확도가 높지 않고 통계 정보의 휘발성이 강함. 크래서 쿼리의 실행 계획을 수립할때 실제 테이블의 데이터를 일부 분석해서 통계 정보를 보완해서 사용
- MySQL 서버의 통계 정보
    * MySQL 5.6부터는 InnoDB 스토리지 엔진을 사용하는 테이블에 대한 통계 정보를영구적으로 관리할 수 있게 개선
    * 각 테이블의 통계 정보를 mysql 데이터베이스의 innodb_index_stats 테이블과 innodb_table_stats 테이블로 관리. 통계 정보가 테이블로 관리됨으로써 서버가 재시작되도 기존의 통계 정보 유지 가능
    * 각 테이블의 통계 정보를 영구적, 또는 단기적으로 변경하는것은 ALTETR TABLE을 통해서 가능(STATS_PERSISTENT=0,1 이용)
    * 통계 정보의 각 칼럼은 인덱스가 가진 유니크 값의 갯수, 인덱스의 리프 노드 페이지 개수, 인덱스 트리의 전체 페이지 개수, 테이블의 전체 레코드 건수등이 있음
    * MySQL 5.5까지는 테이블의 통계 정보가 메모리에만 저장되며 테이블이 새로 오픈되는경우, 테이블의 레코드가 대량(테이블 전체 레코드 중에서 1/16)으로 변경, ANALYZE TABLE 명령 등의 이벤트가 발생하면 자동으로 통계정보가 갱신
    * innodb_stats_auto_recalc 시스템 변수를 OFF로 변경하여서 자동 갱신되는걸 막고, STATS_AUTO_RECALC 옵션을 이용해 통계 정보를 자동으로 수집할지 여부도 테이블 생성할때 테이블 단위로 가능
    * innodb_stats_transient_sample_pages와 innodb_stats_persistent_sample_pages 변수로 자동으로 통계 정보 수집이 실행될때 몇개의 페이지만 임의로 샘플링해서 분석할지와, ANALYZE TABLE 명령에서 몇개의 페이지를 샘플링해서 분석할지 결정
    * 정확한 통계 정보를 수집하고자 하면 innodb_stats_persistent_sample_pages 변수의 값을 높이면 되나 너무 높이면 통계 정보 수집 기간이 길어지므로 주의

### 히스토그랭
- 히스토그램 정보 수집 및 삭제
    * MySQL 8.0 버전에서 히스토그램 정보는 칼럼 단위로 관리(수동), 수집된 히스코드램 정보는 시스템 딕셔너리에 함께 저장
    * Singleton 히스토그램(칼럼값 개별로 레코드 건수를 관리하는 히스토그램, 도수분포표), Equi-Height 히스토그램(칼럼값의 범위를 균등한 개수로 구분해서 관리하는 히스토그램)
    * 히스토그램은 버킷 단위로 구분되어 레코드 건수나 칼럼값의 범위가 관리(싱글톤 - 칼럼값과 발생 빈도의 비율 2개, 높이 균형 히스토그램 - 범위 시작값, 마지막값, 발생빈도율, 버킷별 유니크한 값의 갯수)
    * 히스토그램 삭제 작업은 테이블의 데이터를 참조하는것이 아니라 딕셔너리 내용만 삭제하기 때문에 다른 쿼리 처리의 성능에 영햐ㅐㅇ을 주지 않고 즉시 완료. 하지만 히스토그램이 사라지면 쿼리의 실행 계획이 바뀔수있으니 주의
    * 히스토그램을 삭제하지 않고 MySQL 옵티마이저가 히스토그램을 사용하지 않게 할수도 있음(optimizer_switch 시스템 변수값 변경)

- 히스토그램의 용도
    * 테이블과 인덱스에 대한 통계 정보는 항상 균등한 분포도를 가지고 있지 않기 때문에, 이러한 단점을 보완하기 위해서 히스토그램이 도입
    * 히스토그램은 특정 칼럼이 가지는 모든 값에 대한 분포도 정보를 가지지는 않지만 각 범위별 레코드 건수와 유니크한 값의 개수 정보를 가지고 있기 때문에 훨씬 더 정확한 예측 가능
    * 히스토그램이 없으면 옵티마이저는 데이터가 균등하게 분포돼 있을것으로 예측. 하지만 히스토그램이 있으면 특정 범위의 데이터가 많고 적음을 식별 가능

- 히스토그램과 인덱스
    * 히스토그램과 인덱스는 완전히 다른 객체이기 때문에 서로 비교할 대상은 아니지만, 부족한 통계 정보를 수집하기 위해 사용된다는 측면에서는 공통점이 있음
    * MySQL서버에서는 쿼리의 실행 계획을 수립할때 사용 가능한 인덱스들로 부터 조건절에 일치하는 레코드 건수를 대략 파악하고 최종적으로 가장 나은 실행 계획을 선택하는데, 조건절에 일치하는 레코드 건수를 예측하기 위해 실제 인덱스의 B-Tree를 샘플링해서 살펴봄(인덱스 다이브)
    * MySQL서버에서는 인덱스된 칼럼을 검색 조건으로 사용하는 경우, 그 칼럼의 히스토그램은 사용하지 않고 실제 인덱스 다이브를 통해 직접 수집한 정보를 활용(히스토그램은 주로 인덱스 되지 않은 칼럼에 대한 데이터 분포도를 참조)
    * 인덱스 다이브 작업은 어느정도 비용이 필요하며 떄로는 실행 계획 수립만으로도 상당한 인덱스 다이브를 실행하기도 함

### 코스트 모델
- MySQL서버가 쿼리를 처리하려면 디스크로부터 페이지 읽기, 메모리로부터 데이터 페이지 읽기, 인덱스 키 비교, 레코드 펴악, 메모리 임시 테이블 작업, 디스크 임시 테이블 작업 등 다양한 작업을 필요로 함
- MySQL서버는 사용자의 쿼리에 대해 이러한 다양한 작업이 얼마나 필요한지 예측하고, 전체 작업 비용을 계산한 결과를 바탕으로 최적의 실행 계획을 찾음. 이렇게 쿼리의 비용을 계산하는데 필요한 작업들의 비용을 코스트 모델이라고 함
- MySQL 5.7 이전까지는 이런 작업들의 비용이 서버 소스코드에 상수화 되어 있었지만, 5.7버전부터 DBMS 관리자가 조정할수있게 개선되었음. 8.0 부터는 히스토그램이나 메모리에 상주중인 페이지의 비율 계산 등의 정보도 추가됨
- MySQL 8.0 서버의 코스트 모델은 mysql DB에 있는 server_cost, engine_cost 테이블에 저장돼있는 설정값을 사용
- 스토리지 엔진별로 각 단위 작업의 비용을 설정할수 있음
- 코스트 모델에서 중요한것은 각 단위 작업에 설정되는 비용 값이 커지면 어떤 실행 계획들이 고비용/저비용으로 바뀌는지를 파악하는것
    * key_compare_cost를 높임 -> 가능하면 정렬을 수행하지 않는 방향의 실행계획
    * row_evaluate_cost를 높임 -> 풀스캔을 실행하는 쿼리들의 비용이 높아짐. 가능하면 인덱스 레인지 스캔을 사용하는 실행계획
    * dist_temptable_create_cost/disk_temptable_row_cost를 높임 -> 디스크에 임시 테이블을 만들지 않는 방향의 실행 계획
    * memory_temptable_create_cost/memory_temptable_row_cost를 높임 -> 메모리 임시테이블을 만들지 않는 방향의 실행 계획
    * io_block_read_cost를 높임 -> InnoDB 버퍼 풀에 데이터 페이지가 많이 적재돼 있는 인덱스를 사용하는 실행 계획
    * momory_block_read_cost 높임 -> InnoDB 버퍼 풀에 적재된 데이터 페이지가 상대적으로 적더라도 그 인덱스를 사용할 가능성이 높음


## 실행 계획 확인
- 실행 계획은 DESC 또는 EXPLAIN 명령으로 확인 가능

### 실행 계획 출력 포맷
- FORMAT옵션을 사용해 실행 계획의 표시 방법을 JSON이나 TREE, 단순 테이블 형태로 선택 가능
- EXPLAIN ANALYZE 기능으로 쿼리의 실행 계획과 단계별 소요된 시간 정보를 확인할수있음

## 실행 계획 분석

### id칼럼
- 하나의 SELECT문장은 다시 1개 이상의 하위 SELECT문장을 포함할 수 있고, 이렇게 SELECT단위로 구분한것을 단위 쿼리라고 표현하며, 실행 계획에서 가장 왼쪽에 표시되는 ID칼럼은 단위 SELECT별로 부여되는 식별자 값
- SELECT문장은 하나인데 여러개의 테이블이 조인되는 경우에는 id값이 증가하지 않고 같은 id값이 부여
- 실행계획의  id칼럼이 테이블의 접근 순서를 의미하는것은 아님(EXPLAIN FORMAT=TREE 명령을 통해 확인해보면 순서를 더 정확히 알 수 있음)

### select_type 칼럼
- SIMPLE: UNION이나 서브쿼리를 사용하지 않는 단순한 SELECT, 쿼리에 조인이 포함된 경우도 마찬가지. 쿼리 문장이 아무리 복잡해도 SIMPLE 쿼리는 단 하나만 존재하며, 일반적으로 제일 바깥 SELECT쿼리
- PRIMARY: UNION이나 서브쿼리를 가지는 쿼리에서 가장 바깥쪽의 단위 쿼리
- UNION: UNION으로 결합하는 단위 SELECT쿼리 가운ㄴ제 첫번째를 제외한 두번째 이후 단위 SELECT쿼리. 첫번째 단위 SELECT는 UNION되는 쿼리 결과들을 모아서 저장하는 임시 테이블(DERIVED)이 select_type
- DEPENDENT UNION: UNION이나 UNION ALL로 결합된 단위 쿼리가 외부 쿼리에 의해 영향 받는것. 내부 쿼리가 외부의 값을 참조해서 처리될때
- UNION RESULT: UNION 결과를 담아두는 테이블. MySQL 8.0부터는 UNION ALL이 임시 테이블을 사용하지 않도록 되었으나, UNION/UNION DISTINCT는 아직 임시테이블을 사용하므로 실행 계획상 임시테이블을 가르키는 라인의 select_type이 UNION RESULT. 단위쿼리가 아니라 별도의 id는 없음
- SUBQUERY: FROM절 이외에서 사용되는 서브쿼리만을 의미. FROM절에서 사용되는 서브쿼리는 DERIVED, 이외의 위치에서 사용되는 서브쿼리는 전부 SUBQUERY
- DEPENDENT SUBQUERY: 서브쿼리가 바깥쪽 SELECT쿼리에서 정의된 칼럼을 사용하는 경우
- DERIVED: 단위 SELECT쿼리의 실행 결과로 메모리나 디스크에 임시 테이블을 생성하는것(임시 테이블 혹은 파생 테이블이라고 부르는 그것)
- DEPENDENT DERIVED: 해당 테이블이 레터럴 조인으로 사용된것
- UNCACHEABLE SUBQUERY: 서브 쿼리에 포함된 요소에 의해 캐시 자체가 불가능한 경우(사용자 변수가 서브 쿼리에 사용, NON_DETERMINISTIC 속성의 스토어드 루틴이 서브쿼리내 사용된 경우, UUID()나 RAND()와 같이 결괏값이 호출할떄마다 달라지는 함수가 서브쿼리에 사용된 경우)
- UNCACHEABLE UNION: UNION + UNCACHEABLE
- MATERIALIZED: FROM절이나 IN(subquery) 형태의 쿼리에 사용된 서브쿼리의 최적화를 위해 쿼리의 내용을 임시 테이블로 생성한다

## table 칼럼
- MySQL 서버의 실행 계획은 단위 SELECT쿼리 기준이 아니라 테이블 기준으로 표시
- 별도의 테이블을 사용하지 않는 SELECT 쿼리는 table 칼럼에 NULL 표시
, 별도의 테이블을 사용하지 않는 SELECT 쿼리는 table 칼럼에 NULL 표시
- <> 로 둘러싸인 이름은 임시 테이블을 의미. <>에 표시되는 숫자는 단위 SELECT쿼리의 id값을 지칭

## partitions 칼럼
- MySQL 5.7까지는 EXPLAIN PARTITION명령을 통해 확인 가능했지만, 8.0부터는 EXPLAIN 명령으로 파티션 관련 실행 계획까지 모두 확인 가능
- 파티션이 여러개인 테이블에서 불필요한 파티션을 빼고 쿼리를 수행하기 위해 접근해야 할것으로 판단되는 테이블만 골라내는 과정을 파티션 프루닝 이라고 함
- 쿼리의 실행 계획을 통해서 어느 파티션을 읽는지 확인 가능해야 쿼리의 튜닝이 가능할것

## type 칼럼
- MySQL서버가 각 테이블들의 레코드를 어떤 방식으로 읽었는지를 나타냄(인덱스를 사용했는지, 풀 테이블 스캔으로 읽었는지 등)
- MySQL의 메뉴얼에는 type칼럼을 조인 타입으로 소개. MySQL에서는 하나의 테이블로부터 레코드를 읽는 작업도 조인처럼 처리
- type칼럼에 표시될수 있는 값은 다음과 같음
    * system
    * const
    * eq_ref
    * ref
    * fulltext
    * ref_or_null
    * unique_subquery
    * index_subquery
    * range
    * index_merge
    * index
    * ALL

- 위의 방법중 ALL을 제외한 나머지는 모두 인덱스를 이용. ALL은 풀 테이블 스캔. 하나의 SLECT쿼리는 위의 접근 방법중 단 하나만 사용 가능. index_merge를 제외한 나머지 접근 방법은 단 하나의 인덱스만을 사용
- system: 레코드가 1건만 존재하는 테이블, 또는 단 한건도 존재하지 않는 테이블을 참조하는 형태(MyISAM, MEMORY에서만 사용되는 접근 방법)
- const: 테이블의 레코드 건수와 관계 없이 쿼리가 프라이머리 키나 유니크 키 칼럼을 이용하는 WHERE 조건절을 가지고 있고, 반드시 1건을 반환하는쿼리의 처리 방식
- eq_ref: 여러 테이블이 조인되는 쿼리의 실행 계획에서만 표시. 조인에서 처음 읽은 테이블의 칼럼 값을 그 다음 읽어야할 테이블의 프라이머리 키나 유니크 키 칼럼의 검색 조건에 사용할때. 두번쨰 이후에 읽히는 테이블을 유니크 키로 검색할때 그 유니크 인덱스는 NOT NULL이여야 하며, 다중 조건으로 만들어진 프라이머리 키나 유니크 인덱스라면 인덱스의 모든 칼럼이 비교 조건에 사용 되야만 eq_ref 접근 방법
- ref: 조인의 순서와 관계없고, 프라이머리 키나 유니크 키등의 제약 조건도 없음. 인덱스의 종류와 상관 없이 동등 조건으로 검색할 때
- fulltext: 전문 검색 인덱스를 사용해 레코드를 읽는 접근 방법. 전문 검색 인덱스는 통계 정보과 관리되지 않으며, 전문 검색 인덱스를 사용 하려면 전혀 다른 SQL문법을 사용 해야함
- ref_or_null: ref 접근 방법과 같은데 null 비교가 추가된 형태. ref 또는 Null 비교
- uniuqe_subquery: WHERE 조건절에서 사용될 수 있는 IN 형태의 쿼리를 위한 접근 방법. 서브쿼리에서 중복되지 않는 유니크한 값만 반환할때
- index_subquery: 서브쿼리 결과의 중복된 값을 인덱스를 통해서 제거할 수 있을때
- range: 인덱스 레인지 스캔 형태의 접근 방법. <, >, IS NULL, BETWEEN, IN, LIKE 등의 연산자를 이용해 인덱스를 검색할 때
- index_merge: 2개 이상의 인덱스를 이용해 각각의 검색 결과를 만들어낸 후, 그 결과를 병합해서 처리하는 방식. 여러 인덱스를 읽어야 하므로 range 접근 방법보다 효율성이 떨어지며, 전문 검색 인덱스에서는 적용되지 않고, index_merge 접근 방법으로 처리된 결과는 항상 2개 이상의 집합이 되기 떄문에, 교집합, 합집합, 또는 중복제거 같은 부가적 작업 필요
- index: 인덱스를 처음부터 끝까지 읽는 인덱스 ㅜㄹ 그샌을 의미. 풀 테이블 스캔방식과 비교해서 비교하는 레코드 건수는 같지만, 인덱스는 일반적으로 데이터파일 전체보다 크기가 작아 풀 테이블 스캔보다는 빠르게 처리
- ALL: 풀 테이블 스캔. 가장 비효율적인방법

## possible_keys 칼럼
- 옵티마이저가 최적의 실행 계획을 만들기 위해 후보로 선정했던 접근 방법에서 사용되는 인덱스의 목록일 뿐. 무시해도 됨

## key 칼럼
- 최종 선택된 실행 계획에서 사용되는 인덱스를 의미. 쿼리 튜닝시 key칼럼에 의도했던 인덱스가 표시되는지 확인하는게 중요

## key_len 칼럼
- 쿼리를 처리하기 위해 다중 칼럼으로 구성된 인덱스에서 몇개의 칼럼까지 사용했는지 알려주는 감. 다중 칼럼 인덱스 뿐만 아니라 단일 칼럼으로 만들어진 인덱스에서도 같은 지표를 제공

## ref칼럼
- 접근 방법이 ref면 참조 조건으로 어떤 값이 제공 됐는지 보여줌
- 상숫값을 지정 했다면 ref칼럼의 값은 const로 표시 되고, 다른 테이블의 칼럼 값이면 그 테이블명과 칼럼 명이 표시
- ref의 칼럼이 func로 표시되며 참조용으로 사용되는 값을 그대로 사용한것이아니라 콜레이션 변환이나 값 자체의 연산을 거쳐서 참조됬다는걸 의미

## rows 칼럼
- 실행 계획의 효율성 판단을 위해 예측했던 레코드 건수. 정확하지는 않음
- 레코드의 예측치가 아니라 쿼리를 처리하기 위해 얼마나 많은 레코드를 읽고 체크해야 하는지를 의미

## filtered 칼럼
- 

## extra 칼럼
- const row not found: 쿼리의 실행 계획에서 const 접근 방식으로 테이블을 읽었지만 실제로 해당 테이블에 레코드가 1건도 존재하지 않을때
- deleting all rows: 스토리지 엔진의 핸들러 차원에서 테이블의 모든 레코드를 삭제하는 기능을 제공하는 스토리지 엔진인 경우. WHERE 조건절이 없는 DELETE 문장의 실행 계획에서 자주 표시됨
- distinct: 쿼리의 DISTINCT를 처리하기 위해 조인하지 않아도 되는 항목은 모두 무시하고 꼭 필요한 것만 조인
- firstmatch: 세미조인 최적화중에서 firstMathch 전략이 사용될때
- full scan on null key: 쿼리를 실행하는중 null을 만나면 차선책으로 서브쿼리 테이블에 대해서 풀 테이블 스캔을 사용할것이라는것을 알려주는 키워드
- impossible having: 쿼리에 사용된 having 절의 조건을 만족하는 레코드가 없을떄
- impossible where: where 조건이 항상 false가 될수밖에 없는 경우
- loosescan: 세미 조인 최적화중 loosecan 최적화 전략이 사용됨
- No matcing min/max row: min/max와 같은 집합 함수의 조건절에 만족하는 레코드가 한건도 없는 경우
- no matching row in const table: 쿼리 조인에 사용된 테이블에서 const 방법으로 접근할 떄 일치하는 레코드가 없는 경우(실행 계획을 만들기 위한 기초 자료가 없음)
- no matcing rows after partition pruning: 파티션된 테이블에 대한 update 또는 delete 명령의 실행 계획에서, 해당 파티션에 update 하거나 delete할 대상 레코드가 없을때
- no tables used: FROM절이 없는 쿼리 문장이나 FROM DUAL 형태의 쿼리 실행 계획에서 출력. MySQL에서는 FROM절이 없는 쿼리도 혀용되기에, FROM절이 없거나 FROM절에 상수 테이블을 의미하는 DUAL이 쓰인 경우 표시
- Not exists: NOT IN(sub query) 형태나 NOT EXISTS 연산자를 사용해서 안티조인을 하는 경우도 있지만, 레코드의 건수가 많은경우 아우터 조인을 이용하면 빠른 성능을 낼 수 있으며, 이런 아우터 조인을 이용한 안티 조인에서 테이블을 조인할때, 조인되는 테이블에 레코드가 존재하는지 아닌지 판단만 하는것
- Plan isn't ready yet: EXPLAIN FOR CONNECTION을 이용해서 MySQL 옵티마이저가 의도된 인덱스를 사용하지 못해서 풀스캔을 한다거나 잘못된 실행 계획을 선택한것이 아닌지 확인할때 사용하는데, 이때 Extra칼럼에 Plain is not ready yet이 나오는 경우 해당 커넥션에서 아직 쿼리의 실행 계획이 수립되지 못한 경우
- range checked for each record(index map:N): 레코드마다 인덱스 레인지 스캔을 체크
- recursive: MySQL 8.0부터는 CTE(Common Table Expression)을 이용해 재귀 쿼리 작성이 가능한데, WITH 구문을 이용해서 CTE를 사용하면 됨. 이렇게 CTE를 활용한 재귀 쿼리의 실행은 Recursive
- rematerialize: MySQL 8.0부터는 레터럴 조인 기능이 추가되었는데, 레터럴로 조인되는 테이블은 선행 테이블의 레코드별로 서브쿼리를 실행해서 그 결과를 임시테이블에 저장함. 이 과정을 Rematerializing이라고 함
- Select tables optimized away: MIN, MAX 만 SELECT 절에 사용 되거나 GROUP BY로 MIN, MAX를 조회하는 쿼리가 인덱스를 오름차순 또는 내림차수느올 1건만 읽는 형태의 최적화가 적용되는 경우
- start temporary, end temporary: 세미 조인 최적화중에서 Duplicate weed out 최적화 전략이 사용된 경우 불필요한 중복건을 제거하기 윟 ㅐ니부 임시 테이블을 사용하는데, 이때 조인되어 내부 임시테이블에 저장되는 테이블을 식별할수 있게 조인의 첫번째 테이블에 start temporary, 조인이 끝나는 부분에 end temporary 표시
- unique row not found: 두개의 테이블이 각각 유니크 칼럼으로 아우터 조인을 수행하는 쿼리에서 아우터 테이블에 일치하는 레코드가 존재하지 않을때
- using filesort: ORDER BY를 처리하기 위해 인덱스가 사용되지못한경우 MySQL 서버가 조회된 레코드를 다시 정렬하면서 Using filesort를 표시하고, 조회된 레코드를 메모리 버퍼에 복사해 퀵소트 또는 힙소트 알고리즘으로 정렬
- using index: 데이터 파일을 전혀 읽지 않고 인덱스만 읽어서 쿼리를 모두 처리 할 수 있을때(커버링 인덱스)
- using index condition: 인덱스 컨디션 푸시다운 최적화를 사용한 경우
- using index for group-by: GROUP BY를 처리하기 위해 MySQL 서버가 그루핑 기준 칼럼을 이용해 정렬 작업을 수행하고 다시 정렬된 결과를 그루핑 하는 고부하 작업이 필요하지만, GROUP-BY처리가 인덱스(B-Tree 인덱스에 한함)이용하면 별도의 추가 정렬 없이 정렬된 인덱스 칼럼을 순서대로 읽으면서 그루핑 작업만 수행. 이런 경우 Using index for group-by
    * 타이트 인덱스 스캔(인덱스 스캔)을 통한 GROUP BY: 인덱스를 이용해 GROUP BY를 처리한다 하더라도 AVG, SUM, COUNT처럼 조회하려는 값이 모든 인덱스를 다 읽어야 하는경우 GROUP BY를 위해 인덱스를 사용 하였지만 실행 계획에서는 Using index for group by 메시지가 출력 되지는 않음
    * 루스 인덱스 스캔을 이용한 GROUP BY 처리: 단일 칼럼으로 구성된 인덱스에서 그루핑 칼럼 말고는 아무것도 조회하지 않는 쿼리나, 다중 칼럼으로 만들어진 인덱스에서 GROUP BY가 인덱스를 사용하면서 MIN이나 MAX같이 조회하는 값이 인덱스의 첫번째 또는 마지막 레코드만 읽어도 되는 경우 루스 인덱스 스캔이 사용됨

- Using index for skip scan: MySQL 옵티마이저가 인덱스 스킵 스캔 최적화를 사용한 경우
- Using join buffer(Block Nested Loop), Using join buffer(Batched Key Access), Using join Buffer(hash join): 실행 계획에서 조인 버퍼가 사용되는 경우
- Using MRR: MySQL엔진에서 여러개의 키 값을 한번에 스토리지 엔진으로 전달하고 스토리지 엔진은 넘겨받은 키값들을 정렬해서 최소한의 페이지 접근만으로 필요한 레코드를 읽을수 있게 최적화 하는데, 이런 MRR 최적화를 사용한 경우
- Using sort_union, Using Union, Using intersect: 쿼리가 index_merge 접근 방법으로 실행되면서 2개 이상의 인덱스가 동시에 사용 되엇을때
    * Using intersect: 각각의 인덱스를 사용할수 있는 조건이 AND로 연결되어, 각 처리 결과에서 교집합을 추출해내는 작업을 수행함
    * Using Union: 각 인덱스를 사용할 수 있는 조건이 OR로 연결되어, 각 처리 결과에서 합집합을 추출해내는 작업을 수행함
    * Using sort_union: Using unoin과 같은 작업을 수행하지만 Using Unoin으로 처리될 수 없는경우(Or로 연결된 상대적으로 대량의 range 조건들), 프라이머리 키만 먼저 읽어서 정렬하고 병합한 후 레코드를 읽어서 반환

- using temporary: 임시 테이블을 사용한것. 임시 테이블이 메모리에 생성되었는지 디스크에 생성되었는지는 실행 계획만으로는 판단할수 없음, Using temporary가 표시 되지는 않지만 내부적으로 임시 테이블을 사용할때도 많음
- using where: MySQL 엔진 레이어서 별도의 가공을 해서 필터링 작업을 처리한 경우
- zero limit: MySQL서버에서 데이터 값이 아닌 쿼리 결괏값으 메타 데이터만 필요한 경우 Limit 0을 사용하는데, 이때 MySQL옵티마이저가 사용자의 의도를 알아채고 실제 테이블의 레코드는 전혀 읽지 않고 결괏값의 메타 정보만 반환할때
