---
layout: post
title: "기술면접 준비"
description: 기술면접 준비
date: 2020-08-11 20:41:00 +09:00
categories: Interview
---

1. 자바의 특징
    - OOP : 객체지향 언어, 부품에 해당하는 객체들을 먼저 만들고, 이것들을 하나씩 조립해 전체 프로그램을 완성
    - 가비지 컬렉션에 의한 자동 메모리 관리
    - 멀티 쓰레드 지원
    - JVM위에서 동작하기떄문에 OS에 종속적이지 않고, 이식성이 좋으며 보안성이 좋다
    - 제임스 고슬링 제작

2. 변수란?
    - 하나의 값을 저장할 수 있는 메모리 공간

3. 객체와 클래스의 차이
    - 클래스: 현실 세계의 객체 속성과 동작을 추려내 필드와 메서드로 정의한것. 아직 메모리에 할당되지 않은 상태
    - 객체: 클래스라는 설계도를 기반으로 실제 메모리상에서 동작하는것

4. 객체지향 프로그래밍과 그 특징
    - 프로그래밍에서 필요한 데이터를 추상화 시켜서 상태(속성, 어트리뷰트)와 행위(메서드)를 가진 객체 로 만들고, 그 객체간의 상호작용을 통해 로직을 구성하는 방법.
    - 장점
        * 다른 클래스를 가져와 사용할 수 있고, 상속받을 수 있어 코드의 재사용성 증가
        * 절차지향보다 유지보수가 간단
        * 클래스 단위로 모듈화가 가능하여, 대형 프로젝트에 적합
    
    - 단점
        * 처리속도가 상대적으로 느리다.
        * 객체가 많으면 용량이 커진다.
        * 설계시 많은 노력과 시간이 필요하다.
    
    - 클래스: 현실 세계의 객체를 추상화시켜, 속성과 메서드로 정의한 것 (논리적 개념) 
    - 인스턴스: 클래스에서 정의한 것을 토대로 만든 실제 메모리상에 할당된 것, 실제 데이터
    - 추상화: 객체지향 관점에서 클래스를 정의하는 것, 불필요한 정보 외 중요한 정보만 표현함으로써 공통의 속성과 기능을 묶어 이름을 붙이는 것.
    - 캡슐화: 코드를 수정없이 재활용 하는 것을 목적으로 함. 클래스라는 캡슐에 기능과 특성을 담아 묶는다. 목적을 기준으로 묶는다.
        * 은닉화와의 차이 - 은닉화는 캡슐화의 일부라고 볼 수 있으며, 목적으로 묶인 캡슐 안을 사용자는 볼 수 없다는 것이 은닉화.
    
    - 상속: 클래스로부터 속성과 메서드를 물려받는 것을 말함. 다른 클래스를 가져와서 수정할 일이 있다면, 그 클래스를 직접 수정하는 대신 상속을 받아 변경하고자 하는 부분만 변경
    - 다형성: 하나의 변수명이나 함수명이 상황에 따라 다르게 해석될 수 있음. 대표적인 다형성이 오버라이딩과 오버로딩
    - OOP의 5가지 법칙 (SOLID)
        * Single Responsibility Principle, 단일 책임 법칙: 각 클래스는 목적을 하나씩만 가지고 그에 대한 책임을 져야 한다.
        * Open Close Principle, 개방 폐쇄 법칙: 각 클래스는 클래스에 대한 수정을 폐쇄하고, 확장에 대해 개방해야 한다. 즉 클래스를 수정해야 한다면 그 클래스를 상속, 즉 확장하여 수정한다.
        * Liskov Substitusion Principle, 리스코프 치환 법칙: 자식 클래스를 사용 중일때, 거기에 부모 클래스로 치환하여도 문제가 없어야 한다.
        * Interface Segreation Principle, 인터페이스 분리 법칙: 각 행위에 대한 인터페이스는 서로 분리되어야 한다. 핸드폰을 예로 들면, 전화를 하는데 핸드폰 카메라가 방해가 되면 안된다는 말.
        * Dependency Inversion Principle, 의존성 역전 법칙: 상위 클래스가 하위 클래스에 의존하면 안된다는 법칙. 즉 기본적인 공통되는 속성을 하위 클래스에 의존하면 안된다.

5. 자바의 메모리 영역
    - 메서드 영역: static 변수, 전역변수, 코드에서 사용되는 Class정보들이 올라간다. 코드에서 사용되는 class들을 로더로 읽어, 클래스 별로 런타임 필드 데이터, 메서드 데이터를 분류해 저장한다
    - 스택: 지역변수, 메서드등이 할당되는 영역
    - 힙: new 연산자를 통해 동적 할당된 객체들이 저장되며, 가비지 컬렉션에 의해 관리

6. 추상메서드? 추상 클래스?
    - 추상메서드 : 메서드의 정의부만 있고 구현부는 있지 않은 메서드
    - 추상 클래스 : 추상메서드를 적어도 하나 이상 가지고 있는 클래스로 자식클래스에서 오버라이딩(재정의)가 필요한 추상메서드를 가지고 있기 때문에 객체화 할 수 없다.

7. 인터페이스(Interface)란? 또 왜 사용하나?
    - 인터페이스는 모든 메서드가 구현부가 없는 추상메서드로 이루어진 클래스로, abstract 키워드를 붙이지 않아도 자동으로 모든 메서드는 추상메서드로 정의가 된다. 또한 변수도 자동으로 final static 키워드가 붙게 된다.
    - 팀작업시 개발코드 부분과 객체가 서로 통신하는 접점 역할을 지원하게 되는데, 이는 개발코드에선 객체의 내부 구조를 모르더라도 인터페이스의 메서드 명만 알고 있으면 되기 때문이다
    - 이를 통해 얻을 수 있는 장점은 해당 메서드를 통해 나오는 결과물을 알고 있기 때문에 다른 팀의 작업을 기다리고 있지 않아도 되며, 또한 해당 객체가 수정될 경우 개발 코드 부분은 수정을 하지 않아도 된다.
    - 부가적으로 객체를 파일에 쓰기 위해 Serializable 인터페이스를 구현하거나, Collections.sort()를 하기 위해서 Comparable 인터페이스를  상속하는 것, Cloneable 을 구현하는 것처럼 특정 작업을 하겠다라는 "Mark"역할을 해주기도 한

8. 프로세스(Process) 와 쓰레드(Thread)의 차이점에 대해 아는가?
    - 프로세스 : OS가 메모리 등의 자원을 할당해준 실행중인 프로그램을 가리킨다. 이때, 각각의 프로세스는 서로 메모리 공간을 독자적으로 갖기 때문에 서로 메모리 공간을 공유하지 못한다. 따라서 공유하기 위해서는 IPC(InterProcess Communication)과 같은 방식이 필요하다.
    - 쓰레드 : 쓰레드는 프로세스 내에서 프로세스의 자원을 가지고 실제로 일하는 "일꾼"과 같으며 각 쓰레드는 독자적인 Stack 메모리를 갖고 그 외의 자원(메모리)는 프로세스 내에서 공유하게 된다.

9. 컬렉션프레임워크(CollectionFramework)에 대해 아는만큼 말해 보시오.
    - Collection 인터페이스    
    - List 인터페이스 : 배열과 유사하되, 추가할때마다 자동으로 Boundary를 늘려주는 구조로, 중복된 데이터를 허용하며, 순서가 존재한다.
        * ArrayList : 배열로 구현됬으며, 인접해 있기 때문에 데이터 조회에 매우 빠르다 하지만, 빈번한 삽입, 삭제시 새로 배열을 만들고 데이터를 옮겨야 하기 때문에 LinkedList에 비하여 속도가 느리다.
        * LinkedList : 링크 구조로 되어 있기 때문에 조회는 ArrayList에 비해 느리지만, 삽입 삭제시 링크를 끊고 새로 추가되는 데이터에 링크만 연결하면 되기 때문에 삽입, 삭제에 유리하다.
        * Vector : 구현 방식은 ArrayList와 유사하지만 Vector를 개선한 것이 ArrayList이다. 또한 Vector의 경우에는 ArrayList와 달리 Synchronized(동기화)가 걸려 있어 여러 쓰레드에서 동시에 접근할 수 없다.

    - Set 인터페이스 : 집합처럼 중복된 데이터를 허용하지 않으며, 순서가 없다. 또한, 객체 내부의 중복된 데이터를 배제하고 싶은 경우 Object 클래스의 equals 메서드와 hashCode 메서드의 재정의가 반드시 필요하다.
        * HashSet
        * TreeSet : 순서가 있는 HashSet으로 이진 트리 구조로 만들어 졌다. 순서에 맞게 정렬되어 저장되기 위해서 Comparable을 구현해야한다.

    - Map 인터페이스 : key와 value 쌍으로 데이터를 저장하며, key는 중복될 수 없고, value는 중복 저장이 가능하다.
        * HashMap
        * TreeMap
        * Properties : key value 쌍으로 저장되지만 value의 타입이 String만 가능하다.
        * Hashtable : HashMap과 구조는 같으며, 단지 Synchronized(동기화) 되어져 있다는 점이 다른점이다.

10. 캐시(Cache)와 세션(Session)의 공통점과 차이점은?
    - 공통점 : 둘 다 사용자의 데이터를 저장한다.
    - 캐시 : 캐시는 Client 컴퓨터에 저장했다 서버 요청시 네트워크를 타고 서버로 전달되기 때문에 보안에 취약하다.
    - 세션 : 세션은 서버에 저장되고 브라우저 단위로 관리된다. 캐시에 비해 보안성이 좋다.

11. Request 전송 방식에는 어떤 것들이 있는지 아시나요?
    - Get 방식 : URL의 쿼리문자열에 데이터를 같이 전달하는 방식으로 데이터 길이에 제한이 있고, 보안에 취약하다.
    - POST 방식 : 헤더에 데이터를 넣어 보내기 때문에 보안에 조금 더 유리하고 데이터 길이에 제한이 없다. 하지만, Get에 비해 다소 느리다.
    - DELETE 방식 : RESTFUL에서 삭제 기능을 할 때 주로 사용된다.
    - PUT/PUSH 방식 : RESTFUL에서 수정 작업을 할 때 주로 사용된다.

12. RESTFUL이란?
    - REST란 REpresental State Transfer의 약자, 자원을 표현하여 상태를 전달한다는 뜻으로, 웹에 있는 자원을 HTTP를 통하여 직관적으로 전달하기 위한 간단한 인터페이스이다
    - Restful API는 대부분의 데이터를 JSON형식이나 XML형식을 담아서 HTTP 프로토콜 위에서 통신하는 API 인 것이다.
    - Restful 하다는 것은 REST 법칙에 통과한 것을 말하는데, 그 법칙은 다음과 같다.
        * 자원
        * 메소드(Method: GET, POST, PUT, DELETE)만으로 표현
        * 동사말고 명사만
        * 확장자는 포함하지 않음

13. Spring에서 DI란 무엇인지 아시나요?
    - DI는 Dependency Injection(의존성 주입)의 약자로, 객체들 간의 의존성을 줄이기 위해 사용되는 Spring의 IOC 컨테이너의 구체적인 구현 방식입니다.
    - DI는 기존처럼 개발코드 부분에서 객체를 생성하는 것이 아니라, 팩토리 패턴처럼 객체의 생성과, 데이터를 주입만 담당하는 Factory에 해당 하는 별도의 공간에서 객체를 생성하고 데이터간의 의존성을 주입해 개발코드에서는 이를 가져다 씀으로서 의존성을 줄이는 방식입니다. 이때, Factory 패턴의 Factory Class의 역할을 스프링의 환경설정 파일이 담당합니다.

14. Spring의 AOP란?
    - AOP는 Aspect Oriented Programming 관점 지향 프로그래밍의 약자로, 기존의 OOP(객체 지향 프로그래밍)에서 기능별로 class를 분리했음에도 불구하 고, 여전히 로그, 트랜잭션, 자원해제, 성능테스트 메서드 처럼 공통적으로 반복되는 중복코드가 여전히 발생하는 단점을 해결하고자 나온 방식
    - 공통 코드를 "횡단 관심사"라 표현하며 개발코드에서는 비지니스 로직에 집중하고 실행시에 비지니스 로직 앞, 뒤 등 원하는 지점에 해당 공통 관심사를 수행할 수 있게 함으로서 중복 코드를 줄일 수 있는 방식입니다.

15. 디자인 패턴 아는 것?
    - 싱글톤(SingleTone Pattern) : 대표적으로 Calendar 객체나 dataSource 객체처럼 객체가 하나만 생성되어야 하는 경우 전체 코드에서 하나의 객체만 존재할 수 있도록 이미 생성된 객체가 있으면 그 객체를 사용하도록 하는 방식입니다.
    - 팩토리 패턴(Factory pattern) : 객체간 의존성을 줄이기 위해 객체의 생성과 데이터 주입만 담당하는 Factory Class를 정의하고 개발 코드 부분에서는 생성된 객체를 가져다 사용함으로서 의존성을 줄이는 방식입니다.
    - 옵저버 패턴(Observer Pattern) : 기후 정보처럼 RSS 수신시 하나의 객체가 변하면 다른 객체에 객체가 변했다는 사항을 알려주어야 할 경우에 주로사용됩니다.

16. MVC 패턴이란?
    - Model : data 처리와 접근을 담당(Java Bean)
        * Bean: 자바에서의 POJO(Plain Old Java Object)로, XML 설정파일을 통한 생명주기, 종속성 등의 메타데이터를 가지고 스프링 컨테이너에서 생성된 객체이다. 컨테이너에서 생성되었다는 점을 제외하면 일반 자바객체와 같다.
    
    - View : Client에 보여지는 화면을 담당(JSP or FE)
    - Controller : Model과 View를 제어(Java Class)
    - 3가지 부분으로 나눔으로서, 데이터와 화면간의 의존관계를 벗어날 수 있게하는 개발 기법입니다.

17. 오버로딩과 오버라이딩의 차이?
    - 오버로딩 : 메서드 명은 동일하지만, 매개 변수 타입과 개수를 다르게 해 선언하는 방식
    - 오버라이딩 : 상속한 자식에서 부모의 메서드를 재정의하는 방식

18. Servlet vs JSP
    - Servlet : 자바 언어로 웹 개발을 위해 만들어진 것으로, Container가 이해할 수 있게 구성된 순수 자바코드로만 이루어진 것 
    - JSP : html 기반에 JAVA 코드를 블록화하여 삽입한 것으로 Servlet을 좀 더 쉽게 접근할 수 있도록 만들어 진 것

19. Wrapper Class의 사용이유를 아나요?
    - 기본 data 타입은 객체가 아니어서 Object로 받는 다형성을 지원할 수가 없다. 하지만, 메서드에서 실재로 기본데이터 타입을 다형성으로 넘겨주어야 하는 경우가 빈번히 발생하는데 이때, 기본 데이터 타입을 객체로 변환시켜 전달하기 위해 사용되며 최근에는 AUTO Boxing, AUTO UnBoxing이 지원된다.

20. DataBase에서 Index란?
    - Table에 대한 동작 속도를 높여주는 자료구조로서 빠른 검색을 가능하게 해준다.

21. private, protected, public, default 제어자에 대해 설명해 보시오
    - private : 같은 class 내부에서"만" 접근이 가능하다.
    - public : 어디서든 자유롭게 접근이 가능하다.
    - protected : 같은 class 내부 + 상속받은 자식에서는 부모 class에 접근이 가능하다.
    - default(package) : 아무 것도 선언하지 않은 경우로 같은 패키지 내부에서만 접근이 가능하다.

22. SI가 무엇을 하는 건지 알고 오셨나요?
    - System Integration의 약자로 시스템 통합 사업으로 고객의 기존 전산시스템을 통합하거나 새로운 시스템을 구축하는 작업입니다.

23. SW 개발시 가장 비중을 크게 두어야 할 부분은 어디라고 생각하나요?
    - Testing 부분입니다. 

24. 자바의 제네릭이란??
    - 클래스 내부에서 사용할 데이터 타입을 인스턴스(객체) 생성시에 결정짓는 방식

25. CVS나 SVN에 대해서 아는대로 설명해 보시오.

26. 64bit CPU와 32bit CPU의 OS적 관점에서의 차이를 설명해 보시오.

27. 프로세스와 쓰레드의 차이점에 대해서 설명해 보시오.( 메모리 구조 포함 )

28. ‘데드락’ 이란 무엇이고 이를 해결하기 위한 방법을 설명해 보시오.

29. 변수 명명법이 중요한 이유에 대해서 설명하고 예를 들어 보시오.

30. 자바의 JVM의 역할에 대해서 설명해 보시오.

31. 자바의 특징에 대해서 말해 보시오.

32. Linux에서 톰캣 환경설정을 잡는 것에 대해 설명해 보시오.

33. WAS와 웹서버의 차이점은?

34. Jquery와 Ajax에 대해 아는가?

35. 비동기와 동기 방식의 차이점에 대해서 말해보시오.(네트워크 동기,비동기 아님)

36. 개발시에 중요하다 생각하는 요소를 3가지 기술해 보시오.

37. 스프링의 MVC에 대해서 설명하시오.

38. AOP란 무엇이고 왜 사용하는지

39. ‘에자일’ 방법론에 대해서 아는가?

40. 스프링 환경설정 혼자 잡을 수 있는가? 대강 어떻게 해야하는지 설명해 보시오.

41. 웹서버 내부 구동 방식에 대해 설명할 수 있는가?

42. 스프링 DI란?

43. UML 그려본 적 있는가?

44. Node js나 Angular JS를 사용해 본 적이 있는가?

45. 캐시와 세션의 공통점과 차이점에 대해 말해보시오.

46. 디자인 패턴 아는 것들만 간략히 설명해 보시오.

47. DataBase에서 index관련 질문이었는대 잘 모르겠어서..기억이..

48. 크롬이나 파이어폭스에서 개발도구를 사용해 디버깅을 해보았는가?

49. JDBC는 무엇인가?

50. 스프링을 사용하지 않고 MVC를 JSP에서 만들어 보았는가?

51. DB 옵티마이저에 대해 아는가?

52. 함수형 프로그래밍
    - 함수형 프로그래밍은 선언형 프로그래밍으로, 어떻게(How)가 아닌 무엇(What)을 정의한다. C, Java등의 언어는 명령형 프로그래밍이며, 알고리즘을 기술하고 목적은 기술하지 않는다. 선언형은 반대로 알고리즘은 기술하지 않고 목적 위주로 기술하며, 데이터의 입력이 주어지고 데이터의 흐름을 추상적을 정의하는 방식.

53. Stream
    - SteamAPI는 Java의 Collection에서의 연속된 데이터의 반복 연산을 for문 등을 쓰지 않고, 추상화된 메서드를 통해 무엇(What)을 할 것인지 정의. 즉 FP이다. 스트림을 생성하는 최초연산, 중간의 로직을 구성하는 중간연산, 결과물을 처리하는 최종연산으로 나뉜다. 중간연산의 리턴값은 스트림으로, 계속해서 메서드 체이닝을 해 나갈 수 있다. 최종연산의 리턴값은 스트림이 아니며, 최종연산이 수행되지 않는다면 중간연산 역시 수행되지 않는다.

54. 컨테이너란
    - 프레임워크 안에서 인스턴스들의 생명주기를 관리하며, 생성된 인스턴스들에게 추가적인 기능을 부여한다. 내가 작성한 코드의 처리과정을 컨테이너에서 수행한다. 스프링 컨테이너는 스프링 프레임워크 핵심에 위치하여, DI를 통해 애플리케이션을 구성하는 컴포넌트들을 관리한다.

55. IOC 란?
    - Inversion Of Control, 제어의 역행이라는 뜻으로, 인스턴스의 생성 및 소멸을 개발자 대신 스프링 컨테이너가 한다. 그외 제어권을 프레임워크에서 가져간다는 말로도 쓰인다.

56. DI 란?
    - Dependency Injection, 의존성 주입이라는 뜻으로, IOC를 실제로 구현하는 방법. 의존성이 있는 컴포넌트를 개발자가 코드로 명시하는 것이 아니라 Spring이 런타임에서 연결해 처리해준다. XML파일을 통해 설정한대로, Bean객체 생성시 의존성 주입을 수행한다.

57. VO 란?
    - Value Object의 줄임말로, 값을 갖고있는 객체이다. 비즈니스 값을 가져올 때 사용하며, 보통 값을 수정할 수 없는 것으로 한다. DTO와 혼용해서 쓰기도 한다.

58. DTO 란?
    - Data Transfer Object의 줄임말로, VO와 같이 값을 갖고 있는 객체이다. VO와의 차이점은 DB로 치자면 하나의 인스턴스로, 데이터 핸들링에 사용되는 객체이다. DTO를 통해 데이터를 전달할 수 있다.

59. DAO 란?
    - Data Access Object의 줄임말로, 실제 DB에 접속하는 객체이다. Service와 DB사이에서 가져온 데이터를 엔티티로 변환시켜 가져온다. 대부분의 CRUD API를 제공한다.

60. AJAX란?
    - Ajax란 좁은 의미로 클라이언트에서 서버가 비동기적으로 통신하는 기술
    - HTTP 요청 시 XMLHttpRequest라는 객체를 생성하여 수행한다.
    - request요청의 상태가 변할 때, readyState라는 플래그가 변하며, onreadystatechange라는 함수를 호출하게 된다.
    - readyState 상태 플래그
        * 0 : 객체 생성 완료, open()함수 호출 전
        * 1 : open()함수 호출 성공
        * 2 : send()함수 호출 성공
        * 3 : recv()함수 호출, 데이터 다운로드 중
        * 4 : Done, 모든 작업이 끝남

61. PCB
    - Process Control Block의 약자로, 프로세스 제어 블록이다. 프로세스에 대한 중요한 정보를 저장하고 있다. 운영체제가 프로세스를 표현한 것이라고도 한다. 프로세스 생성시 만들어지며, 주기억장치에 유지된다. 문맥전환 등 다른 프로세스를 처리해야 할 때, PCB에 현재 상태를 저장함으로써 나중에 그 작업 상태를 불러와 작업 재개가 가능해진다. PID, 상태, 다음 명령어 주소 등의 정보가 저장됨.

62. PC
    - Program Counter의 줄임말로, 다음에 실행될 명령어의 주소가 들어있는 레지스터이다. 명령어가 인출되면, 자동으로 다음 명령어를 가리키도록 주소값이 증가된다.

63. 캐시메모리
    - CPU의 레지스터와 메모리 사이에서, 캐싱을 통해 병목 현상을 완화하는 것을 말한다.

64. 멀티 스레드 VS 멀티 프로세스
    - 이 두 가지는 실행 단위를 구분한다는 점은 같지만, 멀티 스레드는 자원을 덜 소모하는 대신 하나의 스레드가 비정상적인 오류를 일으키면 다른 스레드도 종료될 수가 있다는 점과 동기화 문제를 안고 있다. 멀티 프로세스는 자원을 공유하지 않기에 서로간 통신이 멀티 스레드보다 불편하고, CPU 자원을 더 많이 소모한다. 결국 상황에 맞게 골라서 써야한다.

65. CPU 스케줄링 방법
    - 스케줄링 대상은 Ready Queue에 있는 프로세스 대상이다.
    - FCFS (First Come First Served) : 먼저 온 녀석이 먼저 스케줄링을 받음. 중간에 반환하지 않는 비선점형이며, 시간이 긴 프로세스가 먼저 오면 효율성이 떨어짐
    - SJF (Short Job First) : 늦게 오더라도 수행시간이 짧은 프로세스에 먼저 할당. 이렇게 되면 수행시간이 긴 프로세스는 영원히 할당받지 못할 수도 있음(Starvation). 수행시간(CPU Burst Time)은 알지는 못하고 예측만가능
    - SRT (Short Remaining Time) : 현재 프로세스의 수행시간이 끝나는 시간보다 나중에 오는 프로세스의 수행시간 완료 시간이 더 짧다면, 그 즉시 그 프로세스에게 CPU를 할당. 선점형 스케줄링. Starvation과 CPU 수행 시간을 측정할 수 없다는 문제가 있음
    - 우선순위 : 정수로 표현된 우선순위가 더 높은 프로세스에게 할당한다. 선점형 방식과 비선점형 방식으로 나눌 수 있는데, 선점형 방식은 우선순위가 높은 프로세스가 도달하면 그 즉시 그 프로세스에게 CPU를 할당. 비선점형 방식은 Ready Queue의 맨 앞에 그 프로세스를 등록. Starvation과 CPU를 사용못하는 프로세스를 CPU가 무한 대기하는 상태가 있을 수 있음. 오래 기다렸을 경우 우선순위를 높이는 Aging을 통해 해결 가능.
    - Round Robin : 현대적인 CPU 스케줄링으로, 각 프로세스는 동일한 CPU 할당 시간을 갖게 됨. 할당시간 만료시 ready queue 맨 뒤에 가서 줄섬. CPU의 사용시간이 제각각일 때 효율적. 반응 속도가 빨라지며, 공정한 스케줄링. 주의할 점은 할당하는 시간(time quantum)이 너무 길다면 FCFS와 다를게 없음. 너무 작다면 잦은 컨텍스트 스위칭이 발생.

66. 단편화
    - 단편화란 메모리 상에서 적재되고, 해제되는 과정에서 발생하는 메모리 사이의 사용하지 못할 정도로 작은 빈 공간이다. 크게 외부 단편화와 내부 단편화로 나뉜다. 외부 단편화는 프로세스와 프로세스 사이에 발생하는 빈 공간이고, 내부 단편화는 프로세스 안에서 발생하는 빈 공간이다. 외부 단편화는 메모리를 다시 재정렬하는 압축을 통해 해결할 수 있지만, 효율이 좋지 않다.
    - First Fit : 메모리를 할당할 때, 가장 먼저 발견한 곳에 집어넣음
    - Best Fit : 메모리를 할당할 때, 사용 가능한 공간 중 가장 작은 곳에 집어넣음(정렬 필요)
    - Worst Fit : 메모리를 할당할 때, 사용 가능한 공간 중 가장 큰 곳에 집어넣음(정렬 필요)
    - 공간 효율성 : Best Fit > First Fit > Worst Fit
    - 시간 효율성 : First Fit > Best Fit = Worst Fit

67. 가상 메모리
    - 가상 메모리는 기존의 물리 메모리를 물리 메모리와 논리 메모리로 나눔으로써 더욱 효과적으로 쓰기 위한 개념이다. 논리 메모리 테이블은 물리 메모리와 보조기억장치 메모리와 매핑되어 있으며, 프로세스는 가상메모리를 물리 메모리처럼 인식하고 사용하게 된다. 이전에는 가상 메모리는 보조기억장치를 주기억장치처럼 쓰게 하는 것으로 알고 있었는데, 이번에 다시 정리하게 되었다.

68. 페이징
    - 외부 단편화의 압축 작업을 해소하기 위한 방법론으로, 물리 메모리는 Frame, 논리 메모리는 Page라는 고정 크기의 블록으로 나눈다. 프로세스를 페이지 단위로 나눈 뒤에, 사용하지 않는 영역을 보조기억장치에 적재한다. 이를 페이징 되었다고 하는데, 만약 이 페이징 된 영역에 접근해야 하면 페이징 폴트를 발생시킨 후 메모리에 적재시킨다(요구 페이징). 페이징된 정보는 페이징테이블에 저장된다. 단점으로는 내부 단편화가 발생할 수 있다.

69. 세그멘테이션
    - 메모리를 페이지와는 다르게 가변 크기의 세그멘테이션으로 나눈다(물리 메모리 블럭 크기와 다르다). 나누는 시점은 메모리를 사용하게 되는 시점이다. 각 세그멘테이션은 스택, 데이터, 힙, 코드 영역 등으로 나뉘게 된다. 나뉜 세그멘테이션은 시작 주소값과 길이 값이 세그멘테이션 테이블에 저장된다. 자주 사용하면 외부 단편화가 발생할 수 있다.
    - 보통 페이징과 세그멘테이션 둘다 함

70. 페이지 교체 알고리즘 종류
    - FIFO (First In First Out) : 말 그대로 먼저 들어온 페이지를 먼저 내보낸다. 간단한 알고리즘이지만, 페이지의 중요도를 따지지 않기 때문에 초기 변수가 담긴 페이지를 내려버리는 등 여러 문제를 초래할 수 있다.
    - 최적 페이지 교체 (Optimal Page Replacement) : 앞으로 가장 사용되지 않을 페이지를 계산하여 교체한다. 다만 모든 프로세스의 계획을 파악하기가 쉽지 않기 때문에, 어떤 페이지를 교체해야 하는가의 알고리즘을 구현할 때 어려움이 있다.
    - LRU (Last Recently Used) : 가장 나중에 사용된 페이지를 교체한다. FIFO보단 낫고 OPT보단 못하다.
    - LFU (Least Frequently Used) : 가장 덜 사용된 페이지를 교체한다. 활발한 페이지는 사용이 많이 되었을거라는 가정하에 만든 알고리즘. 초기에 많이 사용되었다가 지금은 사용되지 않는 페이지의 경우 교체가 이루어지지 않는다는 문제가 있다.
    - MFU (Most Frequently Used) : 가장 많이 사용된 페이지를 교체한다. 가장 적게 사용된 페이지가 최근에 올라오고 계속 사용될 것이라는 가정. 잘 쓰이지 않는다.

71. HTTP 요청 흐름 (웹브라우저에서의 요청)
    - 브라우저에서 먼저 URL에 적힌 값을 파싱하여, HTTP 요청 메세지를 만든다. 만든 메세지를 웹 서버로 전송하는데, 이때 웹 브라우저 직접 전송을 하는것이 아니라 OS에 보내주십쇼~ 하고 의뢰를 하게 된다. OS는 DNS서버를 조회해서 Host이름을 보내야 할 IP 주소로 변환하게 된다.
    - 프로토콜 스택(운영체제에 내장된 네트워크 제어용 소프트웨어, TCP/IP 계층)과 LAN 어댑터 에서 브라우저로부터 메시지를 받는다. 브라우저로부터 받은 메시지를 패킷 속에 저장한다. 그리고 수신 주소를 제어정보에 덧붙인다. 그 다음, 패킷은 LAN 어댑터에 넘긴다. LAN 어댑터는 패킷을 전기 신호로 변환시켜 LAN 케이블에 송출하게 된다.
    - 허브, 스위치, 라우터 에서 LAN 어댑터로부터 송신한 패킷을 수신한다. 라우터는 패킷을 ISP에 전달, 인터넷으로 들어가게 된다.
    - 액세스 회선, ISP : 액세스 회선이라는 것은 인터넷의 입구에 있는 통신 회선이다. 액세스 회선에 의해 통신사용 라우터(POP, Point Of Presence)까지 운반된다. POP를 거쳐 인터넷의 핵심부로 들어가게 된다. 고속 라우터들 사이로 목적지까지 패킷이 흘러가게 된다.
    - 방화벽, 캐시서버 : 인터넷 핵심부를 통과한 패킷은 목적지의 LAN에 도착하게 된다. 방화벽이 먼저 패킷을 검사한 후, 캐시서버로 보내서 웹 서버까지 갈 필요가 있는지 검사한다.
    - 웹 서버 : 패킷이 물리적 웹 서버에 도착하면, 웹 서버의 프로토콜 스택이 패킷을 추출하여 메시지를 복원하고, 웹 서버 애플리케이션에 넘긴다. 애플리케이션은 요청에 대한 응답 데이터를 넣어 클라이언트로 회송한다. 온 방식 그대로 전송되게 된다.

72. HTTP/HTTPS 차이
    - HTTP + SSL = HTTPS
    - HTTP는 평문 통신이다. TCP/IP 특성상 도청이 가능하며, 통신 상대를 확인하지 않기 때문에 위장이 가능하다. 가령 나는 IP가 A인 사람한테 보내고 싶은데, 악의적인 해커가 내가 IP A요 하고 말해도 검증할 방법이 없다는 것. 또한 완전성을 증명할 수 없기 때문에 변조가 가능하다. 보안 방법은 통신 자체를 암호화(SSL, TLS)하거나, 콘텐츠를 자체를(HTTP 메시지 컨텐츠를) 암호화 하는 것이다. 도청이 가능한 문제, 사용자를 확인할 수 없다는 문제, 정확성을 보장할 수 없다는 문제를 모두 해결할 방안으로 나온 것이 HTTPS이다.
    - HTTPS는 새로운 프로토콜이 아닌, HTTP에서 SSL 개념을 더한 프로토콜이다. 기존 HTTP는 TCP와 직접 통신했지만, HTTPS는 HTTP와 TCP 사이에 SSL, TLS가 끼워져 있는 것이다. HTTP는 SSL과 통신하고, SSL은 TCP와 통신하게 된다.
    - SSL의 원리를 간략하게 설명하면, 대칭키와 공개키 방식 두 암호화 방식을 사용하는데, 먼저 클라이언트가 서버에게 HELLO 메세지를 보내면, 서버가 클라이언트에게 HELLO 메세지를 보내면서, 서버 암호화 된 인증서와 랜덤 데이터를 넘겨주게 된다. HELLO 과정에서 어떤 암호화 프로토콜을 사용할 것인지 협상한다. 클라이언트는 받은 인증서를 CA리스트에서 조회 후 CA 공개키를 사용하여 인증서를 복호화한다. 복호화에 성공 했다면 이 서버는 신뢰할 수 있는 서버이다. 서버가 보낸 랜덤 데이터와 클라이언트의 랜덤 데이터를 조합해서 대칭키를 생성한다. 서버로부터 받은 공개키(인증서)를 사용하여 대칭키를 암호화 후에, 서버에게 보내게 된다. 서버는 암호화된 대칭키를 받고, 비밀키로 복호화 함으로써, 서버와 클라이언트가 서로 대칭키를 가지게 된다. 이 대칭키로 통신을 암호화한다.

73. TCP/UDP 등 로우레벨 통신 지식
    - TCP 3-way hand shake, 4-way hand shake
    - TCP는 흐름제어, 오류제어를 통한 연결 지향성, 순서 중요함, 오류시 재전송. 전이중과 점대점(각 연결이 정확히 2개의 종단점을 가지고 있음) 방식.
    - UDP는 비연결형 프로토콜, 상대방이 받든지 말든지 그냥 보낸다. 손상된 세그먼트에 대해 재전송하지 않는다. 만약 클라이언트 timeout이 발생하면 다시 보내면 그만이다.

74. CORS란?
    - Cross Origin Resource Sharing 약자. 말 그대로 다른 도메인간의 자원 공유를 의미한다. 본래 대부분의 브라우저는 타 도메인 간 요청을 Same-Origin-Policy에 의해 차단한다. 이런 설정을 우회하기 위해 여러 방법이 있었지만, HTML5가 등장하면서 CORS가 등장했다. CORS는 헤더를 통하여 Cross-Domain간 사용가능한 자원을 헤더를 통하여 알려준다.

