---
layout: post
title: "기술면접 준비"
description: 기술면접 준비
date: 2020-08-11 20:41:00 +09:00
categories: Interview
---

# 자기소개
안녕하세요 현재 삼성전자 삼성리서치 사업부 SE팀에 재직중인 유원영입니다.

저는 삼성리서치에서 약 3년동안 Backend 개발자로 일하고 있는데, 재직기간 동안 In-house 서비스인 개발 데이터 가시화 Dashboard의 Backend 서버 개발하고있습니다. 해당 서비스는 개발 과정에서 모이는 git log, jira issue, static analysis 결과 등 여러 데이터를 모아, 이를 가시화 해서 보여주는 서비스로, 개발 초기 당시에는 삼성리서치 사업부 대상으로만 제공되었지만 현재는 해외연구소를 포함한 삼성전자 전체 사업부를 대상으로 서비스 하고 있습니다. 

제가 이직을 결심한 이유는, 제대로 된 서비스를 해보고 싶어서 입니다. 기존에 제가하던 업무인 개발 데이터 가시화 Dashboard는 In-House 서비스여서, 실제 B2C 혹은 B2B 서비스와는 많은 괴리가 있었습니다. 요구사항의 타당성 검증도 제대로 이뤄지지 않고, 그 마저도 관리가 제대로 이뤄지지 않아 시시각각으로 변하는 요구사항에 대응하느라 서비스를 개발하는데 많은 어려움이 있었는데, 그러던 중 이러한 문제의 대부분은 In-House 서비스여서 이해관계자들이 너무 많아 발생하는 문제임을 깨닳았습니다. 그때부터 저는 정말 제대로 된 서비스를 한번 해보고 싶다라는 생각이 들게 되었고, 이직을 준비하게 되었습니다

저는 Backend개발을 하였기 때문에 Spring framerowk에 대한 전반적인 이해 뿐만 아니라, Mysql/PostgreSQL 등 다양한 DB를 직접 다뤘었고, 직접 서비스를 Dockerize하여 CircleCI 및 Artifatcory 와 연동하여 PR생성시 자동 Test 및 Docker image까지 발행 하도록 하였고, 나아가 현재는 Ansible을 통해서 서비스 프로비저닝까지 해보고 있습니다. 이처럼 저의 다양한 경험과 배경지식을 살려 진짜 서비스를 한번 해보고싶습니다. 이상입니다.


# Java

1. 자바의 특징
    - 객체지향 언어
    - 가비지 컬렉션에 의한 자동 메모리 관리
    - 멀티 쓰레드 지원
    - JVM위에서 동작하기떄문에 OS에 종속적이지 않고, 이식성이 좋으며 보안성이 좋다
    - 제임스 고슬링 제작

2. 변수란?
    - 하나의 값을 저장할 수 있는 메모리 공간

3. 객체와 클래스의 차이
    - 클래스: 현실 세계의 객체 속성과 동작을 추려내 필드와 메서드로 정의한것. 아직 메모리에 할당되지 않은 상태
    - 객체: 클래스라는 설계도를 기반으로 실제 메모리상에서 동작하는것

4. 객체지향 프로그래밍과 그 특징
    - 프로그래밍에서 필요한 데이터를 추상화 시켜서 상태(속성, 어트리뷰트)와 행위(메서드)를 가진 객체 로 만들고, 그 객체간의 상호작용을 통해 로직을 구성하는 방법.
    - 장점
        * 다른 클래스를 가져와 사용할 수 있고, 상속받을 수 있어 코드의 재사용성 증가
        * 절차지향보다 유지보수가 간단
        * 클래스 단위로 모듈화가 가능하여, 대형 프로젝트에 적합
    
    - 단점
        * 처리속도가 상대적으로 느리다.
        * 객체가 많으면 용량이 커진다.
        * 설계시 많은 노력과 시간이 필요하다.
    
    - 클래스: 현실 세계의 객체를 추상화시켜, 속성과 메서드로 정의한 것 (논리적 개념) 
    - 인스턴스: 클래스에서 정의한 것을 토대로 만든 실제 메모리상에 할당된 것, 실제 데이터
    - 추상화: 객체지향 관점에서 클래스를 정의하는 것, 불필요한 정보 외 중요한 정보만 표현함으로써 공통의 속성과 기능을 묶어 이름을 붙이는 것.
    - 캡슐화: 코드를 수정없이 재활용 하는 것을 목적으로 함. 클래스라는 캡슐에 기능과 특성을 담아 묶는다. 목적을 기준으로 묶는다.
        * 은닉화와의 차이 - 은닉화는 캡슐화의 일부라고 볼 수 있으며, 목적으로 묶인 캡슐 안을 사용자는 볼 수 없다는 것이 은닉화.
    
    - 상속: 클래스로부터 속성과 메서드를 물려받는 것을 말함. 다른 클래스를 가져와서 수정할 일이 있다면, 그 클래스를 직접 수정하는 대신 상속을 받아 변경하고자 하는 부분만 변경
    - 다형성: 하나의 변수명이나 함수명이 상황에 따라 다르게 해석될 수 있음. 대표적인 다형성이 오버라이딩과 오버로딩
    - OOP의 5가지 법칙 (SOLID)
        * Single Responsibility Principle, 단일 책임 법칙: 각 클래스는 목적을 하나씩만 가지고 그에 대한 책임을 져야 한다.
        * Open Close Principle, 개방 폐쇄 법칙: 각 클래스는 클래스에 대한 수정을 폐쇄하고, 확장에 대해 개방해야 한다. 즉 클래스를 수정해야 한다면 그 클래스를 상속, 즉 확장하여 수정한다.
        * Liskov Substitusion Principle, 리스코프 치환 법칙: 자식 클래스를 사용 중일때, 거기에 부모 클래스로 치환하여도 문제가 없어야 한다.
        * Interface Segreation Principle, 인터페이스 분리 법칙: 각 행위에 대한 인터페이스는 서로 분리되어야 한다. 핸드폰을 예로 들면, 전화를 하는데 핸드폰 카메라가 방해가 되면 안된다는 말.
        * Dependency Inversion Principle, 의존성 역전 법칙: 상위 클래스가 하위 클래스에 의존하면 안된다는 법칙. 즉 기본적인 공통되는 속성을 하위 클래스에 의존하면 안된다.

5. 추상메서드? 추상 클래스?
    - 추상메서드 : 메서드의 정의부만 있고 구현부는 있지 않은 메서드
    - 추상 클래스 : 추상메서드를 적어도 하나 이상 가지고 있는 클래스로 자식클래스에서 오버라이딩(재정의)가 필요한 추상메서드를 가지고 있기 때문에 객체화 할 수 없다.

6. 인터페이스(Interface)란? 또 왜 사용하나?
    - 인터페이스는 모든 메서드가 구현부가 없는 추상메서드로 이루어진 클래스로, abstract 키워드를 붙이지 않아도 자동으로 모든 메서드는 추상메서드로 정의가 된다. 또한 변수도 자동으로 final static 키워드가 붙게 된다.
    - 팀작업시 개발코드 부분과 객체가 서로 통신하는 접점 역할을 지원하게 되는데, 이는 개발코드에선 객체의 내부 구조를 모르더라도 인터페이스의 메서드 명만 알고 있으면 되기 때문이다
    - 이를 통해 얻을 수 있는 장점은 해당 메서드를 통해 나오는 결과물을 알고 있기 때문에 다른 팀의 작업을 기다리고 있지 않아도 되며, 또한 해당 객체가 수정될 경우 개발 코드 부분은 수정을 하지 않아도 된다.
    - 부가적으로 객체를 파일에 쓰기 위해 Serializable 인터페이스를 구현하거나, Collections.sort()를 하기 위해서 Comparable 인터페이스를  상속하는 것, Cloneable 을 구현하는 것처럼 특정 작업을 하겠다라는 "Mark"역할을 해주기도 한다

7. Wrapper Class의 사용이유를 아나요?
    - 기본 data 타입은 객체가 아니어서 Object로 받는 다형성을 지원할 수가 없다. 하지만, 메서드에서 실재로 기본데이터 타입을 다형성으로 넘겨주어야 하는 경우가 빈번히 발생하는데 이때, 기본 데이터 타입을 객체로 변환시켜 전달하기 위해 사용되며 최근에는 AUTO Boxing, AUTO UnBoxing이 지원된다.

8. 컬렉션프레임워크(CollectionFramework)에 대해 아는만큼 말해 보시오.
    - Collection 인터페이스    
    - List 인터페이스 : 배열과 유사하되, 추가할때마다 자동으로 Boundary를 늘려주는 구조로, 중복된 데이터를 허용하며, 순서가 존재한다.
        * ArrayList : 배열로 구현됬으며, 인접해 있기 때문에 데이터 조회에 매우 빠르다 하지만, 빈번한 삽입, 삭제시 새로 배열을 만들고 데이터를 옮겨야 하기 때문에 LinkedList에 비하여 속도가 느리다.
        * LinkedList : 링크 구조로 되어 있기 때문에 조회는 ArrayList에 비해 느리지만, 삽입 삭제시 링크를 끊고 새로 추가되는 데이터에 링크만 연결하면 되기 때문에 삽입, 삭제에 유리하다.
        * Vector : 구현 방식은 ArrayList와 유사하지만 Vector를 개선한 것이 ArrayList이다. 또한 Vector의 경우에는 ArrayList와 달리 Synchronized(동기화)가 걸려 있어 여러 쓰레드에서 동시에 접근할 수 없다.

    - Set 인터페이스 : 집합처럼 중복된 데이터를 허용하지 않으며, 순서가 없다. 또한, 객체 내부의 중복된 데이터를 배제하고 싶은 경우 Object 클래스의 equals 메서드와 hashCode 메서드의 재정의가 반드시 필요하다.
        * HashSet
        * TreeSet : 순서가 있는 HashSet으로 이진 트리 구조로 만들어 졌다. 순서에 맞게 정렬되어 저장되기 위해서 Comparable을 구현해야한다.

    - Map 인터페이스 : key와 value 쌍으로 데이터를 저장하며, key는 중복될 수 없고, value는 중복 저장이 가능하다.
        * HashMap
        * TreeMap
        * Properties : key value 쌍으로 저장되지만 value의 타입이 String만 가능하다.
        * Hashtable : HashMap과 구조는 같으며, 단지 Synchronized(동기화) 되어져 있다는 점이 다른점이다.

9. 오버로딩과 오버라이딩의 차이?
    - 오버로딩 : 메서드 명은 동일하지만, 매개 변수 타입과 개수를 다르게 해 선언하는 방식
    - 오버라이딩 : 상속한 자식에서 부모의 메서드를 재정의하는 방식

10. private, protected, public, default 제어자에 대해 설명해 보시오
    - private : 같은 class 내부에서"만" 접근이 가능하다.
    - public : 어디서든 자유롭게 접근이 가능하다.
    - protected : 같은 class 내부 + 상속받은 자식에서는 부모 class에 접근이 가능하다.
    - default(package) : 아무 것도 선언하지 않은 경우로 같은 패키지 내부에서만 접근이 가능하다.

11. 자바의 제네릭이란??
    - 클래스 내부에서 사용할 데이터 타입을 인스턴스(객체) 생성시에 결정짓는 방식

12. 자바의 JVM의 역할에 대해서 설명해 보시오(메모리 종류 포함)
    - Java Virtual Machine
    - JAVA와 OS 사이에서 중계자 역할
    - JAVA가 OS에 구애받지 않고 재사용을 가능하게 해 줌
    - Runtime Data Area 속의 클래스, 힙, 스택, Native 메서드, PC레지스터로 구성
        * 클래스 영역: Method영역, Code 영역, Static영역 등으로 불림
            + Field Information: 멤버변수의 이름, 데이터 타입, 접근제어자에 대한 정보
            + Method Information: 메서드의 이름, 리턴타입, 매개변수, 접근제어자에 대한 정보
            + Type Information: 타입의 속성이 Class인지 Interface인지 여부 저장, Type의 전체 이름(패키지먕 + 클래스명), Type의 Super class의 전체이름, 접근제어자 및 연관된 interface의 정보
            + 상수풀: Type에서 사용된 상수들이 저장. 문자상수, 타입, 필드, Metho의 symbolic reference도 상수에 저장
            + class variable: static 변수, 모든 객체가 공유, 객체 생성 없이 접근 가능
            + Class 사용 이전에 메모리 할당: final class변수의 경우 상수로 치환되어 상수풀에 저장
        
        * 스택: 메서드 호출시마다 각각의 스택 프레임(메서드만을 위한 공간)이 생성, 메서드 안에서 사용되어지는 값들을 저장, 호출된 메서드의 메개변수, 지역변수, 리턴값, 연산시 일어나는 값들을 임시 저장
        * 힙: new 연산자로 생성된 객체와 배열을 저장하는 공간, 클래스 영역에 로드된 클래스만 생성가능, GC에 의해 관리되는 영역
            + Permanent Generation: 생성된 객체들의 주소값이 저장되는 공간
            + New Area: Eden(객체들이 최초로 생성되는 공간), Suvivor(Eden에서 참조되는 갹체들이 저장되는 공간)
            + Old Area: New Area에서 일정 시간 이상 참조되는 객체들이 저장되는 공간

        * Native 메서드: 자바외의 다른 언어에서 제공되는 메서드들이 저장되는 공간
        * PC레지스더: Thread들이 생성될때마다 생성되는 공간, Thread가 어떤 부분을 어떤 명령으로 실행할지에 대한 기록, 현재 실행되는 부분의 명령과 주소를 저장

13. JDBC는 무엇인가?
    - 자바를 이용한 데이터베이스 접속과 SQL 문장의 실행, 그리고 실행 결과로 얻어진 데이터의 핸들링을 제공하는 방법과 절차에 관한 규약
    - 자바 프로그램 내에서 SQL 문을 실행하기 위한 자바 API
    - SQL과 프로그래밍 언어의 통합 접근 중 한 형태
    - JAVA는 표준 인터페이스인 JDBC API를 제공
    - 데이터베이스 벤더, 또는 기타 써드파티에서는 JDBC 인터페이스를 구현한 드라이버(driver)를 제공한다.

14. Stream
    - SteamAPI는 Java의 Collection에서의 연속된 데이터의 반복 연산을 for문 등을 쓰지 않고, 추상화된 메서드를 통해 무엇(What)을 할 것인지 정의. 즉 FP이다. 스트림을 생성하는 최초연산, 중간의 로직을 구성하는 중간연산, 결과물을 처리하는 최종연산으로 나뉜다. 중간연산의 리턴값은 스트림으로, 계속해서 메서드 체이닝을 해 나갈 수 있다. 최종연산의 리턴값은 스트림이 아니며, 최종연산이 수행되지 않는다면 중간연산 역시 수행되지 않는다.

15. synchronized, volodate, atomic class 차이
    - 셋 모두 thread safe(어떤 함수나 변수, 객체가 여러 스레드에 의해 동시에 접근이 이뤄져도 프로그램의 실행에 문제가 없음)를 만들기 위해 사용
    - volatile는 CPU의 캐시 메모리에 저장하지 않고 반드시 메인 메모리에 저장하기 때문에 변수의 가시성 문제를 해결. 하지만 항상 동시성 문제를 해결하는 것이 아니고, 하나의 스레드만 write를 하고 나머지의 스레드들은 read하는 상황에서만 최신의 값을 보장
    - Atomic 클래스의 경우는 여러 스레드에서 읽기 쓰기 모두 이용할 수 있다. (CAS)
        * CAS(compare-and-swap): CAS방식은 자신이 읽었던 변수의 값을 기억하고 있다가 변경을 완료하기 직전에 읽었던 변수의 값이 그대로인지 확인하고 아니라면 실행을 무산시키는 방식
    - synchronized 경우도 여러 스레드에서 읽기 쓰기 모두 이용할 수 있다. (Lock)

16. string, string buffer, string builder 차이
    - string: immutable, 불변, 한번 생성되면 할당된 메모리 공간이 변하지않음. + 또는 concat메서드를 통해 기존에 생성된 string을 참조하는게 아니라 새로운 문자열을 만든후 그 객체를 참조하도록 함. Thread safe
    - stringbuffer: 각 메서드별로 synchronized, 멀티스레드 환경에서의 동기화 지원
    - stringbuilder: 동기화 미지원

17. string 은 메모리의 어느 영역에?
    - new 를 통해 만들어지면 heap영역, 리터럴을 사용해 만들어지면 Permanent Generation의 string constant pool에 존재 ( ~ 1.6 )
    - 이젠 똑같이 heap 영역

18. map, flatMap차이(stream)
    - map: 단일 스트림안의 요소르 원하는 특정 형태로 변환
    - flatMap: 스트림의 형태가 배열과 같을떄, 모든 원소를 단일 원소 스트림으로 반환 가능

19. Exception, Error 차이
    - Error : 컴파일 시 문법적인 오류와 런타임 시 널포인트 참조와 같은 오류로 프로세스에 심각한 문제를 야기 시켜 프로세스를 종료 시킬 수 있다
    - Exception : 컴퓨터 시스템의 동작 도중 예기치 않았던 이상 상태가 발생하여 수행 중인 프로그램이 영향을 받는 것. 예를 들면, 연산 도중 넘침에 의해 발생한 끼어들기 등이 이에 해당한다
        + Checked Exception: Exception의 하위클래스들, 반드시 예외 처리를 해야함, 트랜잭션 롤백 안됨, IOException, SQLException
        + Unchecked Exception: Exception의 하위인 Runtime Exception의 하위 클래스들, 예외 처리 안해도됨, 트랜잭션 롤백, NPE, IllegalArgumentException
    
    - 프로그램이 실행 중 어떤 원인에 의해서 오작동을 하거나 비정상적으로 종료되는 경우를 프로그램 오류라 하고, 프로그램오류에는 에러(error)와 예외(exception) 두 가지로 구분할 수 있다.
    - 에러는 메모리 부족이나 스택오버플로우와 같이 발생하면 복구할 수 없는 심각한 오류이고, 예외는 발생하더라도 수습할 수 있는 비교적 덜 심각한 오류이다. 이 예외는 프로그래머가 적절히 코드를 작성해주면 비정상적인 종류를 막을 수 있다.

20. Java lambda문법, Single Abstract Method
    - ```( 매개변수 ) -> { 실행문 }``` 
    - SAM: 1개의 추상메서드를 가지고있는 인터페이스, 함수형 인터페이스라고도 함. 자바의 람다식은 함수형 인터페이스로만 접근, 람다식으로 만든 객체에 접근하기 위해 사용, Runnable, Supplier, Consumer등이 이에 해당
    
    ```java
    public interface FunctionalInterface {
        public abstract void doSomething(String text);
    }

    FunctionalInterface func = text -> System.out.println(text);
    func.doSomething("do something");
    ```

21. JVM, JRE, JDK
    - JVM: 자바 가상머신, 컴파일된 바이트코드 실행, 운영체제와 독립적으로 동작하기 위해 필요
    - JRE: 자바 구동 환경, JVM + 시스템라이브러리
    - JDK: 자바 개발 키트, JRE + 컴파일러, 디버거 등의 개발도구

22. JPA, Hibernate, Spring Data JPA
    - JPA: Java Persistence API, 자바 어플리케이션에서 관계형 데이터베이스를 사용하는 방식을 정의한 인터페이스, 인터페이스일뿐 라이브러리가 아님
    - Hibernate: JPA의 구현체, 단순 JPA의 구현체이기 때문에, JPA를 사용한다고 해서 반드시 Hibernate를 사용할 필요는 없음
    - Spring Data JPA: JPA를 쓰기 편하게 만들어둔 모듈(ex> EntityManager 사용 대신에 Repository 사용), JPA를 추상화 한 것



# Computer Sience

1. 프로세스(Process) 와 쓰레드(Thread)의 차이점에 대해 아는가?
    - 프로세스 : OS가 메모리 등의 자원을 할당해준 실행중인 프로그램을 가리킨다. 이때, 각각의 프로세스는 서로 메모리 공간을 독자적으로 갖기 때문에 서로 메모리 공간을 공유하지 못한다. 따라서 공유하기 위해서는 IPC(InterProcess Communication)과 같은 방식이 필요하다.
    - 프로세스의 동기화 방법: 세마포어
    - 쓰레드 : 쓰레드는 프로세스 내에서 프로세스의 자원을 가지고 실제로 일하는 "일꾼"과 같으며 각 쓰레드는 독자적인 Stack 메모리를 갖고 그 외의 자원(메모리)는 프로세스 내에서 공유하게 된다.
    - 쓰레드의 동기화 방법: synchronized, volidate, Atomic 클래스, 뮤텍스, 락

2. 디자인 패턴 아는 것?
    - 싱글톤(SingleTone Pattern) : 대표적으로 Calendar 객체나 dataSource 객체처럼 객체가 하나만 생성되어야 하는 경우 전체 코드에서 하나의 객체만 존재할 수 있도록 이미 생성된 객체가 있으면 그 객체를 사용하도록 하는 방식입니다.
    - 팩토리 패턴(Factory pattern) : 객체간 의존성을 줄이기 위해 객체의 생성과 데이터 주입만 담당하는 Factory Class를 정의하고 개발 코드 부분에서는 생성된 객체를 가져다 사용함으로서 의존성을 줄이는 방식입니다.
    - 옵저버 패턴(Observer Pattern) : 기후 정보처럼 RSS 수신시 하나의 객체가 변하면 다른 객체에 객체가 변했다는 사항을 알려주어야 할 경우에 주로사용됩니다.
    - MVC 패턴
        * Model : data 처리와 접근을 담당(Java Bean)
            + Bean: 자바에서의 POJO(Plain Old Java Object)로, XML 설정파일을 통한 생명주기, 종속성 등의 메타데이터를 가지고 스프링 컨테이너에서 생성된 객체이다. 컨테이너에서 생성되었다는 점을 제외하면 일반 자바객체와 같다.
        * View : Client에 보여지는 화면을 담당(JSP or FE)
        * Controller : Model과 View를 제어(Java Class)
        * 3가지 부분으로 나눔으로서, 데이터와 화면간의 의존관계를 벗어날 수 있게하는 개발 기법입니다.

3. DataBase에서 Index란?
    - Table에 대한 동작 속도를 높여주는 자료구조로서 빠른 검색을 가능하게 해준다.

4. Git에 대해서 아는대로 설명해 보시오.
    - 분산 버전 관리 시스템
    - 매우 빠른 속도와 더불어 SVN과 달리 서버에만 저장소가 있는것이 아니라 로컬과 서버 모두에 저장소가 있는것이 특징
    - 로컬에도 저장소가 있기 때문에, 네트워크가 끊겨도 작업이 가능하다

5. ‘데드락’ 이란 무엇이고 이를 해결하기 위한 방법을 설명해 보시오.
    - 프로세스가 자원을 얻지못해 다음 처리를 하지 못하고 있는 상태. 교착상태
    - 데드락 발생조건은 4가지를 모두 만족해야 되기 때문에, 이들중 하나라도 만족하지 못하게 만들면 데드락 발생 X
        * 상호배제: 자원은 한번에 한 프로세스만 사용
        * 점유대기: 최소한 하나의 자원을 점유하고있으면, 다른 프로세스에 할당되어 사용하고있는 자원을 추가로 점유하기위해 대기하는 프로세스 필요
        * 비선점: 다른 프로세스가 사용중인 자원을, 그 사용이 끝날때까지 뺏을수 없어야함
        * 순환대기: 프로세스집합에서 p0는 p1이 소유한 자원을, p1은 p2가 소유한 자원을... pn은 p0가 소유한 자원을 요구해야 한다

6. ‘에자일’ 방법론에 대해서 아는가?
    - 기존 폭포수모델과 달리 문서보다는 동작하는 소프트웨어에 중점을 두어, 일정한 주기를 가지고 동작하는 소프트웨어를 계속 만들어내며, 그때 그때 필요한 요구를 수정하고 더해서 하나의 커다란 소프트웨어를 만들어내는 방법론
    - 애자일은 하나의 방법론이 아닌 개발 프로세스이며, 이에 속하는 방법론으로는 XP, 스크럼등이 있다

7. UML 그려본 적 있는가?
    - UseCase 다이어그램, 시퀀스 다이어그램, 클래스 다이어그램 등

8. DB 옵티마이저에 대해 아는가?
    - 사용자가 질의한 SQL문에대해 최적의 실행 방법을 결정하는것

9. 함수형 프로그래밍
    - 함수형 프로그래밍은 선언형 프로그래밍으로, 어떻게(How)가 아닌 무엇(What)을 정의한다. C, Java등의 언어는 명령형 프로그래밍이며, 알고리즘을 기술하고 목적은 기술하지 않는다. 선언형은 반대로 알고리즘은 기술하지 않고 목적 위주로 기술하며, 데이터의 입력이 주어지고 데이터의 흐름을 추상적을 정의하는 방식.

10. VO 란?
    - Value Object의 줄임말로, 값을 갖고있는 객체이다. 비즈니스 값을 가져올 때 사용하며, 보통 값을 수정할 수 없는 것으로 한다. DTO와 혼용해서 쓰기도 한다.

11. DTO 란?
    - Data Transfer Object의 줄임말로, VO와 같이 값을 갖고 있는 객체이다. VO와의 차이점은 DB로 치자면 하나의 인스턴스로, 데이터 핸들링에 사용되는 객체이다. DTO를 통해 데이터를 전달할 수 있다.

12. DAO 란?
    - Data Access Object의 줄임말로, 실제 DB에 접속하는 객체이다. Service와 DB사이에서 가져온 데이터를 엔티티로 변환시켜 가져온다. 대부분의 CRUD API를 제공한다.

13. PCB
    - Process Control Block의 약자로, 프로세스 제어 블록이다. 프로세스에 대한 중요한 정보를 저장하고 있다. 운영체제가 프로세스를 표현한 것이라고도 한다. 프로세스 생성시 만들어지며, 주기억장치에 유지된다. 문맥전환 등 다른 프로세스를 처리해야 할 때, PCB에 현재 상태를 저장함으로써 나중에 그 작업 상태를 불러와 작업 재개가 가능해진다. PID, 상태, 다음 명령어 주소 등의 정보가 저장됨.

14. PC
    - Program Counter의 줄임말로, 다음에 실행될 명령어의 주소가 들어있는 레지스터이다. 명령어가 인출되면, 자동으로 다음 명령어를 가리키도록 주소값이 증가된다.

15. 캐시메모리
    - CPU의 레지스터와 메모리 사이에서, 캐싱을 통해 병목 현상을 완화하는 것을 말한다.

16. 멀티 스레드 VS 멀티 프로세스
    - 이 두 가지는 실행 단위를 구분한다는 점은 같지만, 멀티 스레드는 자원을 덜 소모하는 대신 하나의 스레드가 비정상적인 오류를 일으키면 다른 스레드도 종료될 수가 있다는 점과 동기화 문제를 안고 있다. 멀티 프로세스는 자원을 공유하지 않기에 서로간 통신이 멀티 스레드보다 불편하고, CPU 자원을 더 많이 소모한다. 결국 상황에 맞게 골라서 써야한다.

17. CPU 스케줄링 방법
    - 스케줄링 대상은 Ready Queue에 있는 프로세스 대상이다.
    - FCFS (First Come First Served) : 먼저 온 녀석이 먼저 스케줄링을 받음. 중간에 반환하지 않는 비선점형이며, 시간이 긴 프로세스가 먼저 오면 효율성이 떨어짐
    - SJF (Short Job First) : 늦게 오더라도 수행시간이 짧은 프로세스에 먼저 할당. 이렇게 되면 수행시간이 긴 프로세스는 영원히 할당받지 못할 수도 있음(Starvation). 수행시간(CPU Burst Time)은 알지는 못하고 예측만가능
    - SRT (Short Remaining Time) : 현재 프로세스의 수행시간이 끝나는 시간보다 나중에 오는 프로세스의 수행시간 완료 시간이 더 짧다면, 그 즉시 그 프로세스에게 CPU를 할당. 선점형 스케줄링. Starvation과 CPU 수행 시간을 측정할 수 없다는 문제가 있음
    - 우선순위 : 정수로 표현된 우선순위가 더 높은 프로세스에게 할당한다. 선점형 방식과 비선점형 방식으로 나눌 수 있는데, 선점형 방식은 우선순위가 높은 프로세스가 도달하면 그 즉시 그 프로세스에게 CPU를 할당. 비선점형 방식은 Ready Queue의 맨 앞에 그 프로세스를 등록. Starvation과 CPU를 사용못하는 프로세스를 CPU가 무한 대기하는 상태가 있을 수 있음. 오래 기다렸을 경우 우선순위를 높이는 Aging을 통해 해결 가능.
    - Round Robin : 현대적인 CPU 스케줄링으로, 각 프로세스는 동일한 CPU 할당 시간을 갖게 됨. 할당시간 만료시 ready queue 맨 뒤에 가서 줄섬. CPU의 사용시간이 제각각일 때 효율적. 반응 속도가 빨라지며, 공정한 스케줄링. 주의할 점은 할당하는 시간(time quantum)이 너무 길다면 FCFS와 다를게 없음. 너무 작다면 잦은 컨텍스트 스위칭이 발생.

18. 단편화
    - 단편화란 메모리 상에서 적재되고, 해제되는 과정에서 발생하는 메모리 사이의 사용하지 못할 정도로 작은 빈 공간이다. 크게 외부 단편화와 내부 단편화로 나뉜다. 외부 단편화는 프로세스와 프로세스 사이에 발생하는 빈 공간이고, 내부 단편화는 프로세스 안에서 발생하는 빈 공간이다. 외부 단편화는 메모리를 다시 재정렬하는 압축을 통해 해결할 수 있지만, 효율이 좋지 않다.
    - First Fit : 메모리를 할당할 때, 가장 먼저 발견한 곳에 집어넣음
    - Best Fit : 메모리를 할당할 때, 사용 가능한 공간 중 가장 작은 곳에 집어넣음(정렬 필요)
    - Worst Fit : 메모리를 할당할 때, 사용 가능한 공간 중 가장 큰 곳에 집어넣음(정렬 필요)
    - 공간 효율성 : Best Fit > First Fit > Worst Fit
    - 시간 효율성 : First Fit > Best Fit = Worst Fit

19. 가상 메모리
    - 가상 메모리는 기존의 물리 메모리를 물리 메모리와 논리 메모리로 나눔으로써 더욱 효과적으로 쓰기 위한 개념이다. 논리 메모리 테이블은 물리 메모리와 보조기억장치 메모리와 매핑되어 있으며, 프로세스는 가상메모리를 물리 메모리처럼 인식하고 사용하게 된다. 이전에는 가상 메모리는 보조기억장치를 주기억장치처럼 쓰게 하는 것으로 알고 있었는데, 이번에 다시 정리하게 되었다.

20. 페이징
    - 외부 단편화의 압축 작업을 해소하기 위한 방법론으로, 물리 메모리는 Frame, 논리 메모리는 Page라는 고정 크기의 블록으로 나눈다. 프로세스를 페이지 단위로 나눈 뒤에, 사용하지 않는 영역을 보조기억장치에 적재한다. 이를 페이징 되었다고 하는데, 만약 이 페이징 된 영역에 접근해야 하면 페이징 폴트를 발생시킨 후 메모리에 적재시킨다(요구 페이징). 페이징된 정보는 페이징테이블에 저장된다. 단점으로는 내부 단편화가 발생할 수 있다.

21. 세그멘테이션
    - 메모리를 페이지와는 다르게 가변 크기의 세그멘테이션으로 나눈다(물리 메모리 블럭 크기와 다르다). 나누는 시점은 메모리를 사용하게 되는 시점이다. 각 세그멘테이션은 스택, 데이터, 힙, 코드 영역 등으로 나뉘게 된다. 나뉜 세그멘테이션은 시작 주소값과 길이 값이 세그멘테이션 테이블에 저장된다. 자주 사용하면 외부 단편화가 발생할 수 있다.
    - 보통 페이징과 세그멘테이션 둘다 함

22. 페이지 교체 알고리즘 종류
    - FIFO (First In First Out) : 말 그대로 먼저 들어온 페이지를 먼저 내보낸다. 간단한 알고리즘이지만, 페이지의 중요도를 따지지 않기 때문에 초기 변수가 담긴 페이지를 내려버리는 등 여러 문제를 초래할 수 있다.
    - 최적 페이지 교체 (Optimal Page Replacement) : 앞으로 가장 사용되지 않을 페이지를 계산하여 교체한다. 다만 모든 프로세스의 계획을 파악하기가 쉽지 않기 때문에, 어떤 페이지를 교체해야 하는가의 알고리즘을 구현할 때 어려움이 있다.
    - LRU (Last Recently Used) : 가장 나중에 사용된 페이지를 교체한다. FIFO보단 낫고 OPT보단 못하다.
    - LFU (Least Frequently Used) : 가장 덜 사용된 페이지를 교체한다. 활발한 페이지는 사용이 많이 되었을거라는 가정하에 만든 알고리즘. 초기에 많이 사용되었다가 지금은 사용되지 않는 페이지의 경우 교체가 이루어지지 않는다는 문제가 있다.
    - MFU (Most Frequently Used) : 가장 많이 사용된 페이지를 교체한다. 가장 적게 사용된 페이지가 최근에 올라오고 계속 사용될 것이라는 가정. 잘 쓰이지 않는다

23. TDD란
    - 테스트케이스를 먼저 만들고 그 테스트를 통과하게끔 코드를 짜는 방법
    - 품질을 어느정도 확보 할 수 있고, 리팩토링이 용이해지며, 자동화 프로세스와 맞물려 CI/CD등에 필요

24. Block & Non Block
    * 블로킹: 자신의 수행이 끝날때가지 제어권을 자신이 가지고있음
    * 논블로킹: 자신이 호출되었을때 제어권을 바로 자신을 호출한쪽에 넘기며, 자신을 호출한쪽에서 다른일을 수행 할 수 있게 함
    
25. DB Transaction 사용하는 이유
    - 트랜잭션(Transaction)은 데이터베이스의 상태를 변환시키는 하나의 논리적 기능을 수행하기 위한 작업의 단위 또는 한꺼번에 모두 수행되어야 할 일련의 연산
    - 하나의 트랜잭션은 Commit되거나 Rollback된다
    - 트랜잭션 성질 4가지
        * Atomicity(원자성): 트랜잭션의 연산은 데이터베이스에 모두 반영되든지 아니면 전혀 반영되지 않아야 함. 트랜잭션 내의 모든 명령은 반드시 완벽히 수행되어야 하며, 모두가 완벽히 수행되지 않고 어느하나라도 오류가 발생하면 트랜잭션 전부가 취소되어야 함
        * Consistency(일관성): 트랜잭션이 그 실행을 성공적으로 완료하면 언제나 일관성 있는 데이터베이스 상태로 변환. 시스템이 가지고 있는 고정요소는 트랜잭션 수행 전과 트랜잭션 수행 완료 후의 상태가 같아야함
        * Isolation(독립성,격리성): 둘 이상의 트랜잭션이 동시에 병행 실행되는 경우 어느 하나의 트랜잭션 실행중에 다른 트랜잭션의 연산이 끼어들 수 없고, 실행중인 트랜잭션은 완전히 완료될 때까지 다른 트랜잭션에서 수행 결과를 참조할 수 없다
        * Durablility(영속성,지속성): 성공적으로 완료된 트랜잭션의 결과는 시스템이 고장나더라도 영구적으로 반영되어야 한다



    

# Server & Spring Framework

1. 캐시(Cache)와 세션(Session)의 공통점과 차이점은?
    - 공통점 : 둘 다 사용자의 데이터를 저장한다.
    - 캐시 : 캐시는 Client 컴퓨터에 저장했다 서버 요청시 네트워크를 타고 서버로 전달되기 때문에 보안에 취약하다.
    - 세션 : 세션은 서버에 저장되고 브라우저 단위로 관리된다. 캐시에 비해 보안성이 좋다.

2. Request 전송 방식에는 어떤 것들이 있는지 아시나요?
    - GET 방식 : URL의 쿼리문자열에 데이터를 같이 전달하는 방식으로 데이터 길이에 제한이 있고, 보안에 취약하다.
    - POST 방식 : 헤더에 데이터를 넣어 보내기 때문에 보안에 조금 더 유리하고 데이터 길이에 제한이 없다. 하지만, Get에 비해 다소 느리다.
    - DELETE 방식 : RESTFUL에서 삭제 기능을 할 때 주로 사용된다.
    - PUT/PUSH 방식 : RESTFUL에서 수정 작업을 할 때 주로 사용된다.

3. RESTFUL이란?
    - REST란 REpresental State Transfer의 약자, 자원을 표현하여 상태를 전달한다는 뜻으로, 웹에 있는 자원을 HTTP를 통하여 직관적으로 전달하기 위한 간단한 인터페이스
    - REST API의 구성
        * 자원 - URI
        * 행위 - HTTP Method
        * 표현 

    - REST의 특징
        * Uniform Interface: URI로 지정한 리소스에 대한 조작을 통일되고 한정적인 인터페이스로 수행하는 아키텍처 스타일
        * Stateless: 무상태성, 작업을 위한 상태 정보를 저장하고 관리하지 않음. 세션정보나 쿠키를 별도로 저장하고 관리하지 않기 때문에 API는 단순히 들어오는 요청만 처리하면된다.
        때문에 서비스의 자유도가 높고 서버에서 불필요한 정보를 관리하지 않아 구현이 단순해짐
        * Cacheable: 캐시가능. HTTP라는 기존 웹표준을 그대로 사용하기 때문에, 웹에서 사용하는 기존 인프라를 그대로 활용이 가능하며, 이로인해 HTTP가 가진 캐싱기능을 할수있음
        * Self-descriptiveness: 자체 표현 구조로, REST API 메시지만 보고도 이를 쉽게 이해 할 수 있다
        * Client - Server: REST서버는 API제공, 클라이언트는 사용자 인증이나 컨텍스트를 직접 관리하는 구조로 각각의 역할이 확실하게 구분되어 서로 개발해야할 내용이 명확하고 의존성이 적음
        * 계층형 구조: REST서버는 다중 계층으로 구성될수있으며, 보안, 로드밸런싱, 암호화 계층을 추가해 구조상의 유연성을 둘 수 있고, PROXY, 게이트웨이 같은 네트워크 기반의 중간매체를 사용할수있다

    - REST API 디자인 가이드
        * URI는 정보의 자원을 표현해야 한다(리소스명은 동사보다는 명사를 활용)
        * 자원에 대한 행위는 HTTP Method(GET, POST, PUT, DELETE)로 포현한다 
        * / 구분자는 계층관계를 나타내는데 활용
        * URI의 마지막 문자로 / 를 포함하지 않는다
        * ```-```는 URI가독성을 높이는데 활용
        * _ 은 URI에 사용하지 않는다
        * URI엔 소문자가 적합하며, 파일 확장자는 URI에 포함하지 않는다


4. Spring에서 DI란 무엇인지 아시나요? IoC란? 
    - Inversion Of Control, 제어의 역행이라는 뜻으로, 인스턴스의 생성 및 소멸을 개발자 대신 스프링 컨테이너가 한다. 그외 제어권을 프레임워크에서 가져간다는 말로도 쓰인다.
    - DI는 Dependency Injection(의존성 주입)의 약자로, 객체들 간의 의존성을 줄이기 위해 사용되는 Spring의 IOC 컨테이너의 구체적인 구현 방식입니다.
    - DI는 기존처럼 개발코드 부분에서 객체를 생성하는 것이 아니라, 팩토리 패턴처럼 객체의 생성과, 데이터를 주입만 담당하는 Factory에 해당 하는 별도의 공간에서 객체를 생성하고 데이터간의 의존성을 주입해 개발코드에서는 이를 가져다 씀으로서 의존성을 줄이는 방식입니다. 이때, Factory 패턴의 Factory Class의 역할을 스프링의 환경설정 파일이 담당합니다.

5. Spring의 AOP란?
    - AOP는 Aspect Oriented Programming 관점 지향 프로그래밍의 약자로, 기존의 OOP(객체 지향 프로그래밍)에서 기능별로 class를 분리했음에도 불구하 고, 여전히 로그, 트랜잭션, 자원해제, 성능테스트 메서드 처럼 공통적으로 반복되는 중복코드가 여전히 발생하는 단점을 해결하고자 나온 방식
    - 공통 코드를 "횡단 관심사"라 표현하며 개발코드에서는 비지니스 로직에 집중하고 실행시에 비지니스 로직 앞, 뒤 등 원하는 지점에 해당 공통 관심사를 수행할 수 있게 함으로서 중복 코드를 줄일 수 있는 방식입니다.

6. Servlet vs JSP
    - Servlet : 자바 언어로 웹 개발을 위해 만들어진 것으로, Container가 이해할 수 있게 구성된 순수 자바코드로만 이루어진 것 
    - JSP : html 기반에 JAVA 코드를 블록화하여 삽입한 것으로 Servlet을 좀 더 쉽게 접근할 수 있도록 만들어 진 것

7. WAS와 웹서버의 차이점은?
    - 웹서버: 웹 브라우저와 같은 클라이언트를 통해 HTTP요청을 받아, HTML과 같은 문서를 정적으로 처리해 반환
    - 웹 어플리케이션 서버: 웹서버 + 웹 컨테이너. HTTP를 통해 컴퓨터나 장치에 애플리케이션을 수행해주는 미들웨어
        * 웹 컨테이너: 자바 서블릿과 상호작용. 서블릿 API제공

    - 웹서버는 정적 데이터를 처리하고 웹 어플리케이션 서버는 동적 데이터를 처리
    - 웹서버를 앞단에두고 정적 문서 처리를 담당하게 한 후, 웹 어플리케이션 서버는 애플리케이션 로직만 수행하도록 하여 서버의 부담을 줄임

8. 비동기와 동기 방식의 차이점에 대해서 말해보시오
    - 동기: 요청을 보낸 후 받아야지만 다음 동작 실행
    - 비동기: 요청을 보낸 후 응답결과와 상관없이 다음 동작을 실행. 비동기식은 비동기식 처리를 요청할 때 할일 이 끝난 후 처리결과를 알려주는 콜백이라는 함수를 함께 알려줌.

9. Spring Framework에서의 요청 처리 순서(브라우저부터 설명)
    - 클라이언트(브라우저)에서 URL로 접속하여 정보를 요청
    - DispatcherServler이 해당 요청을 받아, 해당 요청을 매핑한 컨트롤러가 있는지 확인
    - Handler Mapping에서 적절한 Controller에게 처리 요청
    - Controller 에서 해당 요청 처리 후, 결과를 출력할 View의 이름을 DispatcherServlet에게 반환
        * 이 과정에서 컨트롤러는 해당 요청을 처리할 적절한 Service를 사용 할 수 있고, 해당 Service는 DAO를 통해 DB와 접근도 할 수 있음
        * 이것이 MVC 패턴

    - DispatcherServelet에서 받은 View이름을 바탕으로 적절한 View를 ViewResolver를 통해 검색
    - ViewResolver가 처리 결과를 View에게 송신
    - View는 처리 결과를 담아 DispathcerServler에게 송신
    - DispathcerServlet이 클라이언트에게 최종 결과 출력

10. 컨테이너란
    - 프레임워크 안에서 인스턴스들의 생명주기를 관리하며, 생성된 인스턴스들에게 추가적인 기능을 부여한다. 내가 작성한 코드의 처리과정을 컨테이너에서 수행한다. 스프링 컨테이너는 스프링 프레임워크 핵심에 위치하여, DI를 통해 애플리케이션을 구성하는 컴포넌트들을 관리한다.

11. AJAX란?
    - Ajax란 좁은 의미로 클라이언트에서 서버가 비동기적으로 통신하는 기술
    - HTTP 요청 시 XMLHttpRequest라는 객체를 생성하여 수행한다.
    - request요청의 상태가 변할 때, readyState라는 플래그가 변하며, onreadystatechange라는 함수를 호출하게 된다.
    - readyState 상태 플래그
        * 0 : 객체 생성 완료, open()함수 호출 전
        * 1 : open()함수 호출 성공
        * 2 : send()함수 호출 성공
        * 3 : recv()함수 호출, 데이터 다운로드 중
        * 4 : Done, 모든 작업이 끝남

12. HTTP 요청 흐름 (웹브라우저에서의 요청)
    - 브라우저에서 먼저 URL에 적힌 값을 파싱하여, HTTP 요청 메세지를 만든다. 만든 메세지를 웹 서버로 전송하는데, 이때 웹 브라우저 직접 전송을 하는것이 아니라 OS에 보내주십쇼~ 하고 의뢰를 하게 된다. OS는 DNS서버를 조회해서 Host이름을 보내야 할 IP 주소로 변환하게 된다.
    - 프로토콜 스택(운영체제에 내장된 네트워크 제어용 소프트웨어, TCP/IP 계층)과 LAN 어댑터 에서 브라우저로부터 메시지를 받는다. 브라우저로부터 받은 메시지를 패킷 속에 저장한다. 그리고 수신 주소를 제어정보에 덧붙인다. 그 다음, 패킷은 LAN 어댑터에 넘긴다. LAN 어댑터는 패킷을 전기 신호로 변환시켜 LAN 케이블에 송출하게 된다.
    - 허브, 스위치, 라우터 에서 LAN 어댑터로부터 송신한 패킷을 수신한다. 라우터는 패킷을 ISP에 전달, 인터넷으로 들어가게 된다.
    - 액세스 회선, ISP : 액세스 회선이라는 것은 인터넷의 입구에 있는 통신 회선이다. 액세스 회선에 의해 통신사용 라우터(POP, Point Of Presence)까지 운반된다. POP를 거쳐 인터넷의 핵심부로 들어가게 된다. 고속 라우터들 사이로 목적지까지 패킷이 흘러가게 된다.
    - 방화벽, 캐시서버 : 인터넷 핵심부를 통과한 패킷은 목적지의 LAN에 도착하게 된다. 방화벽이 먼저 패킷을 검사한 후, 캐시서버로 보내서 웹 서버까지 갈 필요가 있는지 검사한다.
    - 웹 서버 : 패킷이 물리적 웹 서버에 도착하면, 웹 서버의 프로토콜 스택이 패킷을 추출하여 메시지를 복원하고, 웹 서버 애플리케이션에 넘긴다. 애플리케이션은 요청에 대한 응답 데이터를 넣어 클라이언트로 회송한다. 온 방식 그대로 전송되게 된다.

13. HTTP/HTTPS 차이
    - HTTP + SSL = HTTPS
    - HTTP는 평문 통신이다. TCP/IP 특성상 도청이 가능하며, 통신 상대를 확인하지 않기 때문에 위장이 가능하다. 가령 나는 IP가 A인 사람한테 보내고 싶은데, 악의적인 해커가 내가 IP A요 하고 말해도 검증할 방법이 없다는 것. 또한 완전성을 증명할 수 없기 때문에 변조가 가능하다. 보안 방법은 통신 자체를 암호화(SSL, TLS)하거나, 콘텐츠를 자체를(HTTP 메시지 컨텐츠를) 암호화 하는 것이다. 도청이 가능한 문제, 사용자를 확인할 수 없다는 문제, 정확성을 보장할 수 없다는 문제를 모두 해결할 방안으로 나온 것이 HTTPS이다.
    - HTTPS는 새로운 프로토콜이 아닌, HTTP에서 SSL 개념을 더한 프로토콜이다. 기존 HTTP는 TCP와 직접 통신했지만, HTTPS는 HTTP와 TCP 사이에 SSL, TLS가 끼워져 있는 것이다. HTTP는 SSL과 통신하고, SSL은 TCP와 통신하게 된다.
    - SSL의 원리를 간략하게 설명하면, 대칭키와 공개키 방식 두 암호화 방식을 사용하는데, 먼저 클라이언트가 서버에게 HELLO 메세지를 보내면, 서버가 클라이언트에게 HELLO 메세지를 보내면서, 서버 암호화 된 인증서와 랜덤 데이터를 넘겨주게 된다. HELLO 과정에서 어떤 암호화 프로토콜을 사용할 것인지 협상한다. 클라이언트는 받은 인증서를 CA리스트에서 조회 후 CA 공개키를 사용하여 인증서를 복호화한다. 복호화에 성공 했다면 이 서버는 신뢰할 수 있는 서버이다. 서버가 보낸 랜덤 데이터와 클라이언트의 랜덤 데이터를 조합해서 대칭키를 생성한다. 서버로부터 받은 공개키(인증서)를 사용하여 대칭키를 암호화 후에, 서버에게 보내게 된다. 서버는 암호화된 대칭키를 받고, 비밀키로 복호화 함으로써, 서버와 클라이언트가 서로 대칭키를 가지게 된다. 이 대칭키로 통신을 암호화한다.

14. TCP/UDP 등 로우레벨 통신 지식
    - TCP 3-way hand shake
        * TCP/IP 프로토콜을 이용해서 통신하는 프로그램이, 데이터를 전송하기 전에 먼저 정확한 전송을 보장하기 위해 상대방과 사전에 세션을 수립
        * 클라이언트에서 서버로 접속을 요청하는 SYN패킷을 보냄. 클라이언트는 SYN을 보내고 SYN/ACK 응답을 기다리는 SYN_SENT 상태가 됨
        * 서버는 SYN 요청을 받고, 클라이언트에게 요청을 수락한다는 ACK와 SYN 플래그가 설정된 패킷을 발송하고 다시 클라이언트가 ACK로 응답하기를 기다리는 SYN_RECEIVED 상태가 됨
        * 다시 클라이언트는 서버에게 ACK 를 보내고, 이후 연결이 이뤄져 데이터가 오가게되고 서버의 상태는 ESTABLISHED가 된다

    - TCP 4-way hand shake
        * 3-way hand shake가 연결을 수립하기 위한것이였다면, 4-way hand shake는 세션을 종료하기 위해 수행
        * 클라이언트가 연결을 종료하겟다는 FIN 플래그 전송
        * 서버는 확인 메시지인 ACK를 보내고, 자신의 통신이 끝날때까지 기다리게 되는데 이 상태가 TIME_WAIT
        * 서버의 통신이 끝났으면 연결이 종료되었다고 클라이언트에게 FIN 플래그 전송
        * 클라이언트는 확인했다는 ACK를 다시 클라이언트로 보내고 연결 종료
        * 서버에서 FIN을 전송하기전 전송한 패킷이 Routing지연이나 패킷 유실로 인한 재전송 등의 이유로 FIN보다 늦게 도착할 경우, 이 패킷은 Drop되고 유실될것이다. 클라이언트에서는 이를 방지하기 위해 서버로부터 FIN을 수신하더라도 일정 시간(디폴트 240초) 동안 세션을 남겨놓고 잉여 패킷을 기다리는데, 이 상태가 TIME_WAIT이다

    - TCP는 흐름제어, 오류제어를 통한 연결 지향성, 순서 중요함, 오류시 재전송. 전이중과 점대점(각 연결이 정확히 2개의 종단점을 가지고 있음) 방식.
    - UDP는 비연결형 프로토콜, 상대방이 받든지 말든지 그냥 보낸다. 손상된 세그먼트에 대해 재전송하지 않는다. 만약 클라이언트 timeout이 발생하면 다시 보내면 그만이다.

15. CORS란?
    - Cross Origin Resource Sharing 약자. 말 그대로 다른 도메인간의 자원 공유를 의미한다. 본래 대부분의 브라우저는 타 도메인 간 요청을 Same-Origin-Policy에 의해 차단한다. 이런 설정을 우회하기 위해 여러 방법이 있었지만, HTML5가 등장하면서 CORS가 등장했다. CORS는 헤더를 통하여 Cross-Domain간 사용가능한 자원을 헤더를 통하여 알려준다.

16. 사용했던 프로젝트 환경
    - Spring Boot 2.1.2
        * spring-boot-starter: 의존성과 설정을 자동화 해주는 모듈
        * spring-boot-starter-web: 웹과 관련된 의존성과 설정을 자동화
        * spring-boot-starter-actuator: Spring Boot기반 어플리케이션을 쉽게 제공해주는 라이브러리, 상태 모니터링, 트래픽등
        * spring-boot-starter-test: 테스트와 관련된 라이브러리(spring-test, junit, hamcrest등)
    
    - lombok : getter/setter등 반복되는 코드를 어노테이션으로 작성하게 해주는 라이브러리 
    
    - tomcat
        * spring-boot-starter-tomcat: spring boot 내장 톰켓
        * javax.el-api 2.2.4: 값을 표현하는데 쓰는 Expression Language를 사용하기 위해
    - JPA
        * spring-boot-starter-data-jpa: JPA를 한번 더 추상화해 사용하기 쉽게 만든 프레임워크
        * spring-orm: 객체와 DB 테이블을 매핑하기 위한 도구
        * mysql-connector-java: Mysql 연결을 위한 커넥터
        * com.h2database: 자바 기반의 오픈소스 RDBMS
        * spring-data-rest-hal-browser: HATEOAS (Hypermedia As The Engine Of Application State)을 구현하기 위한 Hpyertext Application Language
        * spring-boot-starter-freemarker: 자바 템플릿 엔진, 템플릿 뷰를 만들때 사용
        * querydsl-jpa 4.1.4: SQL, JPQL을 문자열이 아닌 코드로 작성하게 해주는 빌더 API

    - swagger
        * springfox-swagger2 2.6.1, springfox-swagger-ui 2.6.1, swagger-springmvc 1.0.2
        * REST API를 설계 및 문서화 등에 유용하게 사용되는 라이브러리
    
    - usertype.jodatim 2.0.1: 시간 관련 라이브러리, 사용하기 편하고 Thread Safe함
    - JSON
        * jackson-datatype-joda, jackson-datatype-hibernate5, jackson-module-scala_2.11 2.6.6, jackson-core-asl 1.9.13, jackson-mapper-asl 1.9.13, json-path, json-simple 1.1.1, gson
        * JSON 관련 라이브러리

    - Apache Commons
        * commons-io 1.3.2: IO관련 유틸리티
        * commons-lang3 3.3.2: java.lang 관련 추가 유틸리티
        * httpclient: HTTP 통신을위한 라이브러리
        * commons-validator 1.5.1: 데이터 검증등을 위한 라이브러리
        * commons-codec 1.9: base64, URL등의 인코딩/디코딩을 위한 라이브러리
    
    - Excel parsing
        * poi 3.17, poi-ooxml 3.17, poi-scratchpad 3.17, opencsv 4.0
        * 엑셀등 문서 읽기/쓰기를 위해

    - bouncycastle
        * bcprov-jdk15on 1.47: 확장된 기능을 가진 자바 암호화 라이브러리
    
    - annotations

    - Spring Security
        * spring-security-core: 스프링 시큐리티 
        * spring-security-oauth2 2.3.5: OAuth2.0 라이브러리
        * spring-security-jwt 1.0.0, java-jwt 3.8.3 : JWT사용을 위한 라이브러리
    
    - Unit Test(JUnit 5)
        * junit-jupiter-api, junit-jupiter-engine, junit-platform-runner, junit-platform-commons 1.5.2: JUnit 5
        * mockito-core: Mock 라이브러리
        * jacoco-maven-plugin: Code Coverage 측정을 위한 라이브러리
        * maven-surefire-plugin, maven-surefire-report-plugin: Unit test를 위해 

    - onelogin
        * java-saml-core 2.3.0: 도메인간의 SSO를 가능하게 하는 라이브러리
        * SAML : Security Asserting Markup Language, http://en.wikipedia.org/wiki/SAML 참조
        * SSO : Single Sign On 하나의 일관된 인증방식으로 여러 서비스에 로그온할 수 있는 방법

    - Java 1.8
    - log4jdbc 1.16

17. 배포 전략
    - Rolling: 서비스중인 서버를 한대씩 구버전에서 신버전으로 교체. 서비스중인 서버 한대를 제외 시키고 그자리에 신버전 서버를 추가. 트래픽을 점진적으로 변경. 서버수의 제약이 있을때 유용하나, 배포중 인스턴스의 수가 감소하므로, 처리 용량을 미리 고려 해야함
    - Blue/Green: 구버전에서 새버전으로 일제히 전환하는 전략. 구버전의 서버와 신버전의 서버를 동시에 나란히 구성하고, 배포시점이 되면 트래픽을 일제히 전환. 한번에 하나의 버전만 프로덕션 되므로, 버전 관리 문제를 방지 할 수 있고, 빠른 롤백이 가능. 운영 환경에 영향을 주지 않고 실제 서비스환경으로 새버전 테스트 가능. 단 시스템 자원이 2배로 필요하고, 전체 플랫폼에 대한 테스트가 이뤄져야 한다
    - Canary: 구버전과 새버전의 서버들을 구성하고 일부 트래픽을 새버전으로 분산하여 오류 여부를 판단. 분산 후 결과에 따라 새 버전이 운영 환경을 대체할수도 있고, 다시 구버전으로 돌아갈수도있다

18. 모놀리식 아키텍처와 MSA
    - Monolithic Architecture: 모듈별로 개발을 한 후, 개발이 완료된 애플리케이션을 하나의 결과물로 패키징하여 배포되는 형태
        * 개발, 빌드, 배포, 테스트가 용이함
        * CI/CD가 어렵고, 모든 모듈이 하나의 프로세스에서 돌아가기 떄문에, 하나의 모듈이 수정되어 서버를 내렸다 올릴경우 다른 모듈들도 그동안 작동 불가능한 상태가 됨

    - Mirchroservice Archetecture: 애플리케이션을 느슨히 결합된 서비스의 모임으로 구조화하는 서비스 지향 아키텍처(SOA) 스타일의 일종인 소프트웨어 개발 기법. 이로 인해 쉽게 교체 될 수 있고, 독립적으로 개발되고 전개될 수 있는 작은 어플리케이션이 마이크로서비스
        * 마이크로서비스의 핵심은 한가지만 아주 잘 처리하자 이며, 이로 인해 큰 문제들을 작은 문제로 나누어 해결, 작게 나뉘어진 서비스가 서로에게 영향을 미치지 않고 독립적으로 역할을 수행
        * 각각의 서비스가 오직 자신과만 상호작용 하는 DB를 가지기 때문에, 서비스마다 DB종류도 다르게 가질수있지만, 각 서비스별 데이터 중복이 일어날 수있고, 한쪽의 데이터만 업데이트 될 수도 있다
    
    - 모놀리식 아키텍처는 어플리케이션 확장시 운영에 관한 업무량이 증가하며, 새로운 기능 추가에 따른 라인수와 복잡도 증가, 불가피하게 어플리케이션을 수직/수평으로 확장해야한다
    - 모놀리식 아키텍처는 특정 서비스에만 트래픽이 몰려서 로드밸런서를 두어 확장해도, 모든 모듈이 하나의 어플리케이션으로 배포되기 때문에 어플리케이션 사본을 운영하는 서버를 두어 수평 확장해야 한다
        * 이렇게 확장할경우 기존 코드에 대해 무결성을 확인하기 위해 많은 테스트를 거쳐야 하며, 기술적 부채가 늘어난다. 그래서 이러한 형태가 Monolithic(단단히 하나로 짜여진)이다
    
    - 마이크로서비스 아키텍처는 작은 서비스 단위로 나누어 배포하기 떄문에 배포가 어렵고, 서비스간 통신 방식이 필요하며, 서비스를 나눠서 데이터간 중복이 있을 수 있고 정합성을 보장하기 어렵다

19. 스케일업, 스케일아웃
    - 스케일아웃: 여러대의 서버로 나누어 일을 처리하는것. 로드밸런서 필요
    - 스케일업: 서버가 더 빠르게 동작하기위해 서버의 하드웨어 성능을 올림

20. Spring에서의 예외 처리 전략
    - 통일된 Error Response객체를 가져야함. 그렇지 않으면 클라이언트에서 예외처리를 항상 같은 로직으로 처리하기가 어려움
    - ```@ControllerAdvice```로 모든 예외를 핸들링
        * handleMethodArgumentNotValidException: ```@Valide```로 바인딩 에러시 발생
        * handleBindException: ```@ModelAttribut``` 으로 binding error 발생시 BindException 발생
        * handleMethodArgumentTypeMismatchException: enum type 일치하지 않아 binding 못할 경우 발생
        * handleHttpRequestMethodNotSupportedException: 지원하지 않은 HTTP method 호출 할 경우 발생
        * handleAccessDeniedException: Authentication 객체가 필요한 권한을 보유하지 않은 경우 발생, Security에서 던지는 예외
        * handleException: 그 밖에 발생하는 모든 예외 처리, Null Point Exception 등, 개발자가 직접 핸들링해서 다른 예외로 던지지 않으면 모두 이곳으로 모임
        * handleBusinessException: 비지니스 요규사항에 따른 Exception
    
    - Error Code를 Enum으로 정의해 한곳에서 관리
    - 요구사항에 맞지 않는 요청이 들어온경우, Exception을 발생시켜 로직을 종료 해야함. 이것이 Business Exception
    - try-catch는 최대한 지양하며, 사용하게 될 경우 더욱 구체적인 Exception을 발생시켜라

21. OSI 7 Layer
    - 1 물리계층: 물리 매체를 통해 Bit흐름을 전송, 물리적 장치와 인터페이스가 전송을 위해 필요한 기능과 처리절차 규정
    - 2 데이터링크: 노드와 노드 사이의 데이터 전달, 단순 bit를 전송하는 물리층에 신뢰성을 더하기 위한 흐름제어및 오류제어기능, LLC와 MAC 2개의 서브Layer
    - 3 네트워크: 송신측에서 최종 목적지까지 데이터를 전달, 송수신측의 논리주소 지정및 최종목적지에 도달하도록 경로를 배정하는 라우팅기능, 데이터링크의 물리주소는 패킷이 시스템으로 이동할때마다 변경되지만, 네트워크 주소는 목적지까지 변하지 않음
    - 4 전송: 네트워크 계층에서 패킷을 종단까지 전달한다면(네트워크 주소), 전송층은 종단 내에서 최종 수신 프로세스로의 전달(포트 주소)을 담당, 분할/재조립, 연결/흐름제어, 오류제어
    - 5 세션: 통신하는 프로세스 사이의 대화제어 및 동기화 담당
    - 6 표현: 데이터의 변환, 압축, 암호화를 담당
    - 7 응용: 사용자에게 서비스 제공 역할, SMTP, FTP, HTTP등 사용자가 원하는 최종목표에 해당

22. Proxy
    - 프록시는 보안등의 이유로 직접 통신할수 없는 서버와 서버 사이의 중개자 역할
    - Forward 프록시: 프록시를 클라이언트와 원격리소스 사이에 위치시킴. 클라이언트가 요청한 리소스를 원격에서 가져와서 클라이언트에 돌려주는 역할
    - Reverse 프록시: 프록시를 인터넷 리소스앞에 위치시김. 내부서버가 직접 제공하는것 대신 보안을 확보하기 위해 사용. DMZ라고 하는 내부/외부 네트워크 모두 접근할 수 있는 공간에 리버스 프록시를 위치시키고, 실제 서비스는 내부망에 위치하도록 하여서 보안 확보. 일반적으로 WEB(Apache, nginx) - WAS(Tomcat) 분리형태에서, WEB이 리버스프록시가 된다

23. OAuth 2.0
    - OAuth 2.0이란: 외부 서비스의 인증 및 권한부여를 관리하는 범용 프레임워크. OAuth기반 서비스의 API를 호출 할때에는, HTTP 헤더에 accessToken을 포함하여 요청을보내는데, 서비스는 해당 accessToken을 검사하며 요청이 유효한지 확인한다
    - OAuth를 구성하는 4개 Role
        * resource owner(자원 소유자): protected resource(보호된 자원)에 접근하는 권한을 제공
        * resource server(자원 서버): access token을 사용해 요청을 수신할때, 권한을 검증후 적절한 결과를 응답
        * client: 자원 소유자의 보호된 자원에 접근 요청을 하는 어플리케이션
        * authorization Server: 클라이언트가 성공적으로 access token을 발급받은 이후에, 자원 소유자를 인증하고 권한부여
    
    - 권한 허가 절차
        * 클라이언트가 자원 소유자에게 권한을 요청
        * 자원 소유자가 권한을 허가하면 클라이언트는 권한증서를 받는데, 이 권한 증서는 자원소유자가 자원에 접근할 수 있는 권한을 부여하였다는 증거로, 클라이언트가 access token을 요청하여 얻어오는데 사용되며 4종류가 있다
            + Authorization Code: 클라이언트가 자원소유자에게 직접 권한부여를 요청하는 대신, 자원 소유자가 권한 서버에 인증을 받고 권한을 허가함. 권한을 허가하게 되면 Authorization Code(권한 코드)가 발급되게 되고, 클라이언트는 이 코드를 권한 서버에 보내 access token을 받아온다. access token을 클라이언트로 직접 전달하지 않기때문에, 전달과정에서 생길수있는 잠재적 유출을 방지하는데 도움
            + Implicit: Authorization Code을 간소화한 절차로, access token을 얻기위해 중간 매개체로 Authorization Code를 사용하는것 대신, 바로 access token을 받아오는 방식. 간편하지만 보안성이 낮아짐
            + Resource Owner Password Credentials: 자원 소유자의 계정 인증 정보(ID/PW)가 access token을 얻기 위한 권한 증서로 사용됨. 계정 정보를 어플리케이션에 직접 입력해야 하므로 신뢰할수 있어야 하며 access token을 얻은 이후에는 리소스 요청을 위해 계정 인증 정보를 클라이언트가 가지고 있을 필요는 없음
            + Client Credentials: 자원 소유자가 유저가 아닌 클라이언트일때 사용되는 방식으로, 클라이언트가 관리하는 리소스에만 접근할 경우로 권한이 한정 되어 있을경우로 권한이 한정되어있을때 활용. 즉 클라이언트가 자원소유자가 되는 상황이며 클라이언트는 자기를 인증할 수 있는 정보를 권한서버에게 보내 access token을 요청

        * 권한 증서를 받은 클라이언트는 access token을 권한 서버에 요청
        * 권한 요청을 받은 권한 서버는 클라이언트가 보내온 권한 증서의 유효성을 검증해서 유효하다면 access token을 발급하고 그 결과를 클라이언트에 알려줌
        * access token을 받은 클라이언트는 자원 서버에 해당 access token을 사용해서 자원을 요청
        * 요청을 받은 자원 서버는 해당 access token의 유효성을 검증하여 유효하다면 요청 처리

    - Access Token과 Refresh Token
        * Access Token: 요청 절차를 정상적으로 마친 클라이언트에게 발급됨. 보호된 자원에 접근할때 권한 확인용으로 사용
        * Refresh Token: 한번 발급받은 Access Token은 사용할 수 있는 시간이 제한되어 있으므로, 유효기간이 만료되면 새로운 access token을 받아와야 하는데, 이때 사용되는것이 refresh token. 권한서버가 access token을 발급해줄때 같이 발급되며, 전용의 발급 절차 없이 미리 가지고 있을 수 있음. 권한서버에서만 활용되며 자원 서버에는 전송되지 않고, 오류등으로 권한이 만료됨을 안 클라이언트는 refresh token을 권한 서버에 보내 새로운 access token의 발급을 요청. 권한 서버는 refresh token의 유효성을 검증하고 문제가 없으면 access token을 발급

    - AuthorizationServerConfigurerAdapter
        * accessTokenConverter
        * tokenStore
        * tokenGranter
        * configure(ClientDetailsServiceConfigurer)
        * configure(AuthorizationServerEndpointsConfigurer)

    - JwtAccessTokenConverter
        * encode
        * enhance
    
    - RefreshTokenGranter
        * getAccessToken
        * Constructor
    
    - TokenEnhancer
        * enhance
        
    - AbstractTokenGranter
        * Constructor
        * getOAuth2Authentication
        * getAccessToken
    
    - WebSecurityConfigurerAdapter
        * authenticationManagerBean
        * configure

24. 컨테이너 오케스트레이션
