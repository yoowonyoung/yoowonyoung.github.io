---
layout: post
title: "기술면접 준비"
description: 기술면접 준비
date: 2020-08-11 20:41:00 +09:00
categories: Interview
---

# 자기소개
안녕하세요 현재 카카오 비즈개발실 채널서비스개발 파트에 재직중인 유원영입니다.

저는 이전 직장인 삼성리서치에서는 약 3년동안 재직 하였는데, 재직기간 동안 In-house 서비스인 개발 데이터 가시화 Dashboard의 Backend 서버를 개발 했었습니다. 해당 서비스는 개발 과정에서 모이는 git log, jira issue, static analysis 결과 등 여러 데이터를 모아, 이를 가시화 해서 보여주는 서비스로, 개발 초기 당시에는 삼성리서치 사업부 대상으로만 제공되었지만 나중엔 해외연구소를 포함한 삼성전자 전체 사업부를 대상으로 서비스를 했었습니다.

이후 카카오로 이직하여, 멜론 개발실에서 멜론 콘텐츠 개발 프로젝트에 백엔드 개발자로 참여, 멜론의 트랙제로기능에 대한 추천 트랙 리스트 관리 기능을 제작하며, 기획자가 해당 기능을 사용하기 위한 내부 어드민 페이지도 같이 제작 하였고, 멜론의 레거시 백엔드 코드 개선작업에도 참여, 16년된 멜론의 가사 등록 모듈을 개선하기도 하였습니다. 현재는 채널서비스 개발파트로 옮겨, 카카오for비즈니스 서비스의 기존 CI/CD 환경을 Kubernetes 환경에 맞게 고도화 하는 업무에 참여 하고 있습니다.

저는 계속 Spring/Java 기반의 Backend개발을 하였고 인프라를 직접 다뤘기 때문에 Spring framerowk에 대한 전반적인 이해 뿐만 아니라, Mysql/PostgreSQL/Oracle 등 다양한 DB에 대한 사용 경험 및, 서비스를 Dockerize하여 CircleCI 및 Artifatcory 와 연동하여 PR생성시 자동 Test 및 Docker image까지 백업 하며 Ansible을 통해서 프로비저닝하는 환경을 직접 구축한 경험도 있습니다. 이러한 배경 지식과 경험을 바탕으로 더욱더 발전하면서 기여하고싶습니다. 

# 카카오에서의 경력이 짧은데 왜 이직 하게 되었는가
카카오의 문화와 맞지 않다고 생각해서. 카카오 엔터테인먼트 분사와 관련해서 이슈가 있었음. 카카오 엔터테인먼트가 출범하면서 내가 속해있던 멜론도 카카오 엔터테인먼트로 합병이 될 예정이였음. 입사후 수습기간도 풀리지않았는데 전달받은 소식이긴 했지만, 사업적 측면에서 봣을땐 당연할뿐만아니라 컨텐츠 산업끼리 시너지를 낼 수 있는 환경이 만들어지는것이라 긍정적으로 생각하였음. 하지만 전적동의를 구하는 과정에서, 전적 이후 카카오 엔터테인먼트에서의 개발 환경이나 인프라 심지어 복지나 처우까지 정해진것이 하나 없는 상황에서 짧은 기간 동안 전적 동의를 구하였고 이에 수많은 동료들이 항의 하였지만 회사는 강행하였음. 그래서 선택을 보류하게, 선택을 보류한 인력은 본사에 잔류시킨다는 카카오의 결정에 따라, 카카오 본사에 잔류하게 되었는데, 첫 설명회 당시에는 잔류 이후 재배치 프로세스에 대해서 개인이 원하는 부서를 최대한 반영해준다고 말하였으나, 실제 재배치 프로세스에서는 개인의 의사가 아닌 회사 결정에 따라 전략배치가 이뤄졌었음. 그래서 배치받을 조직의 조직장분과 면담 한번 해보지 못한채 인사 이동 공고를 통해 배치 부서를 확인 하게 되었음. 그러한 과정을 거치면서 상당한 스트레스를 받게 되었고, 카카오의 문화와 나는 맞지 않다고 판단, 그로인해 이직을 결심하게 되었음

# Java

1. 자바의 특징
    - 객체지향 언어
    - 가비지 컬렉션에 의한 자동 메모리 관리
    - 멀티 쓰레드 지원
    - JVM위에서 동작하기떄문에 OS에 종속적이지 않고, 이식성이 좋으며 보안성이 좋다
    - 제임스 고슬링 제작

2. 변수란?
    - 하나의 값을 저장할 수 있는 메모리 공간

3. 객체와 클래스, 인스턴스의 차이
    - 클래스: 현실 세계의 객체 속성과 동작을 추려내 필드와 메서드로 정의한것. 아직 메모리에 할당되지 않은 상태
    - 객체: 클래스라는 설계도를 기반으로 실제 메모리상에서 동작하는것
    - 인스턴스: 설계도를 바탕으로 소프트웨어의 세계에 구현된 구체적인 실체. 객체가 메모리에 할당되어 실제 사용되면 그때 인스턴스라고 부르는것. 사실 객체와 인스턴스는 구분짓기 

4. 객체지향 프로그래밍과 그 특징
    - 프로그래밍에서 필요한 데이터를 추상화 시켜서 상태(속성, 어트리뷰트)와 행위(메서드)를 가진 객체 로 만들고, 그 객체간의 상호작용을 통해 로직을 구성하는 방법.
    - 장점
        * 다른 클래스를 가져와 사용할 수 있고, 상속받을 수 있어 코드의 재사용성 증가
        * 절차지향보다 유지보수가 간단
        * 클래스 단위로 모듈화가 가능하여, 대형 프로젝트에 적합
    
    - 단점
        * 처리속도가 상대적으로 느리다.
        * 객체가 많으면 용량이 커진다.
        * 설계시 많은 노력과 시간이 필요하다.
    
    - 추상화: 객체지향 관점에서 클래스를 정의하는 것, 불필요한 정보 외 중요한 정보만 표현함으로써 공통의 속성과 기능을 묶어 이름을 붙이는 것.
    - 캡슐화: 코드를 수정없이 재활용 하는 것을 목적으로 함. 클래스라는 캡슐에 기능과 특성을 담아 묶는다. 목적을 기준으로 묶는다.
        * 은닉화와의 차이 - 은닉화는 캡슐화의 일부라고 볼 수 있으며, 목적으로 묶인 캡슐 안을 사용자는 볼 수 없다는 것이 은닉화.
    
    - 상속: 클래스로부터 속성과 메서드를 물려받는 것을 말함. 다른 클래스를 가져와서 수정할 일이 있다면, 그 클래스를 직접 수정하는 대신 상속을 받아 변경하고자 하는 부분만 변경
    - 다형성: 하나의 변수명이나 함수명이 상황에 따라 다르게 해석될 수 있음. 대표적인 다형성이 오버라이딩과 오버로딩
    - OOP의 5가지 법칙 (SOLID)
        * Single Responsibility Principle, 단일 책임 법칙: 각 클래스는 목적을 하나씩만 가지고 그에 대한 책임을 져야 한다.
        * Open Close Principle, 개방 폐쇄 법칙: 각 클래스는 클래스에 대한 수정을 폐쇄하고, 확장에 대해 개방해야 한다. 즉 클래스를 수정해야 한다면 그 클래스를 상속, 즉 확장하여 수정한다.
        * Liskov Substitusion Principle, 리스코프 치환 법칙: 자식 클래스를 사용 중일때, 거기에 부모 클래스로 치환하여도 문제가 없어야 한다.
        * Interface Segreation Principle, 인터페이스 분리 법칙: 각 행위에 대한 인터페이스는 서로 분리되어야 한다. 핸드폰을 예로 들면, 전화를 하는데 핸드폰 카메라가 방해가 되면 안된다는 말.
        * Dependency Inversion Principle, 의존성 역전 법칙: 상위 클래스가 하위 클래스에 의존하면 안된다는 법칙. 즉 기본적인 공통되는 속성을 하위 클래스에 의존하면 안된다.

5. 추상메서드? 추상 클래스?
    - 추상메서드 : 메서드의 정의부만 있고 구현부는 있지 않은 메서드
    - 추상 클래스 : 추상메서드를 적어도 하나 이상 가지고 있는 클래스로 자식클래스에서 오버라이딩(재정의)가 필요한 추상메서드를 가지고 있기 때문에 객체화 할 수 없다.

6. 인터페이스(Interface)란? 또 왜 사용하나?
    - 인터페이스는 모든 메서드가 구현부가 없는 추상메서드로 이루어진 클래스로, abstract 키워드를 붙이지 않아도 자동으로 모든 메서드는 추상메서드로 정의가 된다. 또한 변수도 자동으로 final static 키워드가 붙게 된다.
    - 팀작업시 개발코드 부분과 객체가 서로 통신하는 접점 역할을 지원하게 되는데, 이는 개발코드에선 객체의 내부 구조를 모르더라도 인터페이스의 메서드 명만 알고 있으면 되기 때문이다
    - 이를 통해 얻을 수 있는 장점은 해당 메서드를 통해 나오는 결과물을 알고 있기 때문에 다른 팀의 작업을 기다리고 있지 않아도 되며, 또한 해당 객체가 수정될 경우 개발 코드 부분은 수정을 하지 않아도 된다.
    - 부가적으로 객체를 파일에 쓰기 위해 Serializable 인터페이스를 구현하거나, Collections.sort()를 하기 위해서 Comparable 인터페이스를  상속하는 것, Cloneable 을 구현하는 것처럼 특정 작업을 하겠다라는 "Mark"역할을 해주기도 한다

7. Wrapper Class의 사용이유를 아나요?
    - 기본 data 타입은 객체가 아니어서 Object로 받는 다형성을 지원할 수가 없다. 하지만, 메서드에서 실재로 기본데이터 타입을 다형성으로 넘겨주어야 하는 경우가 빈번히 발생하는데 이때, 기본 데이터 타입을 객체로 변환시켜 전달하기 위해 사용되며 최근에는 AUTO Boxing, AUTO UnBoxing이 지원된다
    - Wrapper class들은 불변이다. 내부 값을 바꾸고 싶으면 새로 만들어야 한다

8. 컬렉션프레임워크(CollectionFramework)에 대해 아는만큼 말해 보시오.
    - Collection 인터페이스    
    - List 인터페이스 : 배열과 유사하되, 추가할때마다 자동으로 Boundary를 늘려주는 구조로, 중복된 데이터를 허용하며, 순서가 존재한다.
        * ArrayList : 배열로 구현됬으며, 인접해 있기 때문에 데이터 조회에 매우 빠르다 하지만, 빈번한 삽입, 삭제시 새로 배열을 만들고 데이터를 옮겨야 하기 때문에 LinkedList에 비하여 속도가 느리다.
        * LinkedList : 링크 구조로 되어 있기 때문에 조회는 ArrayList에 비해 느리지만, 삽입 삭제시 링크를 끊고 새로 추가되는 데이터에 링크만 연결하면 되기 때문에 삽입, 삭제에 유리하다.
        * Vector : 구현 방식은 ArrayList와 유사하지만 Vector를 개선한 것이 ArrayList이다. 또한 Vector의 경우에는 ArrayList와 달리 Synchronized(동기화)가 걸려 있어 여러 쓰레드에서 동시에 접근할 수 없다.

    - Set 인터페이스 : 집합처럼 중복된 데이터를 허용하지 않으며, 순서가 없다. 또한, 객체 내부의 중복된 데이터를 배제하고 싶은 경우 Object 클래스의 equals 메서드와 hashCode 메서드의 재정의가 반드시 필요하다.
        * HashSet
        * TreeSet : 순서가 있는 HashSet으로 이진 트리 구조로 만들어 졌다. 순서에 맞게 정렬되어 저장되기 위해서 Comparable을 구현해야한다.

    - Map 인터페이스 : key와 value 쌍으로 데이터를 저장하며, key는 중복될 수 없고, value는 중복 저장이 가능하다.
        * HashMap
        * TreeMap
        * Properties : key value 쌍으로 저장되지만 value의 타입이 String만 가능하다.
        * Hashtable : HashMap과 구조는 같으며, 단지 Synchronized(동기화) 되어져 있다는 점이 다른점이다.

9. 오버로딩과 오버라이딩의 차이?
    - 오버로딩 : 메서드 명은 동일하지만, 매개 변수 타입과 개수를 다르게 해 선언하는 방식
    - 오버라이딩 : 상속한 자식에서 부모의 메서드를 재정의하는 방식

10. private, protected, public, default 제어자에 대해 설명해 보시오
    - private : 같은 class 내부에서"만" 접근이 가능하다.
    - public : 어디서든 자유롭게 접근이 가능하다.
    - protected : 같은 class 내부 + 상속받은 자식에서는 부모 class에 접근이 가능하다.
    - default(package) : 아무 것도 선언하지 않은 경우로 같은 패키지 내부에서만 접근이 가능하다.

11. 자바의 제네릭이란??
    - 클래스 내부에서 사용할 데이터 타입을 인스턴스(객체) 생성시에 결정짓는 방식

12. 자바의 JVM의 역할에 대해서 설명해 보시오(메모리 종류 포함)
    - Java Virtual Machine, JAVA와 OS 사이에서 중계자 역할, JAVA가 OS에 구애받지 않고 재사용을 가능하게 해 줌
    - Class Loader: 컴파일 된 class 파일들을 Runtime Data Area에 적재
    - Execution Engine: Class Loader에 의해 적재된 클래스들을 기계어로 변경해 명령어 단위로 실행 (명령어를 하나하나 실행하는 인터프리터 방식과, JIT - 적절한 시간에 전체 바이트 코드를 네이티브 코드로 변경해서 Execution Engine이 네이티브로 컴파일된 코드를 실행해서 성능을 높이는 방식이 있음)
    - Garbage Collector: 힙 메모리 영역에 생성된 객체들중 참조되지 않는 객체를 찾아서 제거. GC중엔 다른 모든 스레드가 일시정지
    - 메모리 영역은 Runtime Data Area 속의 클래스, 힙, 스택, Native 메서드, PC레지스터로 구성
        * 클래스 영역: Method영역, Code 영역, Static영역 등으로 불림
            + Field Information: 멤버변수의 이름, 데이터 타입, 접근제어자에 대한 정보
            + Method Information: 메서드의 이름, 리턴타입, 매개변수, 접근제어자에 대한 정보
            + Type Information: 타입의 속성이 Class인지 Interface인지 여부 저장, Type의 전체 이름(패키지먕 + 클래스명), Type의 Super class의 전체이름, 접근제어자 및 연관된 interface의 정보
            + 상수풀: Type에서 사용된 상수들이 저장. 문자상수, 타입, 필드, Metho의 symbolic reference도 상수에 저장
            + class variable: static 변수, 모든 객체가 공유, 객체 생성 없이 접근 가능
            + Class 사용 이전에 메모리 할당: final class변수의 경우 상수로 치환되어 상수풀에 저장
        
        * 스택: 메서드 호출시마다 각각의 스택 프레임(메서드만을 위한 공간)이 생성, 메서드 안에서 사용되어지는 값들을 저장, 호출된 메서드의 메개변수, 지역변수, 리턴값, 연산시 일어나는 값들을 임시 저장
        * 힙: new 연산자로 생성된 객체와 배열을 저장하는 공간, 클래스 영역에 로드된 클래스만 생성가능, GC에 의해 관리되는 영역
            + Permanent Generation: 생성된 객체들의 주소값이 저장되는 공간
            + New Area: Eden(객체들이 최초로 생성되는 공간), Suvivor(Eden에서 참조되는 갹체들이 저장되는 공간)
            + Old Area: New Area에서 일정 시간 이상 참조되는 객체들이 저장되는 공간

        * Native 메서드: 자바외의 다른 언어에서 제공되는 메서드들이 저장되는 공간
        * PC레지스더: Thread들이 생성될때마다 생성되는 공간, Thread가 어떤 부분을 어떤 명령으로 실행할지에 대한 기록, 현재 실행되는 부분의 명령과 주소를 저장

13. JDBC는 무엇인가?
    - 자바를 이용한 데이터베이스 접속과 SQL 문장의 실행, 그리고 실행 결과로 얻어진 데이터의 핸들링을 제공하는 방법과 절차에 관한 규약
    - 자바 프로그램 내에서 SQL 문을 실행하기 위한 자바 API
    - SQL과 프로그래밍 언어의 통합 접근 중 한 형태
    - JAVA는 표준 인터페이스인 JDBC API를 제공
    - 데이터베이스 벤더, 또는 기타 써드파티에서는 JDBC 인터페이스를 구현한 드라이버(driver)를 제공한다.

14. Stream
    - SteamAPI는 Java의 Collection에서의 연속된 데이터의 반복 연산을 for문 등을 쓰지 않고, 추상화된 메서드를 통해 무엇(What)을 할 것인지 정의. 즉 FP이다. 스트림을 생성하는 최초연산, 중간의 로직을 구성하는 중간연산, 결과물을 처리하는 최종연산으로 나뉜다. 중간연산의 리턴값은 스트림으로, 계속해서 메서드 체이닝을 해 나갈 수 있다. 최종연산의 리턴값은 스트림이 아니며, 최종연산이 수행되지 않는다면 중간연산 역시 수행되지 않는다.

15. synchronized, volatile, atomic class 차이
    - 셋 모두 thread safe(어떤 함수나 변수, 객체가 여러 스레드에 의해 동시에 접근이 이뤄져도 프로그램의 실행에 문제가 없음)를 만들기 위해 사용
    - volatile는 CPU의 캐시 메모리에 저장하지 않고 반드시 메인 메모리에 저장하기 때문에 변수의 가시성 문제를 해결. 하지만 항상 동시성 문제를 해결하는 것이 아니고, 하나의 스레드만 write를 하고 나머지의 스레드들은 read하는 상황에서만 최신의 값을 보장
    - Atomic 클래스의 경우는 여러 스레드에서 읽기 쓰기 모두 이용할 수 있다. (CAS)
        * CAS(compare-and-swap): CAS방식은 자신이 읽었던 변수의 값을 기억하고 있다가 변경을 완료하기 직전에 읽었던 변수의 값이 그대로인지 확인하고 아니라면 실행을 무산시키는 방식
    - synchronized 경우도 여러 스레드에서 읽기 쓰기 모두 이용할 수 있다. (Lock)

16. string, string buffer, string builder 차이
    - string: immutable, 불변, 한번 생성되면 할당된 메모리 공간이 변하지않음. + 또는 concat메서드를 통해 기존에 생성된 string을 참조하는게 아니라 새로운 문자열을 만든후 그 객체를 참조하도록 함. Thread safe
    - stringbuffer: 각 메서드별로 synchronized, 멀티스레드 환경에서의 동기화 지원
    - stringbuilder: 동기화 미지원

17. string 은 메모리의 어느 영역에?
    - new 를 통해 만들어지면 heap영역, 리터럴을 사용해 만들어지면 Permanent Generation의 string constant pool에 존재 ( ~ 1.6 )
    - 이젠 똑같이 heap 영역

18. map, flatMap차이(stream)
    - map: 단일 스트림안의 요소르 원하는 특정 형태로 변환
    - flatMap: 스트림의 형태가 배열과 같을떄, 모든 원소를 단일 원소 스트림으로 반환 가능

19. Exception, Error 차이
    - Error : 시스템에 비정상적인 상황이 생겼을때 발생(컴파일 에러 등), 시스템 레벨에서 발생하는거라 미리 예측해 처리할수 없기 때문에 오류에 대한 처리는 신경 안써도 됨
    - Exception : 개발자가 구현한 로직에 의하여 예기치 않았던 이상 상태가 발생하여 수행 중인 프로그램이 영향을 받는 것. 예를 들면, 연산 도중 넘침에 의해 발생한 끼어들기 등이 이에 해당한다
        + Checked Exception: Exception의 하위클래스들, throws에 명시 해야함(혹은 try-catch), 반드시 예외 처리를 해야함, 복구가 가능하며 복구하리라 여겨짐, 트랜잭션 롤백 안됨, IOException, SQLException
        + Unchecked Exception: Exception의 하위인 Runtime Exception의 하위 클래스들, throws에 명시안함, 예외 처리 안해도됨, 복구가 불가능함, 개발자가 만든 논리 오류, 트랜잭션 롤백, NPE, IllegalArgumentException
    
    - 프로그램이 실행 중 어떤 원인에 의해서 오작동을 하거나 비정상적으로 종료되는 경우를 프로그램 오류라 하고, 프로그램오류에는 에러(error)와 예외(exception) 두 가지로 구분할 수 있다.
    - 에러는 메모리 부족이나 스택오버플로우와 같이 발생하면 복구할 수 없는 심각한 오류이고, 예외는 발생하더라도 수습할 수 있는 비교적 덜 심각한 오류이다. 이 예외는 프로그래머가 적절히 코드를 작성해주면 비정상적인 종류를 막을 수 있다.

20. Java lambda
    - 람다식이란 익명 함수를 생성하기 위한 식, 함수형 인터페이스를 구현하는 모습으로 사용 
    - 메소드의 구현이 간결해지고 가독성이 올라가며, 함수형 프로그래밍을 바탕으로 병렬 프로그래밍이 가능, 지연 연산으로 향상됭 퍼포먼스
    - 하지만 람다식이 남발되면 오히려 가독성이 떨어지며, 람다식을 재귀로 활용하는경우 까다롭다는 단점
    - ```( 매개변수 ) -> { 실행문 }``` 
    - SAM: 1개의 추상메서드를 가지고있는 인터페이스, 함수형 인터페이스라고도 함. 자바의 람다식은 함수형 인터페이스로만 접근, 람다식으로 만든 객체에 접근하기 위해 사용, Runnable, Supplier, Consumer등이 이에 해당
    
    ```java
    public interface FunctionalInterface {
        public abstract void doSomething(String text);
    }

    FunctionalInterface func = text -> System.out.println(text);
    func.doSomething("do something");
    ```

21. JVM, JRE, JDK
    - JVM: 자바 가상머신, 컴파일된 바이트코드 실행, 운영체제와 독립적으로 동작하기 위해 필요
    - JRE: 자바 구동 환경, JVM + 시스템라이브러리
    - JDK: 자바 개발 키트, JRE + 컴파일러, 디버거 등의 개발도구

22. 영속성, JDBC, MyBatis, JPA, Hibernate, Spring Data JPA
    - 영속성: 데이터를 생성한 프로그램이 종료되더라도 사라지지 않는 데이터의 특성. 영속성을 갖지 않는 데이터는 메모리상에서만 존재하기 때문에, 프로그램이 종료되면 모두 잃어버림. 따라서 파일시스템, DB등을 이용해서 데이터를 영구 저장해서 영속성을 부여해야함
    - 프로그램 아키텍처에 영속성을 부여해주는 계층이 Persistence Layer인데 Persistence Framework를 사용해서 구현
    - Persistence Framework에는 ORM, SQL Mapper가 존재
    - SQL Mapper
        * SQL 문장으로 직접 데이터베이스를 다룸. SQL을 명시 해줘야함
        * 필드를 매핑시키는데에 목적이 있음
        * MyBatis
    - ORM
        * 데이터베이스 객체를 자바 객체로 매핑 함으로써 객체간의 관계를 바탕으로 SQL 자동생성
        * 관계형 데이터베이스의 관계를 객체에 반영시키는게 목적
        * JPA: Java Persistence API, 자바 어플리케이션에서 관계형 데이터베이스를 사용하는 방식을 정의한 인터페이스, 인터페이스일뿐 라이브러리가 아님
        * Hibernate: JPA의 구현체, 단순 JPA의 구현체이기 때문에, JPA를 사용한다고 해서 반드시 Hibernate를 사용할 필요는 없음
        * Spring Data JPA: JPA를 쓰기 편하게 만들어둔 모듈(ex> EntityManager 사용 대신에 Repository 사용), JPA를 추상화 한 것
    - JPA
        * Java ORM기술에 대한 API 표준 명세로, 관계형 데이터베이스의 관리는 표현하는 자바 API
        * javax.persistance 패키지로 정의된 API그 자체와, JPQL(Java Persistence Query Language), 객체/관계 메타데이터로 구성
        * 대표적인 구현체가 Hibernate
    - Hibernate
        * JPA의 구현체중 하나로, SQL을 직접 사용하지 않는다고 해서 JDBC API를 쓰지 않는게 아님. Hibernate 메서드 내부에서 JDBC API가 동작중
        * HQL(Hibernate Query Language)라는 쿼리 언어를 포함하는데, SQL과 매우 비슷할 뿐더러 객체지향적이라, 상속, 다형성, 관계등의 강점을 누릴 수 있음

23. Arrays.sort & Collections.sort
    - Arrays.sort: 배열을 정렬할때, TimeSort(Merge Sort + Insertion Sort)와 Dual Pivot Quick Sort(Quick Sort + Insertion Sort)를 사용
    - Collestions.sort: List를 정렬할때, 내부적으로 Arrays.sort를 사용

24. Comparable vs Comparator
    - Comparable: 정해진 기준으로 정렬할때 사용, java.lang 패키지에 있으므로 import 하지 않고 사용가능, 클래스의 public 메서드의 느낌이 강함, 비교 대상이 꼭 같은 타입일 필요가 없음, 다른 객체와의 비교를 위해 사용되는 메서드를 노출, compareTo(Object o1)
    - Comparator: 사용자가 원하는 기준을 커스텀해서 사용, java.util 패키지에 있어 유틸리티적인 성격이 강함, 비교 대상은 항상 같은 타입이여야함, 객체 자체가 아닌 비교 로직을 외부의 제 3의 객체에 위치 가능(Collestions.sort할때 Comparator 넣어주는것), compare(Objct o1, Object o2)
    - Collections.sort를 할때 Comparable을 구현한 List라면 Comparable에 정의된 순서로 정렬이 되지만, 이때 Comparator를 구현해 넣어주면 해당 Comparator에 정의된 순서로 정렬

25. jar vs war
    - jar: 자바 어플리케이션이 동작할 수 있도록 자바 프로젝트를 압축해놓은 파일
    - war: servlet 컨테이너에 배치할수있는 웹 어플리케이션 압축파일
    
26. GC 동작방식
    - GC는 사용하지 않는 객체를 메모리에서 제거하는 작업
    - 사용중인 객체를 메모리에서 제거 한다면, 프로그램이 정상적으로 실행되지 않을것이기 때문에 사용중인지 아닌지를 구분할 방법이 있어야함
    - 그래서 오래된 객체를 제거하는데 자바는 이 오래됨을 표현하기 위해 힙을 여러 영역으로 나눠둠
    - 처음 생성된 객체는 Young Generation의 일부인 Eden영역에 위치하는데, 이후 이 객체가 다른곳에서 참조되지 않으면 Minor GC가 발생하게 되고 메모리에서 제거됨
    - Eden에서 살아남은 객체는 또다른 Young Generation 의 일부인 Suvivor영역에 이동하게됨. Suvivor는 Suvivor1 과 Suvovir2가 있는데, Minor GC가 발생할때마다 Suvivor1에서 2로, Suvivor2에서 1로 이동하게 되며 그 과정에서 더이상 참조되지 않는 객체는 메모리에서 제고
    - Minor GC동안 Suvovir1,2를 오가며 살아남은 객체는 최종적으로 Old Generation으로 옮겨지며, Old Generation에 있다가 미사용된다고 식별된 객체는 Full GC때 메모리에서 제거됨
    
27. GC 방식
    - Serial GC: 순차적인 GC, single thread
    - Parallel GC: multi thread GC
    - Parallel Old GC: parallel GC를 조금 개선, Old GC 알고리즘이 개선됨
    - CMS GC: GC 과정에서 발생하는 STW(Stop-The-World) 시간을 최소화
    - G1 GC: 큰 힙 메모리에서 짧은 GC 시간을 보장하는 방법

28. JPA 영속성 컨텍스트
    - 영속성 컨텍스트
        * 영속성 컨텍스트란 Entity를 영구 저장하는 환경, EntityManager로 Entity를 저장하거나, 조회하면 EntityManager는 영속성 컨텍스트에 Entity를 보관하고 관리한다
        * 어플리케이션과 데이터베이스 사이에서 객체를 보관하고있는 가상의 DB같은 역할
        * 영속성 컨텍스트는 EntityManager(Session)을 생성할때 하나 만들어진다. 그리고 그 EntityManager를 통해 영속성 컨텍스트에 접근할 수 있고, 영속성 컨텍스트를 관리 할 수 있다
        * 여러 EntityManager에서 하나의 Entity에 접근 할 수도 있다

    - Entity 생명주기
        * new: 영속성 컨텍스트와 전혀 관계가 없는 상태. persist를 통해 merged로 변경
        * merged: 영속성 컨텍스트에 저장된 상태. detach, clear, close를 통해 detached로 변경되거나, remove를 통해 removed로 변경되거나 flush로 db에 반영, db에서 find로 찾아온 Entity도 merged 상태
        * detached: 영속성 컨텍스트에 저장되었다가 분리된 상태. merge를 통해 merged로 변경 
        * removed: 삭제된 상태. persist를 통해 merged로 변경되거나 flush로 db에 반영

    - 영속성 컨텍스트 특징
        * 엔티티를 식별자 값으로 구분하므로 식별자 값이 반드시 있어야함
        * 트랜젝션을 커밋하는 순간 영속성 컨텍스트에 저장된 엔티티를 DB에 반영하는데 이것을 flush라 부름
        * 1차캐시: 영속성 컨택스트 내부의 캐시가 있어, 영속 상태의 엔티티 조회 가능
        * 엔티티의 동일성 보장
        * 트랜젝션을 지원하는 쓰기 지연: 트랜젝션 커밋 전까지 SQL을 모아둿다가, 커밋할때 DB에 보냄

29. 식별 비식별 관계
    - 식별 관계: 외래키를 기본키로 사용하는 관계
    - 비식별 관계: 외래키를 기본키로 사용하지 않고, 일반 속성으로 취급하는 관계

30. 클래스 변수 vs 인스턴스 변수
    - 클래스 변수: class내에서 static 키워드를 붙여 선언한 변수. 한번 선언되면 해당 클래스의 모든 인스턴스가 같은 저장공간을 가리킴. 전역변수 라고도 함. 인스턴스 없이 함수내 호출 가능
    - 인스턴스 변수: class 내에서 선언되지만, static 키워드가 없어 인스턴스에 종속되므로, 인스턴스 생성시마다 새로운 저장공간이 할당되어 저장공간이 공유되지 않음

31. strong, soft, weak, phantom 레퍼런스
    - Strong 레퍼런스: ```MyClass obj = new MyClass()``` 일반적인 참조 유형. obj변수가 참조를 가지고 있는한 GC의 대상이 되지 않음.
    즉, ```obj = null``` 해야 GC의 대상이 됨
    - Soft 레퍼런스

        ```java
        Myclass ref = new MyClass();
        SoftReference<MyClass> softRef = new SoftReference<Myclass>(ref);
        //이 시점에 GC의 대상이 된다
        ref = null;
        //GC가 되지 않은경우 null이 아닌 기존 객체가 반환
        ref = softRef.get();
        ```

        * 대상 객체를 참조하는 경우가 SoftReference만 존재하는 경우 GC의 대상이 됨. JVM의 메모리가 부족한 경우에만 힙영역에서 제거 되고, 그렇지 않은 경우 제거되지 않음

    - Weak 레퍼런스

        ```java
        Myclass ref = new MyClass();
        WeakReference<MyClass> softRef = new WeakReference<Myclass>(ref);
        //이 시점에 GC의 대상이 된다
        ref = null;
        //다음 GC시 무조건 힙 메모리에서 제거, 제거되면 null반환
        ref = softRef.get();
        ```    

        * 대상 객체를 참조하는 경우가 WeakReference만 존재하는 경우 GC의 대상이 됨. 다음 GC시 무조건 힙메모리에서 제거
        * 톰캣의 ConcurrentCache 클래스에서 WeakHashMap을 사용함

    - Phantom 레퍼런스

        ```java
        MyClass ref = new MyClass();
        ReferenceQueue<MyClass> reqQueue = new ReferenceQueue<MyClass>();
        PhantomReference<MyClass> phantomRef = null;
        //팬텀 레퍼런스는 아래처럼만 생성 가능
        phantomRef = new PhantomReference<MyClass>(ref,refQueue);

        ref = null;

        System.gc();
        ```

        * 생성자에서 무조건 ReferenceQueue를 받음. GC가 실행되기전에 PhantomReference는 객체 내부의 참조를 null로 설정하지 않고 참조된 객체를 phantomly reachable로 만든이후에 ReferenceQueue에 enQueue된다
        * finalize를 대신해서 사용
    
    - GC가 객체를 처리하는 순서: soft -> weak -> finalize -> phantom -> 메모리 회수

32. Java Thread pool
    - Scheduled Thread pool: 1분에 한번씩 일을 시키기 위한 thread pool
    - fixed Thread pool: pool에 thread를 고정적으로 몇개를 예비로 둘지 정하는 방식
    - cached thread pool: 유기적으로 thread의 숫자가 증가하고 감소하는 방식

33. JNDI
    - Java Naming and Directory Interface
    - Java로 작성된 어플리케이션에 이름 지정 및 디렉토리 기능을 제공하는 API
    - 데이터베이스와 연결된 커넥션을 미리 만들어 저장해두고 있다가, 필요할때 저장된 공간(pool)에서 가져다 쓰고 반환하는 기법
    - 커넥션풀이 있기 때문에 사용자 요청시마다 드라이버 로드 & 커넥션 객체 생성 및 종료 같은 작업을 하지 않아도 됨




# Computer Sience

1. 프로세스(Process) 와 쓰레드(Thread)의 차이점에 대해 아는가?
    - 프로세스 : OS가 메모리 등의 자원을 할당해준 실행중인 프로그램을 가리킨다. 이때, 각각의 프로세스는 서로 메모리 공간을 독자적으로 갖기 때문에 서로 메모리 공간을 공유하지 못한다. 따라서 공유하기 위해서는 IPC(InterProcess Communication)과 같은 방식이 필요하다.
    - 프로세스의 동기화 방법: 세마포어
    - 쓰레드 : 쓰레드는 프로세스 내에서 프로세스의 자원을 가지고 실제로 일하는 "일꾼"과 같으며 각 쓰레드는 독자적인 Stack 메모리를 갖고 그 외의 자원(메모리)는 프로세스 내에서 공유하게 된다.
    - 쓰레드의 동기화 방법: synchronized, volidate, Atomic 클래스, 뮤텍스, 락

2. 디자인 패턴 아는 것?
    - 싱글톤(SingleTone Pattern) : 대표적으로 Calendar 객체나 dataSource 객체처럼 객체가 하나만 생성되어야 하는 경우 전체 코드에서 하나의 객체만 존재할 수 있도록 이미 생성된 객체가 있으면 그 객체를 사용하도록 하는 방식입니다.
    - 팩토리 패턴(Factory pattern) : 객체간 의존성을 줄이기 위해 객체의 생성과 데이터 주입만 담당하는 Factory Class를 정의하고 개발 코드 부분에서는 생성된 객체를 가져다 사용함으로서 의존성을 줄이는 방식입니다.
    - 옵저버 패턴(Observer Pattern) : 기후 정보처럼 RSS 수신시 하나의 객체가 변하면 다른 객체에 객체가 변했다는 사항을 알려주어야 할 경우에 주로사용됩니다.
    - MVC 패턴
        * Model : data 처리와 접근을 담당(Java Bean)
            + Bean: 자바에서의 POJO(Plain Old Java Object)로, XML 설정파일을 통한 생명주기, 종속성 등의 메타데이터를 가지고 스프링 컨테이너에서 생성된 객체이다. 컨테이너에서 생성되었다는 점을 제외하면 일반 자바객체와 같다.
        * View : Client에 보여지는 화면을 담당(JSP or FE)
        * Controller : Model과 View를 제어(Java Class)
        * 3가지 부분으로 나눔으로서, 데이터와 화면간의 의존관계를 벗어날 수 있게하는 개발 기법입니다.

3. DataBase에서 Index란?
    - Table에 대한 동작 속도를 높여주는 자료구조로서 빠른 검색을 가능하게 해준다
    - 지정한 칼럼들을 기준으로 메모리영역에 목차를 생성 하는것
    - update, insert, delete의 성능이 희생되는 대신 select는 빨라질것
    - 인덱스 키는 길수록 성능상에 이슈가 있음
    - 1개의 컬럼으로만 인덱스를 할것이면 중복도가 낮은(카디널리티카 높은)걸 잡아야 하며, 여러개를 하더라도 카디널리티 순으로 해야함
    - 인덱스 자료구조
        * Hash Table: 컬럼의 값으로 생성된 해시를 기반으로 인덱스 구현, 시간복잡도가 O(1)이라 매우 빠름, 부등호와 같이 연속된 데이터를 위한 순차 검색은 안됨
        * B+ Tree: 자식 노드가 2개 이상인 B-Tree를 개선, B-Tree의 리프노드들을 링크드리스트로 연결하여 순차 검색을 용이하게 함, 시간복잡도가 O(logN)이지만 자주 사용
    

4. Git에 대해서 아는대로 설명해 보시오.
    - 분산 버전 관리 시스템
    - 매우 빠른 속도와 더불어 SVN과 달리 서버에만 저장소가 있는것이 아니라 로컬과 서버 모두에 저장소가 있는것이 특징
    - 로컬에도 저장소가 있기 때문에, 네트워크가 끊겨도 작업이 가능하다

5. ‘데드락’ 이란 무엇이고 이를 해결하기 위한 방법을 설명해 보시오.
    - 프로세스가 자원을 얻지못해 다음 처리를 하지 못하고 있는 상태. 교착상태
    - 데드락 발생조건은 4가지를 모두 만족해야 되기 때문에, 이들중 하나라도 만족하지 못하게 만들면 데드락 발생 X
        * 상호배제: 자원은 한번에 한 프로세스만 사용
        * 점유대기: 최소한 하나의 자원을 점유하고있으면, 다른 프로세스에 할당되어 사용하고있는 자원을 추가로 점유하기위해 대기하는 프로세스 필요
        * 비선점: 다른 프로세스가 사용중인 자원을, 그 사용이 끝날때까지 뺏을수 없어야함
        * 순환대기: 프로세스집합에서 p0는 p1이 소유한 자원을, p1은 p2가 소유한 자원을... pn은 p0가 소유한 자원을 요구해야 한다

6. ‘에자일’ 방법론에 대해서 아는가?
    - 기존 폭포수모델과 달리 문서보다는 동작하는 소프트웨어에 중점을 두어, 일정한 주기를 가지고 동작하는 소프트웨어를 계속 만들어내며, 그때 그때 필요한 요구를 수정하고 더해서 하나의 커다란 소프트웨어를 만들어내는 방법론
    - 애자일은 하나의 방법론이 아닌 개발 프로세스이며, 이에 속하는 방법론으로는 XP, 스크럼등이 있다

7. UML 그려본 적 있는가?
    - UseCase 다이어그램, 시퀀스 다이어그램, 클래스 다이어그램 등

8. DB 옵티마이저에 대해 아는가?
    - 사용자가 질의한 SQL문에대해 최적의 실행 방법을 결정하는것

9. 함수형 프로그래밍
    - 함수형 프로그래밍은 선언형 프로그래밍으로, 어떻게(How)가 아닌 무엇(What)을 정의한다. C, Java등의 언어는 명령형 프로그래밍이며, 알고리즘을 기술하고 목적은 기술하지 않는다. 선언형은 반대로 알고리즘은 기술하지 않고 목적 위주로 기술하며, 데이터의 입력이 주어지고 데이터의 흐름을 추상적을 정의하는 방식.

10. VO 란?
    - Value Object의 줄임말로, 값을 갖고있는 객체이다. 비즈니스 값을 가져올 때 사용하며, 보통 값을 수정할 수 없는 것으로 한다. DTO와 혼용해서 쓰기도 한다.

11. DTO 란?
    - Data Transfer Object의 줄임말로, VO와 같이 값을 갖고 있는 객체이다. VO와의 차이점은 DB로 치자면 하나의 인스턴스로, 데이터 핸들링에 사용되는 객체이다. DTO를 통해 데이터를 전달할 수 있다.

12. DAO 란?
    - Data Access Object의 줄임말로, 실제 DB에 접속하는 객체이다. Service와 DB사이에서 가져온 데이터를 엔티티로 변환시켜 가져온다. 대부분의 CRUD API를 제공한다.

13. PCB
    - Process Control Block의 약자로, 프로세스 제어 블록이다. 프로세스에 대한 중요한 정보를 저장하고 있다. 운영체제가 프로세스를 표현한 것이라고도 한다. 프로세스 생성시 만들어지며, 주기억장치에 유지된다. 문맥전환 등 다른 프로세스를 처리해야 할 때, PCB에 현재 상태를 저장함으로써 나중에 그 작업 상태를 불러와 작업 재개가 가능해진다. PID, 상태, 다음 명령어 주소 등의 정보가 저장됨.

14. PC
    - Program Counter의 줄임말로, 다음에 실행될 명령어의 주소가 들어있는 레지스터이다. 명령어가 인출되면, 자동으로 다음 명령어를 가리키도록 주소값이 증가된다.

15. 캐시메모리
    - CPU의 레지스터와 메모리 사이에서, 캐싱을 통해 병목 현상을 완화하는 것을 말한다.

16. 멀티 스레드 VS 멀티 프로세스
    - 이 두 가지는 실행 단위를 구분한다는 점은 같지만, 멀티 스레드는 자원을 덜 소모하는 대신 하나의 스레드가 비정상적인 오류를 일으키면 다른 스레드도 종료될 수가 있다는 점과 동기화 문제를 안고 있다. 멀티 프로세스는 자원을 공유하지 않기에 서로간 통신이 멀티 스레드보다 불편하고, CPU 자원을 더 많이 소모한다. 결국 상황에 맞게 골라서 써야한다.

17. CPU 스케줄링 방법
    - 스케줄링 대상은 Ready Queue에 있는 프로세스 대상이다.
    - FCFS (First Come First Served) : 먼저 온 녀석이 먼저 스케줄링을 받음. 중간에 반환하지 않는 비선점형이며, 시간이 긴 프로세스가 먼저 오면 효율성이 떨어짐
    - SJF (Short Job First) : 늦게 오더라도 수행시간이 짧은 프로세스에 먼저 할당. 이렇게 되면 수행시간이 긴 프로세스는 영원히 할당받지 못할 수도 있음(Starvation). 수행시간(CPU Burst Time)은 알지는 못하고 예측만가능
    - SRT (Short Remaining Time) : 현재 프로세스의 수행시간이 끝나는 시간보다 나중에 오는 프로세스의 수행시간 완료 시간이 더 짧다면, 그 즉시 그 프로세스에게 CPU를 할당. 선점형 스케줄링. Starvation과 CPU 수행 시간을 측정할 수 없다는 문제가 있음
    - 우선순위 : 정수로 표현된 우선순위가 더 높은 프로세스에게 할당한다. 선점형 방식과 비선점형 방식으로 나눌 수 있는데, 선점형 방식은 우선순위가 높은 프로세스가 도달하면 그 즉시 그 프로세스에게 CPU를 할당. 비선점형 방식은 Ready Queue의 맨 앞에 그 프로세스를 등록. Starvation과 CPU를 사용못하는 프로세스를 CPU가 무한 대기하는 상태가 있을 수 있음. 오래 기다렸을 경우 우선순위를 높이는 Aging을 통해 해결 가능.
    - Round Robin : 현대적인 CPU 스케줄링으로, 각 프로세스는 동일한 CPU 할당 시간을 갖게 됨. 할당시간 만료시 ready queue 맨 뒤에 가서 줄섬. CPU의 사용시간이 제각각일 때 효율적. 반응 속도가 빨라지며, 공정한 스케줄링. 주의할 점은 할당하는 시간(time quantum)이 너무 길다면 FCFS와 다를게 없음. 너무 작다면 잦은 컨텍스트 스위칭이 발생.

18. 단편화
    - 단편화란 메모리 상에서 적재되고, 해제되는 과정에서 발생하는 메모리 사이의 사용하지 못할 정도로 작은 빈 공간이다. 크게 외부 단편화와 내부 단편화로 나뉜다. 외부 단편화는 프로세스와 프로세스 사이에 발생하는 빈 공간이고, 내부 단편화는 프로세스 안에서 발생하는 빈 공간이다. 외부 단편화는 메모리를 다시 재정렬하는 압축을 통해 해결할 수 있지만, 효율이 좋지 않다.
    - First Fit : 메모리를 할당할 때, 가장 먼저 발견한 곳에 집어넣음
    - Best Fit : 메모리를 할당할 때, 사용 가능한 공간 중 가장 작은 곳에 집어넣음(정렬 필요)
    - Worst Fit : 메모리를 할당할 때, 사용 가능한 공간 중 가장 큰 곳에 집어넣음(정렬 필요)
    - 공간 효율성 : Best Fit > First Fit > Worst Fit
    - 시간 효율성 : First Fit > Best Fit = Worst Fit

19. 가상 메모리
    - 가상 메모리는 기존의 물리 메모리를 물리 메모리와 논리 메모리로 나눔으로써 더욱 효과적으로 쓰기 위한 개념이다. 논리 메모리 테이블은 물리 메모리와 보조기억장치 메모리와 매핑되어 있으며, 프로세스는 가상메모리를 물리 메모리처럼 인식하고 사용하게 된다. 이전에는 가상 메모리는 보조기억장치를 주기억장치처럼 쓰게 하는 것으로 알고 있었는데, 이번에 다시 정리하게 되었다.

20. 페이징
    - 외부 단편화의 압축 작업을 해소하기 위한 방법론으로, 물리 메모리는 Frame, 논리 메모리는 Page라는 고정 크기의 블록으로 나눈다. 프로세스를 페이지 단위로 나눈 뒤에, 사용하지 않는 영역을 보조기억장치에 적재한다. 이를 페이징 되었다고 하는데, 만약 이 페이징 된 영역에 접근해야 하면 페이징 폴트를 발생시킨 후 메모리에 적재시킨다(요구 페이징). 페이징된 정보는 페이징테이블에 저장된다. 단점으로는 내부 단편화가 발생할 수 있다.

21. 세그멘테이션
    - 메모리를 페이지와는 다르게 가변 크기의 세그멘테이션으로 나눈다(물리 메모리 블럭 크기와 다르다). 나누는 시점은 메모리를 사용하게 되는 시점이다. 각 세그멘테이션은 스택, 데이터, 힙, 코드 영역 등으로 나뉘게 된다. 나뉜 세그멘테이션은 시작 주소값과 길이 값이 세그멘테이션 테이블에 저장된다. 자주 사용하면 외부 단편화가 발생할 수 있다.
    - 보통 페이징과 세그멘테이션 둘다 함

22. 페이지 교체 알고리즘 종류
    - FIFO (First In First Out) : 말 그대로 먼저 들어온 페이지를 먼저 내보낸다. 간단한 알고리즘이지만, 페이지의 중요도를 따지지 않기 때문에 초기 변수가 담긴 페이지를 내려버리는 등 여러 문제를 초래할 수 있다.
    - 최적 페이지 교체 (Optimal Page Replacement) : 앞으로 가장 사용되지 않을 페이지를 계산하여 교체한다. 다만 모든 프로세스의 계획을 파악하기가 쉽지 않기 때문에, 어떤 페이지를 교체해야 하는가의 알고리즘을 구현할 때 어려움이 있다.
    - LRU (Last Recently Used) : 가장 나중에 사용된 페이지를 교체한다. FIFO보단 낫고 OPT보단 못하다.
    - LFU (Least Frequently Used) : 가장 덜 사용된 페이지를 교체한다. 활발한 페이지는 사용이 많이 되었을거라는 가정하에 만든 알고리즘. 초기에 많이 사용되었다가 지금은 사용되지 않는 페이지의 경우 교체가 이루어지지 않는다는 문제가 있다.
    - MFU (Most Frequently Used) : 가장 많이 사용된 페이지를 교체한다. 가장 적게 사용된 페이지가 최근에 올라오고 계속 사용될 것이라는 가정. 잘 쓰이지 않는다

23. TDD란
    - 테스트케이스를 먼저 만들고 그 테스트를 통과하게끔 코드를 짜는 방법
    - 품질을 어느정도 확보 할 수 있고, 리팩토링이 용이해지며, 자동화 프로세스와 맞물려 CI/CD등에 필요

24. Block & Non Block
    * 블로킹: 자신의 수행이 끝날때가지 제어권을 자신이 가지고있음
    * 논블로킹: 자신이 호출되었을때 제어권을 바로 자신을 호출한쪽에 넘기며, 자신을 호출한쪽에서 다른일을 수행 할 수 있게 함
    
25. DB Transaction 사용하는 이유
    - 트랜잭션(Transaction)은 데이터베이스의 상태를 변환시키는 하나의 논리적 기능을 수행하기 위한 작업의 단위 또는 한꺼번에 모두 수행되어야 할 일련의 연산
    - 트랜잭션은 DB 서버에 여러 개의 클라이언트가 동시에 액세스 하거나 응용프로그램이 갱신을 처리하는 과정에서 중단될 수 있는 경우 등 데이터 부정합을 방지하고자 할 때 사용
    - 하나의 트랜잭션은 Commit되거나 Rollback된다
    - 트랜잭션 성질 4가지
        * Atomicity(원자성): 트랜잭션의 연산은 데이터베이스에 모두 반영되든지 아니면 전혀 반영되지 않아야 함. 트랜잭션 내의 모든 명령은 반드시 완벽히 수행되어야 하며, 모두가 완벽히 수행되지 않고 어느하나라도 오류가 발생하면 트랜잭션 전부가 취소되어야 함
        * Consistency(일관성): 트랜잭션이 그 실행을 성공적으로 완료하면 언제나 일관성 있는 데이터베이스 상태로 변환. 시스템이 가지고 있는 고정요소는 트랜잭션 수행 전과 트랜잭션 수행 완료 후의 상태가 같아야함
        * Isolation(독립성,격리성): 둘 이상의 트랜잭션이 동시에 병행 실행되는 경우 어느 하나의 트랜잭션 실행중에 다른 트랜잭션의 연산이 끼어들 수 없고, 실행중인 트랜잭션은 완전히 완료될 때까지 다른 트랜잭션에서 수행 결과를 참조할 수 없다
        * Durablility(영속성,지속성): 성공적으로 완료된 트랜잭션의 결과는 시스템이 고장나더라도 영구적으로 반영되어야 한다

26. 정렬 알고리즘 정리
    - 버블정렬: 시간 O(n^2), 공간 O(n), 주어진 배열의 마지막 위치에 있는 요소를, 정렬되지 않은 직전 요소부터 첫 요소에 이르기까지 비교해 정렬 순서가 맞지 않은 모든 case에 대해 요소 위치를 바꿔줌. 이를 요소 수만큼 반복
    - 선택정렬: O(n^2), 공간 O(n), 요소 위치 변경 횟수를 줄여 버블정렬을 일부 개선한 알고리즘. 정렬 순서가 맞지 않으면 무조건 자리를 바꿔줬던 버블정렬과 달리, 1회 iteration마다 최소값(혹은 최대값)을 찾고 단 한번만 해당 요소 위치를 바꿔줌
    - 삽입정렬: O(n^2), 공간 O(n), 모든 요소에 대해 앞에서부터 차례대로 이미 정렬된 배열(sorted list)과 비교하여 sorted list 내 자신의 위치를 찾아 삽입함으로써 정렬을 완성, 입력데이터가 이미 정렬된 상태라면 O(n)의 빠른 속도를 보이지만 그렇지 않은 경우 다른 기법을 적용하는 것이 나음
    - 합병정렬: O(nlogn), 공간 O(2n), 스트를 잘게 쪼갠 뒤 둘씩 크기를 비교해 정렬하고 분리된 리스트를 재귀적으로 합쳐서 정렬을 완성, 분할된 리스트를 저장해둘 공간이 필요해 메모리 소모량이 큰 편
    - 힙정렬: O(nlogn), 공간 O(n), 모든 노드가 힙 속성(각 노드의 값이 자신의 자식노드 값보다 큰 이진트리)을 만족하도록 재귀적으로 트리 구조를 만들어 정렬을 완성
    - 퀵정렬: O(nlogn), 공간 O(n),피봇값을 기준으로 피봇 앞에는 피봇보다 작은 값, 뒤에는 큰 값이 오도록 하여 리스트를 분할하고, 분할된 두 개 리스트 각각에 재귀적으로 이 과정을 반복해 정렬을 완성. 합병정렬과 달리 주어진 배열을 임의로 나누지 않기 때문에 대개는 효율적이지만, 피봇값이 잘못 선택되면 O(n^2)이 될 수도 있음
    - 카운팅정렬: O(n+k), 공간 O(k),입력값의 빈도를 세어서 이를 결과리스트의 인덱스로 활용, 입력리스트의 요소값을 해당하는 결과리스트 인덱스 위치에 채워 넣는 방식으로 정렬을 완성, 입력리스트의 최대값(k)이 커지면 복잡도가 크게 높아짐

27. DB Transaction 격리 수준
    - Read Uncommitted
        * 더티리드를 가능하게 하는 격리 수준
        * 더티 리드: 더티 페이지(메모리에는 변경이 되었지만, 디스크에는 아직 변경이 되지 않은 데이터)에 있는 데이터를 검색. 커밋 되지 않은 데이터를 리드하기 떄문에, 더티리드 후 더티페이지가 롤백되면 잘못된 데이터를 읽어온것
    
    - Read Committed(기본)
        * 더티리드를 방지해 잘못된 데이터를 읽어오는 경우가 발생하지 않게함. 단 이 격리 수준에서는 반복되지 않은 읽기가 발생할 수 있다
        * 반복되지 않은 읽기(Unrepeatable Read)
            * 1번 세션이 트랜젝션을 걸고 A 테이블에 대해 SELECT를 실행(아직 COMMIT은 되지 않은 상태)
            * 2번 세션에서 다시 A 테이블에 데이터를 UPDATE한다(바로 실행이 완료된다)
            * 1번 세션에 대해 다시 A테이블에 대해서 SELECT를 실행
            * 1번 세션을 COMMIT
            * 1번 세션의 처음 SELECT와 두번째 SELECT의 결과가 다르다. 이것이 반복되지 않은 읽기 이며, 트랜잭션중 데이터가 변경되면 큰 문제가 발생한다

    - Repeatable Read
        * 공유 잠금(SELECT를 통해 발생하는 잠금)이 걸려도 데이터의 변경을 막아줘 반복되지 않은 읽기의 문제점을 방지함. 하지만 팬텀 읽기(가상 읽기)의 문제가 발생
        * 팬텀 읽기(Phantom Read)
            * 1번 세션의 격리 수준을 REPETABLE READ로 변경
            * 1번 세션에서 트랜잭션을 걸고 A 테이블에 SELECT(COMMIT하지 않은 상태)
            * 2번 세션에서 A 테이블에 대한 UPDATE작업이 완료되지 못함(반복되지 않는 읽기 방지)
            * 2번 세션에서 A 테이블에 대한 INSERT 작업을 실행(바로 완료됨)
            * 1번 세션에서 A 테이블에 대한 SELECT(COMMIT하지 않은 상태)
            * 1번 세션을 COMMIT
            * 1번 세션의 첫번째, 두번쨰 SELECT의 로우 숫자가 다르다. 존재하는 데이터의 변경은 불가능 하지만 추가가 가능한 상황이 팬텀 읽기이다

    - Serializeable
        * 팬텀 읽기를 방지 할 수 있는 격리 수준으로, 공유 잠금이 걸린 테이블에 대한 데이터 변경, 추가 작업이 되지 않는다

    - Snapshot
        * Serializeable과 동일한 격리 수준을 보여주지만, 잠금이 걸린 테이블에 대한 데이터 변경, 추가작업이 가능하다
        * 잠금이 걸린 테이블에 대한 변경, 추가작업은 tempDB에 관리되며 잠금이 풀린 즉시 원 테이블에 작업이 이뤄진다

    - Read Committed Snapshot
        * Snapshot과는 달리, 커밋된 데이터에 대해서는 최신 데이터 버전으로 읽을 수 있는 격리 수준

28. 함수형 프로그래밍
    - 어떻게 할것인지(How)보다 무엇을 할것인지(What)에 포커스를 둠으로써, 거의 모든것을 순수 함수로 나누어 해결함으로, 작은 문제를 해결하기 위한 함수를 작성하여 가독성을 높이고 유지보수를 용이하게 해준다
    - 부수효과가 없는 순수 함수를 1급 객체로 간주하여 파라미터로 넘기거나 반환값으로 사용할 수 있으며 참조 투명성을 지킬수있다
        * 부수효과는 다음과 같이 변화가 발생하는 작업들
        * 변수의 값이 변경, 자료 구조를 제자리에서 수정, 객체의 필드값을 설정, 예외나 오류 발생으로 실행 중단 등
    - 순수 함수는 함수 자체가 독립적이며 Side effect가 없기 때문에 쓰레드 안정성을 보장 받을수있으며, 그로인해 병렬 처리를 동기화 없이 진행 가능
    - 1급 객체란 변수나 데이터 구조 안에 담을 수 있으며, 파라미터로 전달 가능하고, 반환값으로 사용할 수 있으며, 할당에 사용된 이름과 무관하게 고유한 구별이 가능하다
    - 참조 투명성이란 동일한 인자에 대해서 항상 같은 결과를 반환하는것을 말하며, 참조 투명성을 통해 기존의 값은 변경되지 않고 유지된다
    - Java에서 Java8 이후로 StreamAPI, 람다식, 함수형 인터페이스 등으로 함수형 프로그래밍을 지원. 그중 Stream API는 데이터를 추상화하고 처리하는데 자주 사용되는 함수들을 모아둠
    - 자바의 표준 함수형 인터페이스는 반환값과 인수값이 같은 Operator인터페이스, 인수와 반환값이 다른 Function 인터페이스, 인수를 하나 받아 boolean을 반환하는 Predicate 인터페이스, 인수를 받지않고 값을 반환하는 Supplier 인터페이스, 인수를 하나 받고 반환값은 없는 Consumer 인터페이스 등이 있다

29. 리눅스 쉘이란?
    - 운영체제상에서 다양한 운영체제 기능과 서비스를 구현하는 인터페이스를 제공하는 프로그램

30. 데이터베이스 정규화
    - 데이터베이스의 설계를 재구성하는 테크닉. 정규화를 통해 불필요한 데이터를 없앨 수 있고, 삽입, 갱신, 삭제시 발생하는 이상현상을 방지
    - 이상현상
        * 삭제 이상: 튜플 삭제시 같이 저장된 다른 정보까지 연쇄적으로 삭제
        * 삽입 이상: 튜플 삽입시 특정 속성에 해당하는 값이 없어 NULL을 입력해야하는 상황
        * 갱신 이상: 튜플 수정시 중복된 데이터의 일부만 수정됨
    - 1차 정규화: 각 Row마다 칼럼의 값이 1개씩 있어야함. 칼럼이 원자값을 가진다고도 함
    - 2차 정규화: 모든 테이블의 값이 완전 함수적 종속. 기본키중에 특정 컬럼에만 종속된 컬럼이 없어야 함
    - 3차 정규화: 모든 테이블의 값이 이행적 함수 종속이 없어야함. 기본키 이외의 다른 컬럼이 그 외 다른 컬럼의 값을 결정할수 없어야함
    - BCNF: 3차 정규형을 만족하면서, 모든 결정자가 후보키 집합에 속한 정규형
        * 후보키: 슈퍼키중에 최소성을 만족
        * 슈퍼키: 각 행을 유일하게 식별할 수 있는 하나 또는 그 이상의 속성들의 집합

31. NoSQL
    - 스키마 없음, 관계 없음
    - 데이터를 도큐먼트라 부름
    - 다른 구조의 도큐먼트를 같은 컬렉션(sql의 테이블)에 추가 가능
    - 일반적으로 도큐먼트는 json과 비슷한 형식, 관련 데이터를 동일한 컬렉션에 넣음
    - 데이터가 중복되기에 불안정한 측면이 있지만, 자주 변경되지 않는데이터에서 강점을 가짐
    - SQL이 수평확장이 안되는 대신(데이터가 관계적으로 저장 되므로), NoSQL은 가능
    - 정확한 데이터 구조를 알 수 없거나, 변경/확장 될 수 있는 경우, 읽기 처리를 자주하지만 데이터 변경은 자주 이뤄지지 않는 경우, db 수평 확장이 필요한 경우 유리

32. DB락의 종류 및 설정 레벨
    - 공유락: 트랜젝션이 읽기를 할때 사용하는 락. 같은 공유락 끼리는 동시에 접근 가능. 배타락의 접근을 막음
    - 배타락: 트랜젝션이 쓰기를 할때 사용하는 락. 데이터를 읽고 쓸수있음. 이 락이 끝나기전의 모든 접근을 막음. 배타락은 다른 트랜잭션이 수행되고 있는 데이터에 대해서 접근해 락을 걸 수 없음
    - 락 설정 레벨
        * 데이터베이스: 전체 DB 기준으로 락. 1개 세션이 하나의 DB에 접근. DB전체에 영향이 가므로 DB업데이트 같은 작업에서만 사용
        * 파일: 데이터베이스 파일 기준으로 락. 테이블과 같이 실제 데이터가 쓰여지는 물리적 저장소에 락이 걸리므로, 파일 전체를 백업할때 사용
        * 테이블: 테이블 기준으로 락. 전체 테이블에 대한 변경이 있을때 사용. DDL 사용할때 쓰이는 락
        * 페이지와 블럭: 파일을 구성하는 페이지와 블럭 기준으로 락
        * 컬럼: 컬럼 기준으로 락. 락 설정 및 해제시 리소스가 많이쓰여 자주 사용되지는 않음
        * 행: 행 수준의 락. 가장 많이 사용

33. DB 클러스터링 & 레플리케이션
    - 레플리케이션
        * 여러개의 DB를 권한에 따라 수직적인 구조로 구축하는 방식(Master - Slave)
        * 비동기 방식으로 노드들간의 데이터를 동기화
        * 비동기 방식으로 데이터가 동기화 되어 지연시간이 거의 없는 대신, 노드들간의 데이터가 동기화 되지 않아서 일관성 있는 데이터를 얻지 못할수도 있다
    - 클러스터링
        * 여러개의 DB를 수평적인 구조로 구축하여 Fail Over한 시스템을 구축하는 방식
        * 동기 방식으로 노드들간의 데이터를 동기화
        * 1개의 노드가 죽어도 다른 노드가 살아있어서 시스템을 장애 없이 운영할수있지만, 노드들간의 데이터에 동기화 하는 시간이 필요하므로 레플리케이션에 비해 쓰기 성능이 떨어짐 
        
34. 리눅스 기본 명령어
    - cd: 디렉토리 전환
    - pwd: 현재 디렉토리 출력
    - ls: 디렉토리 목록 확인
    - cp: 파일 혹은 디렉토리 복사
    - mv: 파일 혹은 디렉토리 이동(이름 변경시에도 사용)
    - mkdir: 디렉토리 생성
    - rm: 디렉토리 삭제
    - touch: 파일이나 디렉토리의 업데이트 일자를 현재 시간으로 변경(파일이 없다면 생성)
    - cat: 파일 내용 출력
    - head: 파일의 앞부분을 보고싶은 줄 만큼 출력
    - tail: 파일의 뒷부분을 보고싶은 줄 만큼 출력
    - find: 특정 파일이나 디렉토리 검색

# Network & Server & Spring Framework

1. 쿠키와 캐시(Cache)와 세션(Session)의 공통점과 차이점은?
    - 쿠키 : 브라우저를 사용하는 환경(로컬 컴퓨터에), 로그인정보같이 유저가 다시 서버에 요청하기엔 비효율적인 정보를 저장
    - 캐시 : 브라우저를 사용하는 환경(로컬 컴퓨터에), 서버에서 받은 데이터를 저장한 파일. 쿠키와 동일하지만 이미지처럼 재사용되거나 용량이 큰 리소스를 저장
    - 세션 : 세션은 서버에 저장되고 브라우저 단위로 관리된다. 쿠키나 캐시에 비해 보안성이 좋다.

2. Request 전송 방식에는 어떤 것들이 있는지 아시나요?
    - GET 방식 : 데이터 가져오기, SELECT, URL의 쿼리문자열에 데이터를 같이 전달하는 방식으로 데이터 길이에 제한이 있고, 보안에 취약하다.
    - POST 방식 : 데이터 삽입하기, INSERT, 바디 데이터를 넣어 보내기 때문에 보안에 조금 더 유리하고 데이터 길이에 제한이 없다. 하지만, Get에 비해 다소 느리다.
    - DELETE 방식 : RESTFUL에서 삭제 기능을 할 때 주로 사용된다.
    - PUT/PUSH 방식 : RESTFUL에서 수정 작업을 할 때 주로 사용된다.

3. RESTFUL이란?
    - REST란 REpresental State Transfer의 약자, 자원을 표현하여 상태를 전달한다는 뜻으로, 웹에 있는 자원을 HTTP를 통하여 직관적으로 전달하기 위한 간단한 인터페이스
    - REST API의 구성
        * 자원 - URI
        * 행위 - HTTP Method
        * 행위의 내용 - HTTP Message Pay Load

    - REST의 특징
        * Uniform Interface: URI로 지정한 리소스에 대한 조작을 통일되고 한정적인 인터페이스로 수행하는 아키텍처 스타일
        * Stateless: 무상태성, 작업을 위한 상태 정보를 저장하고 관리하지 않음. 세션정보나 쿠키를 별도로 저장하고 관리하지 않기 때문에 API는 단순히 들어오는 요청만 처리하면된다.
        때문에 서비스의 자유도가 높고 서버에서 불필요한 정보를 관리하지 않아 구현이 단순해짐
        * Cacheable: 캐시가능. HTTP라는 기존 웹표준을 그대로 사용하기 때문에, 웹에서 사용하는 기존 인프라를 그대로 활용이 가능하며, 이로인해 HTTP가 가진 캐싱기능을 할수있음
        * Self-descriptiveness: 자체 표현 구조로, REST API 메시지만 보고도 이를 쉽게 이해 할 수 있다
        * Client - Server: REST서버는 API제공, 클라이언트는 사용자 인증이나 컨텍스트를 직접 관리하는 구조로 각각의 역할이 확실하게 구분되어 서로 개발해야할 내용이 명확하고 의존성이 적음
        * 계층형 구조: REST서버는 다중 계층으로 구성될수있으며, 보안, 로드밸런싱, 암호화 계층을 추가해 구조상의 유연성을 둘 수 있고, PROXY, 게이트웨이 같은 네트워크 기반의 중간매체를 사용할수있다

    - REST API 디자인 가이드
        * URI는 정보의 자원을 표현해야 한다(리소스명은 동사보다는 명사를 활용)
        * 자원에 대한 행위는 HTTP Method(GET, POST, PUT, DELETE)로 포현한다 
        * / 구분자는 계층관계를 나타내는데 활용
        * URI의 마지막 문자로 / 를 포함하지 않는다
        * ```-```는 URI가독성을 높이는데 활용
        * _ 은 URI에 사용하지 않는다
        * URI엔 소문자가 적합하며, 파일 확장자는 URI에 포함하지 않는다


4. Spring에서 DI란 무엇인지 아시나요? IoC란? 
    - DI는 Dependency Injection(의존성 주입)의 약자로, 객체들 간의 의존성을 줄이기 위해 사용되는 Spring의 IOC 컨테이너의 구체적인 구현 방식입니다. 객체를 직접 생성하는 게 아니라 외부에서 생성한 후 의존 관계를 setter나 생성자 인수를 통해 주입하는 방식. 모듈간의 결합도가 낮아지고 유연성이 높아짐
    - Inversion Of Control, 제어의 역행이라는 뜻으로, 인스턴스의 생성 및 소멸을 개발자 대신 스프링 컨테이너가 한다. 그외 제어권을 프레임워크에서 가져간다는 말로도 쓰인다.
    - Spring에서는 객체가 생성된 이후 IOC 컨테이너에 의해 의존성이 주입되어, 의존성 객체의 메서드를 사용하는 방식으로, Spring Framework가 모든 의존성 객체들(Bean)을 만들어주고 필요한곳에 주입 시켜줌(DI). 제어의 흐름을 개발자가 컨트롤 하는게 아닌 Spring에 맞겨 처리하게 됨(IOC)
    - 의존성 객체(Bean)들은 기본적으론 싱글톤의 특성을 띄지만(Spring이 만들어주고 있어서), Prototype 빈은 매 요청시마다 생성됨

5. Spring의 AOP란?
    - AOP는 Aspect Oriented Programming 관점 지향 프로그래밍의 약자로, 기존의 OOP(객체 지향 프로그래밍)에서 기능별로 class를 분리했음에도 불구하 고, 여전히 로그, 트랜잭션, 자원해제, 성능테스트 메서드 처럼 공통적으로 반복되는 중복코드가 여전히 발생하는 단점을 해결하고자 나온 방식
    - 공통 코드를 "횡단 관심사"라 표현하며 개발코드에서는 비지니스 로직에 집중하고 실행시에 비지니스 로직 앞, 뒤 등 원하는 지점에 해당 공통 관심사를 수행할 수 있게 함으로서 중복 코드를 줄일 수 있는 방식입니다
    - Proxy 기반으로 어드바이스(횡단 관심사를 구현하는 Aspect의 메서드)의 대상 객체(얘도 결국 스프링 컨테이너에 등록된 빈)마다 프록시 객체가 만들어져서, 실행 시점에 프록시는 해당 객체 호출을 가로채고 재상 메서드에 적용할 어드바이스를 실행
    - ```@Aspect``` 어노테이션으로 Aspect를 지정하고 ```@Pointcut```으로 포인트컷 식을 지정한 후, ```@Before```, ```@After```, ```@Around``` 등의 어노테이션으로 어드바이스를 지정해서 설정

6. Servlet vs JSP
    - Servlet : 자바 언어로 웹 개발을 위해 만들어진 것으로, Container가 이해할 수 있게 구성된 순수 자바코드로만 이루어진 것 
    - JSP : html 기반에 JAVA 코드를 블록화하여 삽입한 것으로 Servlet을 좀 더 쉽게 접근할 수 있도록 만들어 진 것

7. WAS와 웹서버의 차이점은?
    - 웹서버: 웹 브라우저와 같은 클라이언트를 통해 HTTP요청을 받아, HTML과 같은 문서를 정적으로 처리해 반환
    - 웹 어플리케이션 서버: 웹서버 + 웹 컨테이너. HTTP를 통해 컴퓨터나 장치에 애플리케이션을 수행해주는 미들웨어
        * 웹 컨테이너: 자바 서블릿과 상호작용. 서블릿 API제공

    - 웹서버는 정적 데이터를 처리하고 웹 어플리케이션 서버는 동적 데이터를 처리
    - 웹서버를 앞단에두고 정적 문서 처리를 담당하게 한 후, 웹 어플리케이션 서버는 애플리케이션 로직만 수행하도록 하여 서버의 부담을 줄임

8. 비동기와 동기, 블록과 논블록
    - 동기: A라는 행위와 B라는 행위가 순차적으로 작동하면 동기. A가 B를 관찰하는 행위라면 동시에 일어나도 동기
    - 비동기: 인과 관계가 있는 작업 A,B가 동시에(혹은 순차적이지 않게) 실행되고 있다면 비동기. 다되면 콜백으로 알려줌
    - 블록: A라는 함수를 호출했을때 기대하는 모든 행위를 모두 끝마칠때까지 기다렸다가 리턴되면 블로킹
    - 논블록: A라는 함수를 호출했을때 기대하는 어떤 행위를 요청하고 바로 리턴되면 논블로킹
    - 동기와 비동기는 동시성에 관한 이야기 이고, 블로킹/논블로킹은 동시성과는 무관한 이야기

9. Spring Framework에서의 요청 처리 순서(브라우저부터 설명)
    - 클라이언트(브라우저)에서 URL로 접속하여 정보를 요청
    - DispatcherServler이 해당 요청을 받아, 해당 요청을 매핑한 컨트롤러가 있는지 확인
    - Handler Mapping에서 적절한 Controller에게 처리 요청
    - Controller 에서 해당 요청 처리 후, 결과를 출력할 View의 이름을 DispatcherServlet에게 반환
        * 이 과정에서 컨트롤러는 해당 요청을 처리할 적절한 Service를 사용 할 수 있고, 해당 Service는 DAO를 통해 DB와 접근도 할 수 있음. 이것이 MVC 패턴
        * 만약 ```@RestController```로 컨트롤러가 정의 되어 있다면, View로 출력되는것이아니라 Message Convertor에 적절한 메시지 형식 (application/json, text/plain)등으로 바뀌고 이것이 HTTPResponse에 직접 쓰여 반환되게 된다. 밑의 View 검색 절차는 필요하지 않다

    - DispatcherServelet에서 받은 View이름을 바탕으로 적절한 View를 ViewResolver를 통해 검색
    - ViewResolver가 처리 결과를 View에게 송신
    - View는 처리 결과를 담아 DispathcerServler에게 송신
    - DispathcerServlet이 클라이언트에게 최종 결과 출력



10. 컨테이너란
    - 프레임워크 안에서 인스턴스들의 생명주기를 관리하며, 생성된 인스턴스들에게 추가적인 기능을 부여한다. 내가 작성한 코드의 처리과정을 컨테이너에서 수행한다. 스프링 컨테이너는 스프링 프레임워크 핵심에 위치하여, DI를 통해 애플리케이션을 구성하는 컴포넌트들을 관리한다.

11. AJAX란?
    - Ajax란 좁은 의미로 클라이언트에서 서버가 비동기적으로 통신하는 기술
    - HTTP 요청 시 XMLHttpRequest라는 객체를 생성하여 수행한다.
    - request요청의 상태가 변할 때, readyState라는 플래그가 변하며, onreadystatechange라는 함수를 호출하게 된다.
    - readyState 상태 플래그
        * 0 : 객체 생성 완료, open()함수 호출 전
        * 1 : open()함수 호출 성공
        * 2 : send()함수 호출 성공
        * 3 : recv()함수 호출, 데이터 다운로드 중
        * 4 : Done, 모든 작업이 끝남

12. HTTP 요청 흐름 (웹브라우저에서의 요청)
    - 브라우저에서 먼저 URL에 적힌 값을 파싱하여, HTTP 요청 메세지를 만든다. 만든 메세지를 웹 서버로 전송하는데, 이때 웹 브라우저 직접 전송을 하는것이 아니라 OS에 보내주십쇼~ 하고 의뢰를 하게 된다. OS는 DNS서버를 조회해서 Host이름을 보내야 할 IP 주소로 변환하게 된다.
    - 프로토콜 스택(운영체제에 내장된 네트워크 제어용 소프트웨어, TCP/IP 계층)과 LAN 어댑터 에서 브라우저로부터 메시지를 받는다. 브라우저로부터 받은 메시지를 패킷 속에 저장한다. 그리고 수신 주소를 제어정보에 덧붙인다. 그 다음, 패킷은 LAN 어댑터에 넘긴다. LAN 어댑터는 패킷을 전기 신호로 변환시켜 LAN 케이블에 송출하게 된다.
    - 허브, 스위치, 라우터 에서 LAN 어댑터로부터 송신한 패킷을 수신한다. 라우터는 패킷을 ISP에 전달, 인터넷으로 들어가게 된다.
    - 액세스 회선, ISP : 액세스 회선이라는 것은 인터넷의 입구에 있는 통신 회선이다. 액세스 회선에 의해 통신사용 라우터(POP, Point Of Presence)까지 운반된다. POP를 거쳐 인터넷의 핵심부로 들어가게 된다. 고속 라우터들 사이로 목적지까지 패킷이 흘러가게 된다.
    - 방화벽, 캐시서버 : 인터넷 핵심부를 통과한 패킷은 목적지의 LAN에 도착하게 된다. 방화벽이 먼저 패킷을 검사한 후, 캐시서버로 보내서 웹 서버까지 갈 필요가 있는지 검사한다.
    - 웹 서버 : 패킷이 물리적 웹 서버에 도착하면, 웹 서버의 프로토콜 스택이 패킷을 추출하여 메시지를 복원하고, 웹 서버 애플리케이션에 넘긴다. 애플리케이션은 요청에 대한 응답 데이터를 넣어 클라이언트로 회송한다. 온 방식 그대로 전송되게 된다.

13. HTTP/HTTPS 차이
    - HTTP + SSL = HTTPS
    - HTTP는 평문 통신이다. TCP/IP 특성상 도청이 가능하며, 통신 상대를 확인하지 않기 때문에 위장이 가능하다. 가령 나는 IP가 A인 사람한테 보내고 싶은데, 악의적인 해커가 내가 IP A요 하고 말해도 검증할 방법이 없다는 것. 또한 완전성을 증명할 수 없기 때문에 변조가 가능하다. 보안 방법은 통신 자체를 암호화(SSL, TLS)하거나, 콘텐츠를 자체를(HTTP 메시지 컨텐츠를) 암호화 하는 것이다. 도청이 가능한 문제, 사용자를 확인할 수 없다는 문제, 정확성을 보장할 수 없다는 문제를 모두 해결할 방안으로 나온 것이 HTTPS이다.
    - HTTPS는 새로운 프로토콜이 아닌, HTTP에서 SSL 개념을 더한 프로토콜이다. 기존 HTTP는 TCP와 직접 통신했지만, HTTPS는 HTTP와 TCP 사이에 SSL, TLS가 끼워져 있는 것이다. HTTP는 SSL과 통신하고, SSL은 TCP와 통신하게 된다.
    - SSH Hand Shake 과정(TCP 3-way hand shake 이후)
        * Client Hello: 클라이언트가 서버에 연결을 시도하며 전송하는 패킷, 자신이 사용 가능한 Cipher Suite목록, Session ID, SSL Protocol Version, Random Byte 등을 전송. Cipher Suite는 SSL Protocol Version, 인증서 검정, 데이터 암호화 프로토콜, Hash 방식등의 데이터를 담고있어, 선택된 Cipher Suite의 알고리즘에 따라 데이터를 암호화
        * Server Hello: Client가 보내온 ClientHello Packet을 받아 Cipher Suite중 하나를 선택해 클라이언트에 알리면서, 자신의 SSL Protocol Version등도 같이 보냄
        * Certificate: Server가 자신의 SSL 인증서를 Client에 전달, 인증서 내부에는 Server가 발행한 공개키가 들어있음. Client는 Server가 보낸 CA(Certificate Authority, 인증기관)의 개인키로 암호화된 SSL인증서를, CA의 공개키로 복호화(인증서 검증)
        * Server Key Exchange/Server Hello Done: Server의 공개키가 SSL인증서 내부에 없는경우 Server가 직접 전달하는것. 공개키가 SSL인증서 내부에 있을경우 Server Key Excahge는 생략
        * Client Key Exchange: 대칭키를 Client가 생성해서 SSL인증서 내부에서 추출한 Server의 공개키를 이용해 암호화 한 후 Server에게 전달
        * Change Cipher Spec / Finished: Client, Server모두가 서로에게 보내는 Packet으로 교환할 정보를 모두 교환한 뒤 통신할 준비가 되었음을 알리는 패킷. 이후 Finished 패킷을 보내 SSL Handshake 종료

14. TCP/UDP 등 로우레벨 통신 지식
    - TCP 3-way hand shake
        * TCP/IP 프로토콜을 이용해서 통신하는 프로그램이, 데이터를 전송하기 전에 먼저 정확한 전송을 보장하기 위해 상대방과 사전에 세션을 수립
        * 클라이언트에서 서버로 접속을 요청하는 SYN패킷을 보냄. 클라이언트는 SYN을 보내고 SYN/ACK 응답을 기다리는 SYN_SENT 상태가 됨
        * 서버는 SYN 요청을 받고, 클라이언트에게 요청을 수락한다는 ACK와 SYN 플래그가 설정된 패킷을 발송하고 다시 클라이언트가 ACK로 응답하기를 기다리는 SYN_RECEIVED 상태가 됨
        * 다시 클라이언트는 서버에게 ACK 를 보내고, 이후 연결이 이뤄져 데이터가 오가게되고 서버의 상태는 ESTABLISHED가 된다

    - TCP 4-way hand shake
        * 3-way hand shake가 연결을 수립하기 위한것이였다면, 4-way hand shake는 세션을 종료하기 위해 수행
        * 클라이언트가 연결을 종료하겟다는 FIN 플래그 전송
        * 서버는 확인 메시지인 ACK를 보내고, 자신의 통신이 끝날때까지 기다리게 되는데 이 상태가 TIME_WAIT
        * 서버의 통신이 끝났으면 연결이 종료되었다고 클라이언트에게 FIN 플래그 전송
        * 클라이언트는 확인했다는 ACK를 다시 클라이언트로 보내고 연결 종료
        * 서버에서 FIN을 전송하기전 전송한 패킷이 Routing지연이나 패킷 유실로 인한 재전송 등의 이유로 FIN보다 늦게 도착할 경우, 이 패킷은 Drop되고 유실될것이다. 클라이언트에서는 이를 방지하기 위해 서버로부터 FIN을 수신하더라도 일정 시간(디폴트 240초) 동안 세션을 남겨놓고 잉여 패킷을 기다리는데, 이 상태가 TIME_WAIT이다

    - TCP는 흐름제어, 오류제어를 통한 연결 지향성, 순서 중요함, 오류시 재전송. 전이중과 점대점(각 연결이 정확히 2개의 종단점을 가지고 있음) 방식.
    - UDP는 비연결형 프로토콜, 상대방이 받든지 말든지 그냥 보낸다. 손상된 세그먼트에 대해 재전송하지 않는다. 만약 클라이언트 timeout이 발생하면 다시 보내면 그만이다.

15. CORS란?
    - Cross Origin Resource Sharing 약자. 말 그대로 다른 도메인간의 자원 공유를 의미한다. 본래 대부분의 브라우저는 타 도메인 간 요청을 Same-Origin-Policy에 의해 차단한다. 이런 설정을 우회하기 위해 여러 방법이 있었지만, HTML5가 등장하면서 CORS가 등장했다. CORS는 헤더를 통하여 Cross-Domain간 사용가능한 자원을 헤더를 통하여 알려준다.

16. 사용했던 프로젝트 환경
    - Spring Boot 2.1.2
        * spring-boot-starter: 의존성과 설정을 자동화 해주는 모듈
        * spring-boot-starter-web: 웹과 관련된 의존성과 설정을 자동화
        * spring-boot-starter-actuator: Spring Boot기반 어플리케이션을 쉽게 제공해주는 라이브러리, 상태 모니터링, 트래픽등
        * spring-boot-starter-test: 테스트와 관련된 라이브러리(spring-test, junit, hamcrest등)
    
    - lombok : getter/setter등 반복되는 코드를 어노테이션으로 작성하게 해주는 라이브러리 
    
    - tomcat
        * spring-boot-starter-tomcat: spring boot 내장 톰켓
        * javax.el-api 2.2.4: 값을 표현하는데 쓰는 Expression Language를 사용하기 위해
    - JPA
        * spring-boot-starter-data-jpa: JPA를 한번 더 추상화해 사용하기 쉽게 만든 프레임워크
        * spring-orm: 객체와 DB 테이블을 매핑하기 위한 도구
        * mysql-connector-java: Mysql 연결을 위한 커넥터
        * com.h2database: 자바 기반의 오픈소스 RDBMS
        * spring-data-rest-hal-browser: HATEOAS (Hypermedia As The Engine Of Application State)을 구현하기 위한 Hpyertext Application Language
        * spring-boot-starter-freemarker: 자바 템플릿 엔진, 템플릿 뷰를 만들때 사용
        * querydsl-jpa 4.1.4: SQL, JPQL을 문자열이 아닌 코드로 작성하게 해주는 빌더 API

    - swagger
        * springfox-swagger2 2.6.1, springfox-swagger-ui 2.6.1, swagger-springmvc 1.0.2
        * REST API를 설계 및 문서화 등에 유용하게 사용되는 라이브러리
    
    - usertype.jodatim 2.0.1: 시간 관련 라이브러리, 사용하기 편하고 Thread Safe함
    - JSON
        * jackson-datatype-joda, jackson-datatype-hibernate5, jackson-module-scala_2.11 2.6.6, jackson-core-asl 1.9.13, jackson-mapper-asl 1.9.13, json-path, json-simple 1.1.1, gson
        * JSON 관련 라이브러리

    - Apache Commons
        * commons-io 1.3.2: IO관련 유틸리티
        * commons-lang3 3.3.2: java.lang 관련 추가 유틸리티
        * httpclient: HTTP 통신을위한 라이브러리
        * commons-validator 1.5.1: 데이터 검증등을 위한 라이브러리
        * commons-codec 1.9: base64, URL등의 인코딩/디코딩을 위한 라이브러리
    
    - Excel parsing
        * poi 3.17, poi-ooxml 3.17, poi-scratchpad 3.17, opencsv 4.0
        * 엑셀등 문서 읽기/쓰기를 위해

    - bouncycastle
        * bcprov-jdk15on 1.47: 확장된 기능을 가진 자바 암호화 라이브러리
    
    - annotations

    - Spring Security
        * spring-security-core: 스프링 시큐리티 
        * spring-security-oauth2 2.3.5: OAuth2.0 라이브러리
        * spring-security-jwt 1.0.0, java-jwt 3.8.3 : JWT사용을 위한 라이브러리
    
    - Unit Test(JUnit 5)
        * junit-jupiter-api, junit-jupiter-engine, junit-platform-runner, junit-platform-commons 1.5.2: JUnit 5
        * mockito-core: Mock 라이브러리
        * jacoco-maven-plugin: Code Coverage 측정을 위한 라이브러리
        * maven-surefire-plugin, maven-surefire-report-plugin: Unit test를 위해 

    - onelogin
        * java-saml-core 2.3.0: 도메인간의 SSO를 가능하게 하는 라이브러리
        * SAML : Security Asserting Markup Language, http://en.wikipedia.org/wiki/SAML 참조
        * SSO : Single Sign On 하나의 일관된 인증방식으로 여러 서비스에 로그온할 수 있는 방법

    - Java 1.8
    - log4jdbc 1.16

17. 배포 전략
    - Rolling: 서비스중인 서버를 한대씩 구버전에서 신버전으로 교체. 서비스중인 서버 한대를 제외 시키고 그자리에 신버전 서버를 추가. 트래픽을 점진적으로 변경. 서버수의 제약이 있을때 유용하나, 배포중 인스턴스의 수가 감소하므로, 처리 용량을 미리 고려 해야함
    - Blue/Green: 구버전에서 새버전으로 일제히 전환하는 전략. 구버전의 서버와 신버전의 서버를 동시에 나란히 구성하고, 배포시점이 되면 트래픽을 일제히 전환. 한번에 하나의 버전만 프로덕션 되므로, 버전 관리 문제를 방지 할 수 있고, 빠른 롤백이 가능. 운영 환경에 영향을 주지 않고 실제 서비스환경으로 새버전 테스트 가능. 단 시스템 자원이 2배로 필요하고, 전체 플랫폼에 대한 테스트가 이뤄져야 한다
    - Canary: 구버전과 새버전의 서버들을 구성하고 일부 트래픽을 새버전으로 분산하여 오류 여부를 판단. 분산 후 결과에 따라 새 버전이 운영 환경을 대체할수도 있고, 다시 구버전으로 돌아갈수도있다

18. 모놀리식 아키텍처와 MSA
    - Monolithic Architecture: 모듈별로 개발을 한 후, 개발이 완료된 애플리케이션을 하나의 결과물로 패키징하여 배포되는 형태
        * 개발, 빌드, 배포, 테스트가 용이함
        * CI/CD가 어렵고, 모든 모듈이 하나의 프로세스에서 돌아가기 떄문에, 하나의 모듈이 수정되어 서버를 내렸다 올릴경우 다른 모듈들도 그동안 작동 불가능한 상태가 됨

    - Mirchroservice Archetecture: 애플리케이션을 느슨히 결합된 서비스의 모임으로 구조화하는 서비스 지향 아키텍처(SOA) 스타일의 일종인 소프트웨어 개발 기법. 이로 인해 쉽게 교체 될 수 있고, 독립적으로 개발되고 전개될 수 있는 작은 어플리케이션이 마이크로서비스
        * 마이크로서비스의 핵심은 한가지만 아주 잘 처리하자 이며, 이로 인해 큰 문제들을 작은 문제로 나누어 해결, 작게 나뉘어진 서비스가 서로에게 영향을 미치지 않고 독립적으로 역할을 수행
        * 각각의 서비스가 오직 자신과만 상호작용 하는 DB를 가지기 때문에, 서비스마다 DB종류도 다르게 가질수있지만, 각 서비스별 데이터 중복이 일어날 수있고, 한쪽의 데이터만 업데이트 될 수도 있다
    
    - 모놀리식 아키텍처는 어플리케이션 확장시 운영에 관한 업무량이 증가하며, 새로운 기능 추가에 따른 라인수와 복잡도 증가, 불가피하게 어플리케이션을 수직/수평으로 확장해야한다
    - 모놀리식 아키텍처는 특정 서비스에만 트래픽이 몰려서 로드밸런서를 두어 확장해도, 모든 모듈이 하나의 어플리케이션으로 배포되기 때문에 어플리케이션 사본을 운영하는 서버를 두어 수평 확장해야 한다
        * 이렇게 확장할경우 기존 코드에 대해 무결성을 확인하기 위해 많은 테스트를 거쳐야 하며, 기술적 부채가 늘어난다. 그래서 이러한 형태가 Monolithic(단단히 하나로 짜여진)이다
    
    - 마이크로서비스 아키텍처는 작은 서비스 단위로 나누어 배포하기 떄문에 배포가 어렵고, 서비스간 통신 방식이 필요하며, 서비스를 나눠서 데이터간 중복이 있을 수 있고 정합성을 보장하기 어렵다

19. 스케일업, 스케일아웃
    - 스케일아웃: 여러대의 서버로 나누어 일을 처리하는것. 로드밸런서 필요
    - 스케일업: 서버가 더 빠르게 동작하기위해 서버의 하드웨어 성능을 올림

20. Spring에서의 예외 처리 전략
    - 통일된 Error Response객체를 가져야함. 그렇지 않으면 클라이언트에서 예외처리를 항상 같은 로직으로 처리하기가 어려움
    - ```@ControllerAdvice```로 모든 예외를 핸들링(예외 핸들 하면서 Response Body 다룰거면 ```@RestControllerAdvice```)
    - ```@ControllerAdvice``` 클래스에서 ```@ExceptionHandler```어노테이션으로 처리할 Exception을 지정해서 적절하게 처리
    - Error Code를 Enum으로 정의해 한곳에서 관리
    - 요구사항에 맞지 않는 요청이 들어온경우, Exception을 발생시켜 로직을 종료 해야함. 이것이 Business Exception
    - try-catch는 최대한 지양하며, 사용하게 될 경우 더욱 구체적인 Exception을 발생시켜라

21. OSI 7 Layer
    - 1 물리계층: 물리 매체를 통해 Bit흐름을 전송, 물리적 장치와 인터페이스가 전송을 위해 필요한 기능과 처리절차 규정
    - 2 데이터링크: 노드와 노드 사이의 데이터 전달, 단순 bit를 전송하는 물리층에 신뢰성을 더하기 위한 흐름제어및 오류제어기능, LLC와 MAC 2개의 서브Layer
    - 3 네트워크: 송신측에서 최종 목적지까지 데이터를 전달, 송수신측의 논리주소 지정및 최종목적지에 도달하도록 경로를 배정하는 라우팅기능, 데이터링크의 물리주소는 패킷이 시스템으로 이동할때마다 변경되지만, 네트워크 주소는 목적지까지 변하지 않음
    - 4 전송: 네트워크 계층에서 패킷을 종단까지 전달한다면(네트워크 주소), 전송층은 종단 내에서 최종 수신 프로세스로의 전달(포트 주소)을 담당, 분할/재조립, 연결/흐름제어, 오류제어
    - 5 세션: 통신하는 프로세스 사이의 대화제어 및 동기화 담당
    - 6 표현: 데이터의 변환, 압축, 암호화를 담당
    - 7 응용: 사용자에게 서비스 제공 역할, SMTP, FTP, HTTP등 사용자가 원하는 최종목표에 해당

22. Proxy
    - 프록시는 보안등의 이유로 직접 통신할수 없는 서버와 서버 사이의 중개자 역할
    - Forward 프록시: 프록시를 클라이언트와 원격리소스 사이에 위치시킴. 클라이언트가 요청한 리소스를 원격에서 가져와서 클라이언트에 forward 해주는 역할. 그래서 보통 캐슁기능이 있고, 자주 사용하는 컨텐츠라면 월등한 성능 향상을 가져올수 있음
    - Reverse 프록시: 프록시를 인터넷 리소스와 내부서버 사이에 위치시킴. 리버스 프록시가 요청을 받아서 내부 서버에서 데이터를 받아 데이터를 클라이언트에 전달. 내부서버가 직접 제공하는것 대신 보안을 확보하기 위해 사용. DMZ라고 하는 내부/외부 네트워크 모두 접근할 수 있는 공간에 리버스 프록시를 위치시키고, 실제 서비스는 내부망에 위치하도록 하여서 보안 확보. 일반적으로 WEB(Apache, nginx) - WAS(Tomcat) 분리형태에서, WEB이 리버스프록시가 된다

23. OAuth 2.0
    - OAuth 2.0이란: 외부 서비스의 인증 및 권한부여를 관리하는 범용 프레임워크. OAuth기반 서비스의 API를 호출 할때에는, HTTP 헤더에 accessToken을 포함하여 요청을보내는데, 서비스는 해당 accessToken을 검사하며 요청이 유효한지 확인한다
    - OAuth를 구성하는 4개 Role
        * resource owner(자원 소유자): protected resource(보호된 자원)에 접근하는 권한을 제공
        * resource server(자원 서버): access token을 사용해 요청을 수신할때, 권한을 검증후 적절한 결과를 응답
        * client: 자원 소유자의 보호된 자원에 접근 요청을 하는 어플리케이션
        * authorization Server: 클라이언트가 성공적으로 access token을 발급받은 이후에, 자원 소유자를 인증하고 권한부여
    
    - 권한 허가 절차
        * 클라이언트가 자원 소유자에게 권한을 요청
        * 자원 소유자가 권한을 허가하면 클라이언트는 권한증서를 받는데, 이 권한 증서는 자원소유자가 자원에 접근할 수 있는 권한을 부여하였다는 증거로, 클라이언트가 access token을 요청하여 얻어오는데 사용되며 4종류가 있다
            + Authorization Code: 클라이언트가 자원소유자에게 직접 권한부여를 요청하는 대신, 자원 소유자가 권한 서버에 인증을 받고 권한을 허가함. 권한을 허가하게 되면 Authorization Code(권한 코드)가 발급되게 되고, 클라이언트는 이 코드를 권한 서버에 보내 access token을 받아온다. access token을 클라이언트로 직접 전달하지 않기때문에, 전달과정에서 생길수있는 잠재적 유출을 방지하는데 도움
            + Implicit: Authorization Code을 간소화한 절차로, access token을 얻기위해 중간 매개체로 Authorization Code를 사용하는것 대신, 바로 access token을 받아오는 방식. 간편하지만 보안성이 낮아짐
            + Resource Owner Password Credentials: 자원 소유자의 계정 인증 정보(ID/PW)가 access token을 얻기 위한 권한 증서로 사용됨. 계정 정보를 어플리케이션에 직접 입력해야 하므로 신뢰할수 있어야 하며 access token을 얻은 이후에는 리소스 요청을 위해 계정 인증 정보를 클라이언트가 가지고 있을 필요는 없음
            + Client Credentials: 자원 소유자가 유저가 아닌 클라이언트일때 사용되는 방식으로, 클라이언트가 관리하는 리소스에만 접근할 경우로 권한이 한정 되어 있을경우로 권한이 한정되어있을때 활용. 즉 클라이언트가 자원소유자가 되는 상황이며 클라이언트는 자기를 인증할 수 있는 정보를 권한서버에게 보내 access token을 요청

        * 권한 증서를 받은 클라이언트는 access token을 권한 서버에 요청
        * 권한 요청을 받은 권한 서버는 클라이언트가 보내온 권한 증서의 유효성을 검증해서 유효하다면 access token을 발급하고 그 결과를 클라이언트에 알려줌
        * access token을 받은 클라이언트는 자원 서버에 해당 access token을 사용해서 자원을 요청
        * 요청을 받은 자원 서버는 해당 access token의 유효성을 검증하여 유효하다면 요청 처리

    - Access Token과 Refresh Token
        * Access Token: 요청 절차를 정상적으로 마친 클라이언트에게 발급됨. 보호된 자원에 접근할때 권한 확인용으로 사용
        * Refresh Token: 한번 발급받은 Access Token은 사용할 수 있는 시간이 제한되어 있으므로, 유효기간이 만료되면 새로운 access token을 받아와야 하는데, 이때 사용되는것이 refresh token. 권한서버가 access token을 발급해줄때 같이 발급되며, 전용의 발급 절차 없이 미리 가지고 있을 수 있음. 권한서버에서만 활용되며 자원 서버에는 전송되지 않고, 오류등으로 권한이 만료됨을 안 클라이언트는 refresh token을 권한 서버에 보내 새로운 access token의 발급을 요청. 권한 서버는 refresh token의 유효성을 검증하고 문제가 없으면 access token을 발급

    - JWT
        * JSON Web Token: JSON을 사용하여 가볍고 자가수용적인 방식으로 데이터를 전달. 필요한 모든 정보를 자체적으로 지니고있으며, 토큰에 대한 기본 정보, 전달할 정보, 토큰이 검증되었단것을 증명해주는 signature를 포함
        * 기존의 OAuth2.0 의 단점은 api를 호출할때마다 access token이 유효한지 실제 권한 서버를 통해 검증을 해주어야 하는것인데 이러한 작업이 빈번해지면 권한 서버에 부담이 된다. 이러한 문제를 개선하기 위해 토큰 자체에 만료일을 체크하는 부분을 첨부하고 사용자에 대한 추가 정보를 첨부하면 권한 서버에 대한 부담을 줄일 수 있다. 요청을 받은 서비스에서는 이 서비스를 호출한 사용자에 대한 추가정보는 모두 토큰 안에 있기 때문에 다른곳에서 가져올 필요가 없다. 이러한 방식의 토큰을 Claim 기반의 토큰이라 하며 JWT가 바로 Claim기반 토큰이다
    

24. Spring Security + OAuth2.0 + JWT 구현
    - OAuth2.0에서 프로바이더의 역할은 Authorization서비스와 Resoruce서비스를 실질적으로 분리하는것. 같은 애플리케이션에 두 서비스가 있더라도 Spring Security OAuth를 사용해 이들을 두 어플리케이션으로 분리할 수도 있고, Authorization서비스를 공유해 여러 리소스 서비스에서 사용할 수 있다
    - OAuth2.0 Authorization 필수 End point
        * AuthorizationEndpoint: 인가에 대한 요청을 서비스할때 사용. 기본 URL은 /oauth/authotize
        * TokenEndPoint: 엑세스토큰을 받이 위한 요청을 서비스할때 사용. 기본 URL은 /oauth/token
    
    - OAuth2.0 리소스 서버 구현의 필수 필터
        * OAuth2AuthenticationProcessingFilter 인증된 엑세스 토큰을 받는 요청에서 인증을 불러올때 사용
        
    - AuthorizationServerConfigurerAdapter: JWT를 설정하기 위해 AuthorizationServerConfigurerAdapter를 상속
        * accessTokenConverter: 실제 JWT에 access token은 암호화 해야하기때문에, 그 암호화/복호화 키를 처리(내부에서 JWTAccessTokenConveter구현체 사용)
        * tokenStore: accessTokenConverter를 통해 토큰 스토어의 빈을 생성 
        * tokenGranter
        * configure(ClientDetailsServiceConfigurer)
        * configure(AuthorizationServerEndpointsConfigurer): 엔드포인트에 tokenStore를 할당하고 authenticationManager의 accessTokenConverter를 설정

    - JwtAccessTokenConverter
        * encode
        * enhance
    
    - RefreshTokenGranter
        * getAccessToken
        * Constructor
    
    - TokenEnhancer
        * enhance
        
    - AbstractTokenGranter
        * Constructor
        * getOAuth2Authentication
        * getAccessToken
    
    - WebSecurityConfigurerAdapter: WebSecurityConfigurerAdapter를 상속받음. Security를 설정하는 클래스
        * authenticationManagerBean: authenticationManager
        * configure: authenticationManager를 설정

25. 컨테이너 오케스트레이션
    - 컨테이너의 배포 관리를 컨테이너 오케스트레이션이라고 하는데, 컨테이너 오케스트레이션의 목적은 여러 컨테이너의 배포 프로세스를 최적화 하는데 있고, 컨테이너의 수와 호스트의 수가증가할수록 가치가 있게된다. 이러한 유형의 자동화가 오케스트레이션 이다
    - 컨테이너 오케스트레이션은 단지 자동 배포하는것 뿐만 아니라 다음과 같은 기능을 포함할 수 있다
        * 컨테이너 자동 배치 및 복제
        * 컨테이너 그룹에 대한 로드밸런싱
        * 컨테이너 장애 복구
        * 클러스터외부에 서비스 노출
        * 컨테이너 추가 또는 제거로 확장 및 축소
        * 컨테이너 서비스간의 인터페이스를 통한 연결 및 네트워크 포트 노출 제어
26. 대규모 트래픽 처리(내생각)
    - 기본적으로는 로드밸런서를 두어서 적절하게 트래픽을 분산
    - MSA로 마이크로 서비스 단위로 분리해서 운영하면 행여 어느 한 서비스가 다운되더라도 걔만 복구시키면 되니 좋을것 같음
    - 적절한 스케일 업(장비성능 업)과 스케일 아웃(장비 수 증가)도 필요할것임
    - RxJava, Reactor등을 통해서 비동기 방식으로 만드는것도 도움이 됨

        
27. JWT의 저장 위치
    - 기본적으로 쿠기에 저장, 쿠키 발급시 httpOnly, secure, sameSite flag 가 적용되면 좋음

28. Spring DataSource sql 자동실행
    - Spring Boot은 클래스패스 하위에 shema.sql과 data.sql이 있으면 앱이 구동될때 실행 하게 할 수 있음
    - 그것을 위해서는 spring.datasource.initialization-mode의 옵션을 always를 주어야함(never시 실행 안함)

29. Spring에서의 멀티스레드
    - Spring boot은 기본적으로 멀티스레드여서 여러 요청을 동시에 처리 할 수 있음
    - 하지만 Spring 빈은 기본적으로 싱글톤빈 이기 때문에, 실제로 하나의 컨테이너에 하나의 컨트롤러 인스턴스가 존재 하므로 컨트롤러가 멀티스레드로 되어있는지 확인 해야함
    - ```@Async```어노테이션을 추가하면 기본적으로 비동기로 처리 되지만, 이때 SimpleAsyncTaskExecutor에 의해 관리되기 때문에, ```@EnableAsync```를 가진 AsyncConfig class에서, 적절한 Executor를 통해 setCorePoolSize(기본 쓰레드 사이즈), setMaxPoolSize(최대 쓰레드 사이즈), setQueueCapacity(Max쓰레드가 동작하는 경우 대기하는 queue 사이즈)를 설정하고 ```@Async``` 어노테이션에서 해당 Excutor를 등록함으로써 처리

30. 서버가 1000개 있는데 1분내로 싹다 릴리즈 해야 한다면?
    - 서버 배포 전략을 잘 사용 해야 할것 같다
    - 시간이 문제되는 경우라면 블루/그린이 적합하지 않을까
31. C10K
    - 하나의 웹서버에 10000개의 클라이언트 접속을 동시에 다루려면?
    - 대표적인 해결 방법이 Nginx
    - 이벤트 기반의 비동기 처리
    - 이벤트 루프가 계속 돌면서 작업을 요청받고, 요청받은 작업을 콜백에 쌓음
    - 콜백에서는 순서대로 작업을 실행하는 대신 I/O 작업이 종료되면 이벤트를 발생시키는데, 이벤트는 해당 프로세스의 이벤트 큐에 등록되고, 프로세스가 이 큐에 새로 등록된 이벤트를 감지하여 작업 실행

32. HTTP란? HTTP1/2 차이
    - HTTP(Hyper Text Transfer Protocol)이란 서버/클라이언트 모델을 따라 데이터를 주고 받기 위한 프로토콜. 애플리케이션 레벨의 프로토콜로 TCP/IP 위에서 동작하며, 상태를 가지고있지 않는 Stateless 프로토콜로 Method, Path, Version, Header, Body로 구성
    - HTTP 1.x
        + HTTP 헤더 + 바디로 구성
        + 헤더에는 URI, Request Method 등 여러 헤더 정보가 포함
        + 사람이 읽을수있는 문자열이 그대로 전송
        + TCP 커넥션을 이용하므로 3-way-handshake를 사용하게 되어있음
        + HOL(Head of Line) Blocking 특정 응답 지연 문제 - 클라이언트 리퀘스트 순서와 서버의 응답 순서가 동기화 되기 때문
        + 헤더가 큼 - 쿠키등 다양한 메타정보가 저장 되어 있기 때문에
    - HTTP 2.0
        + Body가 binary framing layer라고 하는 공간에 이진 데이터로 되어서 전송. HTTP Reqeus Method, 헤더등은 여전히 문자열이지만 바디가 변경됨
        + 멀티플렉싱 - 하나의 TCP연결에 여러 스트림을 사용해서, 여러 요청/응답을 병렬로 처리
        + 스트림 우선순위 지정 - 1개의 TCP에 여러 스트림을 사용할수있게 되므로, 각각의 스트림에 우선순위 부여 가능
        + 헤더 압축 - HPACK 압축을 통해서 헤더를 압축해서 보냄 
        + Server Push - 클라이언트에게 필요한 데이터가 있을때, 직접 요청하기 전에 서버가 미리 데이터를 전송하여 받아볼수 있게 함
    - HTTP 3
        + UDP

33. 패킷
    - 네트워크상에서 전송하는 데이터를 일정한 크기로 자른, 작게 나뉜 데이터의 묶음
    - 누구에게 어디로 무엇을 보내야 하는지에 대한 정보가 담겨 있으며 안정성 때문에 나눠 보내는것

34. TCP/IP 프로토콜 4계층
    - OSI와 달리 실무적으로 적용 가능한 모델
    - L1 네트워크 연결 계층
        * 데이터 단위: 프레임
        * 전송 주소: MAC
        * 물리적으로 데이터가 네트워크를 통해 어떻게 전송되는지를 정의(논리 주소가 아닌 물리주소 - MAC)
        * 에러검출 및 패킷의 프레임화 담당
        * 프레임 단위의 데이터 구성 - 데이터 전송 전에 패킷헤더에 MAC주소와 오류검출부 첨부
        * Ethernet, PPP, Token Ring
    - L2 인터넷 계층
        * 데이터 단: 패킷
        * 전송 주소: IP
        * 네트워크상 최종 목적지까지 정확하게 연결되도록 연결성을 제공
        * 단말을 구분하기 위해 논리적 주소인 IP를 할당
        * 출발지와 목적지의 논리적 주소가 담겨있는 IP datagram이라는 패킷으로 데이터 변경
        * 라우팅 기능을 처리 - 경로 설정
        * 최종 목적지까지 정확하게 연결 되도록 연결성 제공
        * 패킷 단위의 데이터 구성 - 세그먼트를 목적지까지 전송하기 위해 시작주소와 목적지의 논리적 주소를 붙인 단위
        * IP, ARP, ICMP, RARP
    - L3 전송 계층
        * 데이터 단위: 세그먼트
        * 전송 주소: 포트
        * 통신 노드간의 연결 제어 및 자료 송수신을 담당
        * 어플리케이션 계층의 세션과 데이터그램 통신 서비스 제공
        * 세그먼트 단위의 데이터 구성 - 실질적 데이터 전송을 위해 데이터를 일정 크기로 나눈것, 발신, 수신, 포트주소, 오류검출코드가 추가됨
        * TCP, UDP, RTP 등
    - L4 응용 계층
        * 데이터 단위: 데이터/메시지
        * 사용자와 가장 가까운 계층으로 사용자가 소프트웨어와 소통할 수 있게 해줌
        * 응용프로그램들이 데이터를 교환하기 위해 사용되는 프로토콜
        * 사용자 응용프로그램 인터페이스를 담당
        * 파일전송, 이메일, FTP, HTTP, SSH, DNS, SMTP 등

35. TCP / UDP
    - TCP
        * 연결 지향형 전송 규약
        * 흐름 중심 프로토콜, 통신을 주고 받는것을 중요시함
        * 중간에 패킷이 손실되는 경우 재전송을 통해 신뢰성을 보장
        * 대부분의 통신 및 파일 이나 데이터 전송시 사용
    - UDP
        * 비 연결 지향형 전송 규약
        * 데이터 중심의 프로토콜, 주고받는 통신보다 데이터를 일방적으로 보내는것을 중시함
        * P2P, 스트리밍, 전화등에 사용

36. 로드밸런싱
    - 한곳을 들어오는 부하를 여러곳으로 분산시켜주는것
    - 여러대의 서버를 두고 서비스를 제공하는 분산 처리 시스템에서 필요

37. REST API에서의 URL과 일반 HTTP 에서 URL의 차이
    - HTTP: 기능에 중점을 두어 설계, 회원 정보가 필요하다면 /getUser
    - REST: 자원에 중점을 두어 설계, /user 하위에 기능에 대한 구분을 추가하여 POST, GET, DELETE, PUT 의 HTTP 메서드를 사용

38. 웹훅
    - 웹페이지 또는 웹앱에서 발생하는 특정 행동(이벤트)들을 커스텀 Callback으로 변환해주는 방법
    - 전형적인 API 요청으로 특정 앱의 데이터 및 이벤트 상태를 알기 위해서는 짧은 주기로 반복해서 Data 요청을 보내 Data의 변경이나, 이벤트 발생 여부를 알아야 한다. 그러나, 우리가 필요한 데이터를 가지고 있는 앱이 Webhook 서비스를 제공할 경우, Webhook 설정에 우리 서비스의 요청 Url을 등록해 놓은 뒤에, Webhook 서비스로부터 특정이벤트 관련 정보(알림)를 받기까지 기다리고 있으면 된다. 그래서 Reverse API라고 불리기도 한다

39. Spring Security 작동 원리
    - Filter기반으로 동작하여 MVC와 분리되어 동작하며 기본적으로 세션 & 쿠키 방식으로 인증
    - 이하는 로그인 프로세스를 설명
    - 사용자가 아이디/비밀번호로 로그인을 요청함
    - AuthenticationFilter에서 UsernamePasswordAuthenticationToken을 생성하여 AuthenticaionManager에게 전달
    - AuthenticaionManager는 등록된 AuthenticaionProvider(들)을 조회하여 인증을 요구함
    - AuthenticaionProvider는 UserDetailsService를 통해 입력받은 아이디에 대한 사용자 정보를 DB에서 조회함
    - 입력받은 비밀번호를 암호화하여 DB의 비밀번호화 매칭되는 경우 인증이 성공된 UsernameAuthenticationToken을 생성하여 AuthenticaionManager로 반환함
    - AuthenticaionManager는 UsernameAuthenticaionToken을 AuthenticaionFilter로 전달함
    - AuthenticationFilter는 전달받은 UsernameAuthenticationToken을 LoginSuccessHandler로 전송하고, 토큰을 response의 헤더에 추가하여 반환함

40. Spring WebFlux
    - Spring5에 처음으로 등장
    - 기존의 Spring MVC는 HTTP 요청들을 큐에 넣어두고, 멀티 쓰레드 기반으로 동작. 응답성이 상대적으로 떨어지는 문제 발생
    - 이 문제를 해결하기 위해 비동기 데이터 스트림으로 Non-Blocking 애플리케이션을 개발하기위한 필요성이 생김
    - 그래서 Reactive Stream(논블로킹 백프레셔를 이용한 비동기 데이터 처리 표준)의 구현체인 Project Reactor 의 웹 스트리밍을 담당하는 Webflux가 등장
    - Servlet을 그대로 사용할수도 있지만, Netty를 사용하는게 권장

41. CDN(Content Delivery Network)
    - 물리적으로 떨어져잇는 사용자에게 컨텐츠를 더 빠르게 제공하기위해 고안된 기술
    - 서버를 분산해 캐싱시켜두고, 컨텐츠 요청이 발생하면 사용자와 가장 가까운 서버로 매핑시켜 요청된 파일의 캐싱된 버전으로 요청 처리
    - 서버가 파일을 찾는데 실패한 경우 CDN플랫폼의 다른 서버에서 콘텐츠를 찾은다음에 응답 전송

42. 서버에서 DISK I/O가 많아서 병목이 발생한다 어떻게 해야 좋을까?
    - 일단 file system 의 마운트 옵션부터 바꾸는게 좋을듯? 타임스탬프(atime / access time)이 영향을 많이주니 noatime 적용
    - 디스크 캐싱: 자주 접근한 디스크 내용을 저장하고, 접근시 저장된곳부터 찾는 방식
    - 램디스크: 메모리의 일부분을 고정적으로 할당하여 디스크인척 사용하는 방법

43. 웹의 3계층
    - 프레젠테이션 로직(클라이언트, 사용자 인터페이스), 비즈니스 로직, 데이버베이스 로직을 각각 다른 플랫폼 상에서 구현한것. 각 계층은 물리적으로 독립적이며, 다른 계층에 의존하지 않음
    - 프레젠테이션 계층
        * 응용프로그램의 최상위에 위치해, 서로 다른 층에 있는 데이터등과 커뮤니케이션을 함
        * 사용자 인터페이스를 지원, GUI, Frontend
        * 비즈니스 로직이나 데이터 관리 코드를 포함하면 안됨. 주로 웹서버를 뜻함
    - 어플리케이션 계층
        * 정보 처리의 규칙을 갖고 있음
        * 미들웨어 또는 백엔드, 주로 어플리케이션 서버를 뜻함
    - 데이터 계층
        * 데이터베이스와 그것에 엑세스 해서 쓰거나 관리하는 프로그램
        * DB 또는 파일시스템을 접근 관리

44. React, Vue
    - React
        * Template 구조를 사용하지 않고, 개발자가 JSX를 사용하여 자바 스크립트에서 DOM을 생성
        * 큰 규모에 좋고, 테스팅이 수월
        * Web/Native 앱 개발에 모두 사용 가능
    - Vue
        * Template와 Render Function을 모두 사용할수있음
        * 간편한 Syntax와 프로젝트 설정
        * 빠른 렌더링과 더 작은 용량
    - 공통점
        * Virtual DOM으로 빠른 랜더링
        * 경량 라이브러리
        * 리액티브 컴포넌트(비동기 스트림 처리)

45. DOM
    - HTML 문서에 대한 인터페이스. 기본적으로 여러 프로그램들이 이 페이지의 곤텐츠 및 구조 그리고 스타일을 조작 할 수 있도록 API 제공
    - DOM은 HTML 요소들의 구조화 된 표현, 뷰 포트에 무엇을 렌더링 할지 결정하기 위해 사용, DOM은 페이지의 콘텐츠 및 구조, 그리고 스타일이 JS에 의해 수정되기 위해 사용
    - 항상 유용한 HTML 형식, JS에 의해 수정될 수 있는 동적 모델, 가상 요소를 포함하지 않고, 보이지 않는 요소를 포함함

46. Spring Batch
    - Batch: 일괄처리, 즉 단발성으로 대용량의 데이터를 처리하는 어플리케이션이 배치 어플리케이션
    - Batch 어플리케이션의 조건
        * 대용량 데이터 - 대량의 데이터를 가져오거나, 전달하거나, 계산하는등의 처리를 할수 있어야 함
        * 자동화 - 배치 어플리케이션은 심각한 문제 해결을 제외하면 사용자의 개입 없이 실행 되어야 함
        * 견고성 - 잘못된 데이터들을 충돌/중단 없이 처리할 수 있어야 함
        * 신뢰성 - 배치 어플리케이션은 무엇이 잘못 되었는지 추적 가능해야 함(로깅, 알림 등)
        * 성능 - 지정된 시간 안에 처리를 완료하거나, 동시에 실행되는 다른 어플리케이션을 방해 하면 안됨
    - Spring Batch는 Spring의 특성을 그대로 가져와서 DI, AOP등을 그대로 사용 가능

47. JPA OneToMany, ManyToOne, OneToOne, ManyToMany
    - 연관관계를 매핑하는 어노테이션들로
    - 테이블 중심의 모델링이 된다면, 외래키를 가지고 데이터를 찾기때문에 객체지향 스럽지가 못함. 객체 중심으로 관계를 매핑하는게 좋음
    - 실제 테이블에서는 양방향 연관관계(양쪽에서 서로 참조할수있는 관계)가 존재하지 않고, 이는 JPA에서 프로그래밍적으로 사용할수있게 해주는것일뿐임
    - 권장되는 방식은 단방향임. 외래키가 있는 테이블을 대변하는 엔티티가 연관관계의 주인. 역방향 참조가 필요한 경우가 아니라면 단방향
    - ```@JoinColumn``` : FK를 어떤 컬럼에 매핑시킬껀지
    - ManyToOne
        * 여러개의 테이블이 하나의 테이블과 연관 관계를 맺을때 사용
        * Memeber가 있고 Order가 있다면, 하나의 Member는 여러개의 Order를 가질수있기 때문에, Order관점에서 보면 ManyToOne
        * 따라서 Order 테이블에 ManyToOne과 JoinColumn을 사용해 Member PK 를 위한 필드를 만들어 매핑
        * Order 테이블에 외래키가 존재 하므로 Order테이블이 연관관계의 주인
    - OneToMany
        * 하나의 테이블이 여러개의 테이블과 연관 관계를 맺을때 사용
        * Memeber가 있고 Order가 있다면, 하나의 Member는 여러개의 Order를 가질수있기 때문에, Member관점에서 보면 OneToMany
        * 따라서 Member 테이블에 ```@OneToMany(mappedBy = "member")```와 같이 mappedBy를 통해 Order테이블에서 어떤 속성으로 매핑되는지를 표시 해줘야함(member가 Order의 필드명임)
    - 일대다는 1이 연관관계의 주인이지만, 외래키가 다쪽에 있어야하므로 이상하게 됨. 일대다 단방향보단 다대일 양방향이 나음
    - 일대일 관계는 외래키를 어디 두냐에 따라 달라짐
        * 주 객체에 외래키: 주 객체에 외래키를 두어, 주 객체가 대상 객체에 대한 참조를 가지는 것처럼 주 테이블에 외래키를 두고 대상 테이블을 찾음. JPA 매핑이 편하며, 주 테이블만 조회해도 대상 테이블에 데이터가 있는지 확인이 가능. 값이 없을경우엔 외래키에 Null이 허용됨
        * 대상 객체에 외래키: 대상 테이블에 외래키가 존재하여, 주 테이블과 대상 테이블을 일대일이 아닌 일대다로 변경해도 테이블 구조가 유지됨. 지연로딩을 해도 항상 즉시 로딩이 되는 문제

48. JPA 특정 컬럼만 받아오고 싶을때
    - JPQL사용 : ```@Query("select d.id, d.name from Document d")```
    - Mapping Interface 사용:

    ```java
    interface Data {
        String getId();
        String getName();
    }
    ```

    - QueryDSL 사용: SQL, JPQL을 코드로 작성할 수 있도록 도와주는 빌더 API, JPA 크리테이라에 비해서 편리하고 실용적이다. 문자가 아닌 코드로 작성하기 때문에 컴파일 시점에 오류 발견 가능.

49. JPA 패치 전략
    - 연관관계에 있는 Entity를 모두 가져오는것은 Eager (~ToOne 들의 기본)
    - 연관관계에 있는 Entity를 가져오지 않고, getter를 통해 접근할때 가져오는것은 Lazy(~ToMany의 기본). getTeam하면 Team의 프록시가 조회되고, getTeam().getName해야 실제 쿼리를 이용해 Team을 가져옴
    - ManyToOne이 5개가 있는데, 모두 Eager면 조인이 5번일어나며 그러다보면 어플리케이션의 성능저하가 발생할수있음
    - 정말 필요한 사항이 아니라면 Lazy를 사용하라고 함

50. JPA Cascade 옵션
    - CascadeType.RESIST: 엔티티를 생성하고, 연관 엔티티를 추가 했을때, persist()를 수행하면 연관 엔티티도 같이 persist()가 수행. 만일 연관 엔티티가 DB에 저장 되어있다면, 다시 persist()를 하는 것이기 때문에, Detached Entity passed to persist Excpetion 이 발생
    - CascadeType.MERGE: 트랜젝션이 종료되고, detach 상태에서 연관 엔티티를 추가하거나 변경된 이후에 부모 엔티티가 merge()를 수행하면 변경사항 적용. 연관 엔티티의 추가 및 수정이 모두 반영됨
    - CascadeType.REMOVE: 삭제시 연관 엔티티도 같이 삭제
    - CascadeType.DETACH: 부모 엔티티가 detach()를 수행하게되면, 자식 엔티티도 detach()가 수행되어 변경사항이 반영되지 않음
    - CascadeType.ALL: 모든 CascadeType 적용

51. DNS 거쳐서 나오는 IP는 어디의 IP일까?
    - ???

52. 클라이언트 근처의 CDN은 어떻게 파악해서 거기로 보내줄까?
    - Global Server Load Balancing
    - 물리적으로 가장 가깝거나 여유 트래픽이 남는 곳으로 접속을 유도
    - 서버의 상태를 모니터링(주기적으로 Health Check 수행)하고 실패한 서버의 IP는 응답에서 제외
    - 서버의 로드를 모니터링 하기 때문에 로드가 가장 적은 IP를 반환하는 형식의 로드밸런싱도 가능
    - 각 지역별로 서버에 대한 레이턴시를 가지고 있기 때문에 유저가 접근하면, 유저의 지역으로부터 가장 가까운(레이턴시가 가장 적은)서버로 연결
    - 유저의 지역 정보를 기반으로 해당 지역을 서비스하는 서버로 연결도 가능

53. 클라이언트에서 접속하면 서버는 로케일은 어떻게 파악할까?
    - IP? 
    - 라우터 사이를 홉(점프)하면서 라우터의 정보를 받아오는 방법도 있다던데... 잘 모름

54. 로드밸런서 L4, L7 차이
    - L4
        * TCP/UDP 포트 정보를 바탕으로 로드밸런싱
        * 데이터 안을 들여다보지 않고 패킷 레벨에서만 로드를 분산하기때문에 속도가 빠르고 효율이 높음
        * 데이터의 내용을 복호화 할 필요가 없어서 안전
        * 패킷의 내용을 살펴볼수없기 때문에 섬세한 라우팅이 불가능
        * 사용자의 IP가 수시로 바뀌는 환경이라면 연속적으로 서비스 제공하기가 어려움
    
    - L7
        * TCP/UDP 정보는 물론 HTTP의 URI, FTP의 파일명, 쿠키정보등을 바탕으로 로드밸런싱
        * 상위계층에서 로드를 분산하기 때문에 더 섬세한 라우팅 가능
        * 캐싱기능 제공
        * 비정상적인 트래픽을 사전에 감지할수있어서 서비스의 안정성이 높음
        * 패킷의 내용을 복호화 하기에 더 높은 비용을 지불해야함

55. 로드밸런서 로드밸런싱 방법 종류
    - Round Robin: 요청을 순서대로 각 서버에 분산
    - IP Hash: 클라이언트의 IP주소를 특정 서버로 매핑. 사용자가 항상 같은 서버로 연결되는것을 보장
    - Least Connection: 서버에 연결되있는 커넥션의 개수만 가지고 단독 비교하여서 가장 적은곳에 연결
    - Weighted Least Connections: 서버에 부여된 가중치와 커넥션 개수를 같이 고려해서 연결
    - Fastest Response Time: 가장 빨리 응답하는 서버에 연결
    - Adaptive: Open 또는 Pending 커넥션을 적게 가지고 있는 서버로 네트웍 커넥션 방향을 지정

56. DB랑 엮인부분 테스트는 어떻게? DB 모킹은 어떻게 해서 테스트?
    - ```@DataJapTest```
        * Test Class에 ```@DataJapTest``` 선언
        * JPA 관련된 Component만 로드
        * 테스트 종료후 롤백이 같이되서 테스트할때 들어간 값에 대해서 걱정하지 않아도 됨

    - Mock 활용
        * JPA Repository를 Mocking(```@Mock```)
        * 적절한 given & willReturn으로 세팅
        * 테스트
        * Repository를 사용하는 Service를 테스트 하고 싶은 경우 해당 서비스에 ```@InjectMocks``` 사용
        
57. 모니터링 시스템을 이용한TPS 파악 TPS로 서버 스케일 설정
58. 모니터링 시스템은 어떻게 구축할까? 알람오게 만들려면?

59. A 레코드 vs CNAME
    - A 레코드: 도메인 이름에 IP 주소를 등록하는것
    - CNAME: 하나의 도메인에 도메인 별칭을 부여 하는것

60. Spring 국제화
    - Spring IoC 컨테이너가 가지고 있는 MessageSource 를 통해 국제화(i18n)과 관련된 기능 처리 가능
    - Resource 디렉터리 밑에 messages_xx 이런 형식으로 작성하면 messages리소스 번들로 묶임
    - Spring Boot의 경우엔 자동으로 ResourceBundleMessageSource이 빈으로 등록되고, 이 빈이 messages리소스 번들을 메시지 소스로 읽어옴 
    - HTTP 요청의 Accept-Languag 헤더, 세션의 속성, 쿠키에 있는 language등 다양한 방법으로 확인해서 해당 언어로 지원 

61. ```@Transactional```
    - JPA에서 트랜젝션을 지원할 수 있는 어노테이션
    - Runtime Exception에만 롤백을 

62. Nginx를 이용한 무중단 배포
    - 사용자는 서비스 주소로 접속(Nginx의 주소)
    - Nginx는 사용자 요청을 받아 현재 연결된 서비스로 요청 전달
    - 연결되지 않은 다른 서비스에 배포
    - 배포후 정상적으로 두번째 서비스가 동작하는지 확인
    - 정상 동작 한다면 nginx reload해서 nginx를 2번과 연결

63. 세션이란?
    - 일정 시간동안 같은 클라이언트로부터 들어오는 일련의 요구를 하나의 상태로 보고, 그 상태를 일정하게 유지 시키는것
    - 웹 서버가 세션 아이디 파일을 만들어 서비스가 돌아가고있는 서버에 저장
    - HTTP Session 동작 순서
        * 클라이언트가 서버로 접속을 시도
        * 서버는 클라이언트의 request -header field인 cookie를 확인해 클라이언트가 해당 session-id를 보내왔는지 확인
        * 클라이언트로부터 발송된 session-id가 없다면 서버는 session-id를 생성에 클라이언트에게 resoponse-header field인 set-cookierkqtdmfh session-id를 발행
     
     - Session 저장 방식
        * in memory: 서버의 메모리에 
    
    
# Kubernetes

0. 쿠버네티스란
    - 컨테이너화된 애플리케이션을 쉽게 배포하고 관리할수있게 해주는 소프트웨어 시스템
    - 리눅스 컨테이너의 기능에 의존하므로, 애플리케이션 내부의 세부사항을 알 필요 없이, 각 호스트에 애플리케이션을 수동으로 배포하지 않고도 이기종 애플리케이션을 실행 가능 
    - 애플리케이션이 각 컨테이너에서 실행 되므로, 동일한 서버에서 실행되는 다른 애플리케이션에 영향을 미치지 않음


1. Kube System Component
    - Kube API Server
        * 다른 컨트롤플레인들한테 요청을 받아, 워커노드에 있는 Kubelet을 통해 워커노드를 제어
        * 컨트롤플레인안의 요소끼리는 통신이 불가능, 오직 Kube API를 통해서만 가능
        * REST API를 통해서 상태 제어
        * 인증, 권한, 승인제어, 리소스 검증 및 영구저장 담당
    - Controller Manager
        * Kube API 에의해 받아진 요청을 처리하는 역할
    - Kube Scheduler
        * 요청받은 리소스를 어느 노드에 실행할지 정해줌
        * 다수의 Pod 배치는 라운드 로빈 형태

2. ETCD
    - 다중의 Key, Value 형태의 데이터 저장소
    - Kube API Server에 etcd 클라이언트가 존재

3. POD
    - 쿠버네티스의 빌딩 블록
    - 내부에 다수의 컨테이너를 포함해서 실행 가능
    - 다른 노드에 걸쳐서 실행되지는 않고, 항상 하나의 노드에서만 실행
    - 밀접하게 연관된 프로세스를 하나의 환경에서 실행하는것처럼 가능하지만, 실제론 격리되어있음
    - 같은 호스트/네임스페이스/네트워크 인터페이스를 공유하므로 주의
    - 쿠버네티스 클러스터의 모든 팟은 공유된 단일 플랫 네트워크 주소 공간에 위치
    - 포드 사이에는 NAT 게이트웨이가 존재하지 않음
    - 외부로 서비스하기 위해서는 외부에 서비스를 만들어서 해야함
    - 포드 하나에 컨테이너 하나, 컨테이너 하나 안에는 프로세스 하나만 있는게 일반적
        * 리소스 관찰, 사이드카, 로그 로테이팅등 특수 경우를 제외
        * 한 팟에서 컨테이너끼리 통신은 같은 IP니, Port를 다르게 해서 통신

4. Liveness, Readiness, Startup Probe
    - Liveness Probe
        * 컨테이너가 살아있는지 판단하고 자시시작
        * 컨테이너의 상태를 스스로 판단해서, 교착상태인 컨테이너를 다시 시작
        * 높은 가용성 보장
    - Readiness Probe
        * 팟이 준비된 상태에 있는지 확인하고 정상 서비스를 시작하는 기능
        * 팟이 준비가 안되있자면, 로드밸런서에서 해당 팟으로 트래픽을 보내지 않음
    - Startup Probe 
        * 어플리케이션의 시작 시기를 확인해서 가용성을 높이는 역할
        * Liveness와 Readiness의 기능을 비활성화 해서 컨테이너의 시작 시간을 벌어줌
        * 컨테이너가 시작하고 살아 있다라는게 Startup에 의해 확인되면 그때 Liveness와 Readiness를 실행

5. Lable/Selector
    - Label
        * 리소스에 부여하는 키/값의 쌍
        * 리소스를 인식하기 위해서 라벨을 붙이는것
        * 리소스는 한개 이상의 레이블을 가질 수 있음
    - Selector
        * 각종 리소스를 필터링해서 선택

6. ReplicaSet
    - 팟이 잘 생성되도록 감시하고, 그 유형으 ㅣ팟이 원하는 수만큼 떠있는지 감시해서 그 숫자를 유지하게 해줌
    - 팟에 문제가 발생하면 약 5분정도 후에 인지가 되서 새로운 팟을 만들어줌
        * 쿠버네티스 기본설정이 5분이고 변경 가능
        * 5분 기다리는 이유는 트래픽 증가로 인해 잠시동안 끊어진것일수도 있기에
    - 팟의 범위를 결정하는 레이블 설렉터, 실행해야하는 팟의 수를 결정하는 복제본 수, 새로운 팟을 설명하는 팟 템플릿등으로 구성
    - 수동/자동으로 수평 스케일링
    - 노드에 문제가 발생시 다른 노드에 만들어줌
    - Deployment 밑에 ReplicaSet이 존재

7. Deployment
    - 어플리케이션을 다운타임 없이 업데이트 가능하도록 도와주는 리소스
    - 레플리카셋의 상위에 배포( 디플로이먼트 -> 레플리카셋 -> 팟 )

8. RollingUpdate & Roleback
    - 팟을 단계적으로 대체하는것이 롤링업데이트
    - 로드밸런서가 팟의 레이블을 보고 셀렉트를 할 수 있어서 v1팟을 실행하면서도 v2팟이 실행 가능
    - maxSurge: 최대 몇개까지 팟을 만들것인지
    - maxUnavailable: 사용할수없는 팟의 갯수

9. Namespaces
    - 리소스를 분리된 각각의 영역으로 나누는방법
    - 리소스의 이름들은 네임스페이스 내에서만 고유함

10. Service
    - 팟 자체는 쿠버네티스 내부에 있기 때문에 외부와의 통신이 안됨
    - 팟 집합에서 실행중인 애플리케이션을 네트워크 서비스로 노출하는 추상화 방법, 쿠버네티스는 팟에게 고유한 IP 주소와 팟 집합에 대한 단일 DNS 명을 부여하고, 그것들 간에 로드-밸런스를 수행
    - 서비스는 쿠버네티스 클러스터 안에서 파드의 집합에 대한 경로나 서비스 디스커버리를 제공하는 리소스다. 서비스의 대상이 되는 파드는 서비스에서 정의하는 레이플 셀렉터로 정해진다
    - 서비스를 외부로 노출하는 방식
        * NodePort: 노드 자체 포트를 사용해서 팟으로 리다이렉션
        * LoadBalancer: 외부 게이트웨이를 사용해 노드포트로 리다이렉션(보통 클라우드 환경에서 제공해줌)

11. Ingress
    - nginx로 구성
    - 하나의 IP나 도메인으로 다수의 서비스를 제공
    - HTTP 요청의 HOST 부분을 검사해서, 규칙에 따라 다른 서비스에 연결
    - 도메인 네임은 같아도 디렉토리가 다르면 다른 서비스에 매핑 가능
    - 노드포트가 필요하고 그 위에 인그레스를 만들어 쓰는것

12. Network
    - 한 팟 내의 다수의 컨테이너 끼리 통신
        * Pause 명령어를 통해 아무런 동작을 하지 않는 빈 컨테이너를 생성해서 인터페이스를 공유
        * 포트가 겹치지 않게 구성하는게 특징
        * docker의 기능을 사용해 쿠버네티스 컨테이너를 관찰
        * 각 팟마다 하나의 pause이미지 실행
        * 하나의 팟에는 하나의 인터페이스
    - 팟 끼리의 통신
        * CNI 플로그인 필요(ACI, AOS, Wave Net 등)
    - 팟과 서비스 사이의 통신
        * CluseterIP를 생성하면 iptables의 설정이 적용됨
        * Kube-Proxy가 서비스 트래픽을 제어
        * iptables가 netfilter를 이용해 트래픽 제어
        * 서비스의 ip가 pod에 없기 때문에 기본 게이트웨이를 통해서 보내는데, netfilter를 만나는순간 목적지를 알게되고, kube-proxy와의 통신으로 어딘지 알아냄
    - 외부 클라이언트와 서비스 사이의 통신
        * 외부 클라이언트의 요청은 로드밸런서를 통해 들어옴
        * eth0에 들어가게되면 어느 ip로 보내줄지 결정하는데, 이때 netfilter를 통해 알아냄
    
13. Core DNS
    - 서비스를 생성하면 대응하는 DNS 엔트리 생성 ( <서비스 이름>.<네임스페이스 이름>.svc.cluster.local 의 형식 )
    - 내부에서 DNS 서버 역할을 하는 팟이 존재
    - 각 미들웨어를 통해 로깅, 캐시, 쿠버네티스 질의를 함
    - Kubernetes 정보, etcd 정보 등 다양한 정보를 들고있음
    - Configmap 저장소를 사용해 설정 파일을 컨트롤
    - corefile을 사용해 현재 클러스터의 네임스페이스를 지정
    - 팟에서도 subdomain을 사용하면 dns 서비스를 사용 가능

14. Storage
    - 볼륨
        * 컨테이너가 외부 스토리지에 엑세스하고 공유하는 방법
        * 팟의 각 컨테이너는 고유의 분리된 파일 시스템이 존재하고, 볼륨은 팟의 스펙에 의해 정의
        * 독립적인 쿠버네티스 객체가 아니라서 스스로 생성하거나 삭제가 불가능
        * 각 컨테이너의 파일 시스템을 볼륨 마운트 해서 생성
    - PV와 PVC
        * PV: 시스템 관리자가 생성한 물리 디스크
        * PVC: 개발자가 PV에 하는 요청
        * Provisioning(PV가 정적으로 미리 만들어지거나, 요청에 의해 만들어짐) -> Binding(PV와 PVC가 바인딩됨, 1대1 관계) -> Using(PVC가 팟에서 쓰임) -> Reclaiming(사용이 끝난 PVC가 삭제되고 PV를 초기화)

15. Stateful set
    - 어플리케이션의 상태를 저장하고 관리하는데 사용하는 쿠버네티스 객체
    - 팟을 삭제하면 안의 내용이 사라지기 때문에 상태를 유지시키기 위해서는 스테이트 풀셋이 필요

16. Init container
    - 다수의 컨테이너를 올리는 방법
    - 주 컨테이너가 실행되기전에 초기화 하면서 정리해주는 역할, Init 컨테이너가 끝나야 주 컨테이너가 실행
    - Init 컨테이너가 실패하면 성공할때까지 팟을 반복해서 재시작

17. 시스템 리소스 요구사항과 제한
    - 리소스 = CPU, 메모리 등
    - 리미트 레인지
        * 네임스페이스 / 팟 / 컨테이너별로 리소스를 최소 및 최대로 제한
    - 리소스 쿼타
        * 네임스페이스별 리소스 제한
        * 리미트레인지는 리소스의 정책으로 제한하는거라면, 리소스 쿼타는 총량을 제한하는것(네임스페이스 내의 모든 컨테이너의 합이 ~~를 넘지 않도록)

18. Deamon Set
    - 쿠버네티스 전반에 걸쳐 시스템을 지원하기위해 떠 있는 컨테이너
    - 노드당 팟을 하나씩 배치해주기 때문에 노드의 팟 관리를 위해 쓰이기도 함
    - kube-proxy가 데몬셋으로 만든 쿠버네티스에서 사용하는 컨테이너
    
19. Static pod
    - 마스터 노드에도 존재하며 사용자가 직접 만드는것이 아닌 kubelet이 직접 실행하는 팟
    - kubelet이 직접 지정한 디렉토리에 yaml이 있으면 자동으로 추가, 각각의 노드들에서 kubelet에 의해 실행
    - API 서버를 통해 실행되지 않은 Static pod는 삭제 불가

