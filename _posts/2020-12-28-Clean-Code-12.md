---
layout: post
title: "Clean Code 13 : 동시성"
description: Clena Code 13장 - 동시성
date: 2020-12-28 22:12:00 +09:00
categories: CleanCode Study
---

# 동시성이 필요한 이유?
- 동시성은 결합을 없앤느 전략이다. 즉 무엇과 언제를분리하는 전략으로, 스레드가 하나인 프로그램은 무엇과 언제가 서로 밀접하다
- 무엇과 언제를 분리하면 애플리케이션의 구조와 효율이 극적으로 나아진다. 구조적인 관점에서 프로그램은 거대한 루프 하나가 아니라 작은 협력 프로그램 여럿으로 보인다. 따라서 시스템을 이해하기가 쉽고 분리하기도 쉽다
- 구조적인 개선만을 위해 동시성을 채택하는건 아니다. 어떤 시스템은 응답 시간과 작업 처리량 개선이라는 요구사항으로 인해 직접적인 동시성 구현이 불가피 하다
- 미신과 오해
    * 동시성은 어렵기 떄문에 각별히 주의하지 않으면 난감한 상황에 처한다
    * 동시성은 항상 성능을 높여주는게 아니다. 떄로 성능을 높여주는것이다. 대기시간이 아주 길어 여러 스레드가 프로세서를 공유 할 수 있거나, 여러 프로세서가 동시에 처리할 독립적인 계산이 충분히 많은 경우에만 성능이 좋아진다
    * 동시성을 구현하면 설계는 변한다. 단일 스레드 시스템과 다중 스레드 시스템은 설계가 판이하게 다르다
    * 웹 또는 EJB 컨테이너를 사용한다 해도 동시성을 이해 해야 한다. 컨테이너가 어떻게 동작하는지, 어떻게 동시 수정, 데드락과 같은 문제를 피할 수 있는지를 알아야만 한다
    * 동시성은 다소 부하를 유발한다. 성능 측면에서 부하가 걸리며, 코드도 더 짜야 한다
    * 동시성은 복잡다핟. 간단한 문제라도 동시성은 복잡하다
    * 일반적으로 동시성 버그는 재현하기 어렵다. 그래서 진짜 결함으로 간주되지도 않으며, 일회성 문제로 여겨 무시하기 쉽다
    * 동시성을 구현 하려면 흔히 근본적인 설계 전략을 재고해야 한다

# 동시성 방어 원칙
- 단일 책임 원칙
    * SRP는 주어진 메서드/클래스/컴포넌트를 변경할 이유가 하나여야 한다는 원칙이다
    * 동시성은 복잡성 하나만으로 따로 분리할 이유가 충분하다. 즉 동시성과관련 코드는 다른 코드와 분리해야 한다는 뜻이다

- 자료 범위를 제안하라
    * 공유 객체를 사용하는 코드 내에 임계 영역(Critical Section)을 synchronized 키워드로 보호하는것을 권장한다
    * 이런 임계 영역의 수를 줄이는 기술이 중요하다
    * 공유 자료를 수정하는 위치가 많을수록 보호할 임계 영역을 빼먹거나, 모든 임계 영역을 올바로 보호했는지 확인해야하며, 그렇지 않아도 찾기 힘든 버그가 더 찾기 어려워진다

- 자료 사본을 사용하라
    * 공유 자료를 줄이려면 처음부터 공유하지 않는 방법이 제일 좋다
    * 어떤 경우에는 객체를 복사해 읽기 전용으로 사용하는 방법이 가능하며, 어떤 경우에는 각 스레드가 객체를 복사해 사용한 후 한 스레드가 해당 사본에서 결과를 가져오는 방법도 가능하다
    * 공유 객체를 비하는 방법이 있다면, 코드가 문제를 일으킬 가능성도 아주 낮아진다

- 스레드는 가능한 독립적으로 구현하라
    * 자신만의 세상에 존재하는 스레드를 구현해, 다른 스레드와 자료를 공유하지 않아야 한다
    * 각 스레드는 클라이언트 요청 하나를 처리하며, 모든 정보는 비공유 출처에서 가져오며 로컬 변수에 저장한다

# 라이브러리를 이해하라
- 스레드 환경에 안전한 컬렉션
    * 스레드에 사용해도 안전한 컬렉션이 java.util.concurrent 패키지에 들어 있는데, 이러한 패키지들은 다중 스레드 환경에서 사용해도 안전하며, 성능도 좋다

# 실행 모델을 이해하라
- 기본 용어
    * 한정된 자원(Bound Resource): 다중 스레드 환경에서 사용하는 자원으로, 크기나 숫자가 제한적이다. 데이터베이스 연결, 길이가 일정한 읽기/쓰기 버퍼등이다
    * 상호 배제(Mutual Exclusion): 한번에 한 스레드만 공유 자료나 공유 자원을 사용할 수 있는 경우
    * 기아(Starvation): 한 스레드나 여러 스레드가 굉장히 오랫동안 혹은 영원히 자원을 기다린다. 예를 들어, 항상 짧은 스레드에게 우선 수위를 준다면 짦은 스레드가 지속적으로 이어질경우 긴 스레드가 기아 상태에 빠진다
    * 데드락(Deadlock): 여러 스레드가 서로 끝나기를 기다린다. 모든 스레드가 각기 필요한 자원을 다른 스레드가 점유하는 바람에 어느쪽도 더이상 진행하지 못한다
    * 라이브락(Livelock): 락을 거는 단계에서 각 스레드가 서로를 방해한다. 스레드는 계속해서 진행하려 하지만, 공명으로 인해 굉장히 오랫동안, 혹은 영원히 진행하지 못한다

- 생산자 소비자
    * 하나 이상 생산자 스레드가 정보를 생성해 버퍼나 대기열에 넣고, 하아 이상 소비자 스레드가 대기열에서 정보를 가져와 사용한다
    * 생산자 스레드와 소비자 스레드가 사용하는 대기열은 한정된 자원이다. 생산자 스레드는 대기열에 빈 공간이 있어야 정보를 채우고, 소비자 스레드는 대기열에 정보가 있어야 가져온다
    * 생산자 스레드는 대기열에 정보를 채운 후 소비자 스레드에게 대기열에 정보가 있다는 시그널을 보내고, 소비자 스래드는 대기열에서 정보를 읽어들인후 대기열에 빈 공간이 있다는 시그널을 보낸다
    * 따라서 잘못하면 생산자, 소비자 둘 다 진행 가능함에도 불구하고 동시에 서로에게 시그널을 기다릴 가능성이 존재한다

- 읽기 쓰기
    * 읽기 스레드를 위한 주된 정보원으로 공유 자원을 사용하지만, 쓰기 스레드가 이따금 갱신 할 때 처리율이 문제의 핵심이다
    * 처리율을 강조하면 기아 현상이 생기거나, 오래된 정보가 쌓이고, 갱신을 허용하면 처리율에 영향이 미친다
    * 이러한 문제를 해결할 간단한 전략으로 읽기 스레드가 없을때까지 갱신을 원하는 쓰기 스레드가 버퍼를 기다리는 방법이 있다. 하지만 이 경우에도 읽기가 계속 이어지면 쓰기는 기아에 빠진다는 문제가 있다

# 동기화하는 메서드 사이에 존재하는 의존성을 이해하라
- 공유 객체 하나에는 메서드 하나만 사용해야 한다
- 공유 객체 하나에서 여러 메서드가 필요한 경우 다음을 고려해야 한다
    * 클라이언트에서 잠금 - 클라이언트에서 첫번쨰 메서드를 호출하기 전에 서버를 잠근다. 마지막 메서드를 호출할 떄 까지 잠금을 유지한다
    * 서버에서 잠금 - 서버에다 "서버를 잠그고 모든 메서드를 호출 한 후 잠금을 해제하는 메서드"를 구현한다. 클라이언트에서는 이 메서드를 호출한다
    * 연결(Adapted) 서버 - 잠금을 수행하는 중간 단계를 생성한다. 서버에서 잠금 방식과 유사하지만 원래 서버는 변경하지 않는다

# 동기화 하는 부분을 작게 만들어라
- synchronized 키워드를 통한 락으로 만든 모든 코드 영역은 한번에 한 스레드만 실행이 가능하다. 락은 스레드를 지연시키고 부하를 가중시킨다
- 여기 저기서 synchronized문을 남발하는 코드를 바람직 하지 않다
- 하지만 임계영역은 반드시 보호해야하므로, 코드를 짤때는 임계 영역수를 최대한으로 줄여야한다. 하지만 임계 영역이 거대한 하나여서는 안된다

# 올바른 종료 코드는 구현하기 어렵다
- 깔끔하게 종료하는 코드는 데드락 같은 문제로 인해 올바로 구현하기가 어렵다
- 종료 코드를 개발 초기부터 고민하고 동작하게 초기부터 구현해야 한다. 이는 생각보다 오래 걸리고 어려우므로 이미 나온 알고리즘을 검토 해야 한다

# 스레드 코드 테스트하기
- 코드가 올바르다고 증명하기는 현실적으로 불가능 하지만, 충분한 테스트는 위험을 낮출 수 있다
- 문제를 노출하는 테스트 케이스를 작성하고 프로그램 설정과 시스템 설정, 부하를 바꿔가며 자주 돌려야 한다. 테스트가 실패하면 원인을 추적하고 다시 돌려서 통과한다는 이유로 넘어가면 절대 안된다
- 말이 안되는 실패는 잠정적인 스레드 문제로 취급하라
- 다중 스레드를 고려하지 않은 순차 코드부터 정상적으로 동작하게 만들어라
    * 스레드 환경 밖에서 생기는 버그와 스레드 환경 안에서 생기는 버그를 동시에 디버깅 하지 마라. 먼저 스레드 환경 밖에서 코드를 올바로 돌려라

- 다중 스레드를 쓰는 부분을 다양한 환경에 쉽게 끼워 넣을 수 있게 스레드 코드를 구현 하라
    * 다양한 설정에서 실행할 목적으로 다른 환경에 쉽게 끼워 넣을 수 있는 코드를 구현하라

- 다중 스레드를 쓰는 코드 부분을 상황에 맞게 조율할 수 있게 작성하라
- 프로세서 수보다 많은 스레드를 돌려봐라
- 다른 플랫폼에서 돌려봐라
    * 처음부터 그리고 자주 모든 목표 플랫폼에서 코드를 돌려라

- 코드에 보조 코드를 넣어 돌려라. 강제로 실패를 일으키게 해보라
    * 코드에 보조 코드를 넣는 방법엔 직접 구현하는 것과, 자동화를 이용하는 방법이 있다


