---
layout: post
title: "Effective Java - 아이템61: 박싱된 기본 타입 보다는 기본타입을 사용하라"
description: 박싱된 기본 타입 보다는 기본타입을 사용하라
date: 2020-09-13 20:17:00 +09:00
categories: EffectiveJava Study
---


# 일반적인 프로그래밍 원칙

## 아이템 61 : 박싱된 기본 타입 보다는 기본타입을 사용하라

- 자바의 데이터타입은 크게 2가지로 나눌 수 있는데, int, double, boolean과 같은 기본타입과 String, List와 같은 참조타입이다
- 각각의 기본타입에는 대응하는 Integer, Double, Boolean과 같은 참조타입이 하나씩 있으며, 이를 박싱된 기본타입이라고 한다
- 아이템6에서 이야기 했듯 오토박싱과 오토언박싱 덕분에 두 타입을 크게 구분하지 않고 사용할 수 있지만, 그렇다고 그 차이가 사라지는것은 아니다
- 둘에는 분명한 차이가 있으니 어떤 타입을 사용하는지는 상당히 중요하니, 주의해서 선택해야 한다
- 기본타입과 박싱된 기본 타입의 주된 차이는 크게 3가지 이다
    * 기본 타입은 값만 가지고 있으나, 박싱된 기본타입은 값에 더해 식별성이란 속성을 갖는다. 달리말하면 박싱된 기본 타입의 두 인스턴스는 값이 같아도 서로 다르다고 식별될 수 있다
    * 기본타입의 값은 언제나 유효하나, 박싱된 기본 타입은 유효하지 않은값, 즉 null을 가질수 있다
    * 기본타입이 박싱된 기본타입보다 시간과 메모리 사용면에서 더 효율적이다

- 이러한 차이 때문에 주의하지 않고 사용하면 진짜 문제가 발생할 수 있다

```java
Comparator<Integer> naturalOrder = (i,j) -> (i < j) ? -1 : (i == j ? 0 : 1);
```

- Integer값을 오름차순으로 정렬하는 비교자이다. Integer는 그 자체로 순서가 있어 실질적인 의미는 없지만, 흥미로운것을 하나 보여준다
- 이 코드에는 보이지 않는 결함이 하나 숨어있다. ```naturalOrder.compare(new Integer(42), new Integer(42))``` 의 값을 출력해보면 0이 아닌 1이 출력될것이다. 즉 첫번째가 두번째보다 크다고 할것이다
- 원인은 첫번째 검사(i < j)는 잘 작동하지만, 여기서 i와 j가 참조하는 오토박싱된 Integer 인스턴스는 기본 타입값으로 변환된다. 그 이후 첫번째 정수값이 두번째 정수값보다 작은지 평가하며, 만약 작지 않다면 두번째 검사(i == j)가 이뤄진다.그런데 이 두번째 검사에서 두 '객체 참초'의 식별성을 검사하게 된다. i와 j가 서로 다른 Integer인스턴스라면 비록 값은 같더라도 이 비교의 결과는 false가 되고, 비교자가 1을 반환하게 되는것이다
- 이처럼 박싱된 기본타입에 == 연산자를 사용하면 오류가 발생한다
- 실무에서 이과 같이 기본타입을 다루는 비교자가 필요하다면 Comparator.naturalOrder()를 사룔해야 한다. 비교자를 직접 만들려면 비교자 생성 메서드나 기본 타입을 받는 적적 compare메서드를 사용해야 한다
    * 그렇다 하더라도 이 문제를 고치려면 지역변수 2개를 두어 각각 박싱된 Integer 매개변수의 값을 기본 타입 정수로 저장한다음, 모든 비교를 이 기본타입 변수로 수행해야한다

```java
Comparator<Integer> naturalOrder = (iBoxed, jBoxed) -> {
    int i = iBoxed, j = jBoxed;
    return i < j ? -1 : (i == j ? 0 : 1); 
};
```

- 또 한가지 간단한 예를 보자

```java
public class Unbelievable {
    static Integer i;

    public static void main(String[] args) {
        if (i == 42)
            System.out.println("Unbelievable!");
    }
}
```

- 이 프로그램은 Unbelievable을 출력하지 않지만, i == 42 검사를 할때, NullPointerException을 던지는것이다
- 원인은 i가 int가 아닌 Integer이며, 다른 참조타입 필드와 마찬가지로 i의 초깃값도 null이라는 데도 있다. 즉 i == 42는 Integer와 int를 비교하는것이다
- 거의 예외 없이 기본 타입과 박싱된 기본타입을 혼용한 연산에서는 박싱된 기본 타입의 박싱이 자동으로 풀린다. 그리고 null 참조를 언박싱하면 NullPointerException이 발생한다
- 해결방법은 간단한데, i를 int로 선언해주면 된다
- 또 한가지 예시를 보자

```java
public static void main(String[] args) {
    Long sum = 0L;
    for(long i = 0; i <= Integer.MAX_VALUE; i++) {
        sum += i;
    }
    System.out.println(sum);
}
```

- 이 프로그램은 실수로 지역변수 sum을 박싱된 기본타입으로 선언하여 느려졌다. 오류나 경고없이 컴파일 디지만, 박싱과 언박싱이 반복해서 일어나 체감될정도로 성능이 느려진다
- 이번 아이템에서 다룬 세 프로그램 모두 문제의 원인은 하나다. 프로그래머가 기본 타입과 박싱된 기본 타입의 차이를 무시한 대가를 치른것이다. 처음의 두 프로그램은 뼈아픈 실패로 이뤄졌고, 마지막은 심각한 성능 문제가 발생하였다
- 그렇다면 박싱된 기본 타입은 언제 써야 하는가? 적절히 쓰이는 경우는 다음가 같다
    * 컬렉션의 원소, 키, 값으로 쓴다. 컬렉션은 기본 타입을 담을수 없으므로 어쩔수없이 그래야만 한다
    * 매개변수화 타입이나 매개변수화 메서드의 타입 매개변수로는 박싱된 기본 타입을 써야한다. 자바가 타입 매개변수로 기본 타입을 지원하지 않기 때문이다
    * 리플렉션을 통해 메서드를 호출할때도 박싱된 기본 타입을 사용해야 한다