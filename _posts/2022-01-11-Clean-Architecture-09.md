---
layout: post
title: "Clean Architecture 9장 - 애플리케이션 조립하기"
description: Clean Architecture 9장 
date: 2022-01-11 22:00:00 +09:00
categories: Clean Architecture Study
---

# 애플리케이션 조립하기

## 왜 조립까지 신경써야 할가
- 코드 의존성이 올바른 방향을 가리키게 하기 위해서 필요함. 모든 의존성은 안쪽으로, 애플리케이션의 도메인 코드 방향으로 향해야 도메인 코드가 바깥 계층의 변경으로부터 안전함
- 이런 프로그래밍 스타일의 유익한점은 코드의 테스트 용이성이 올라간다는것
- 그럼 객체 인스턴스를 생성할 책임은 누구에게 있을까? 그리고 의존성 규칙을 어기지 않으면서 어떻게 그렇게 가능할까? 답은 아키텍처에 대해 중립적이고 인스턴스 생성을 위해 모든 클래스에 대한 의존성을 가지는 설정 컴포넌트임

## 평범한 코드로 주입하기
- 볼필요 없다. 스프링 프레임워크가 해줄것이다

## 스프링의 클래스패스 스캐닝으로 조립하기
- 스프링은 클래스 패스 스캐닝으로 클래스 패스에서 접근 가능한 모든 클래스를 확인해 ```@Component```가 붙은 클래스를 찾아, 그 클래스의 객체를 생성한다(그 클래스는 필요한 모든 필드를 인자로 받는 생성자가 있어야함)
- 스프링에서 생성자를 찾아 생성자의 인자로 사용된 ```@Component```가 붙은 클래스들을 찾고 그 클래스들의 인스턴스를 찾아 애플리케이션 컨텍스트에 추가한다
- 스프링이 인식할수있는 어노테이션을 직접 만들수 있다. 메타 어노테이션으로 ```@Component``` 를 가지고 있으면 된다
- 클래스 패스 스캐닝 방식에는 클래스에 프레임워크에 특화된 어노테이션을 붙여야한다는 단점이 있다
- 또 클래스 패스 스캐닝이 애플리케이션 조립에 사용하기에 너무 둔한 도구이기 때문에, 의도치 않은 부수 효과가 일어날수도 있다는 단점이 있다

## 자바 컨피그로 조립하기
- ```@Configuration``` 어노테이션을 통해 클래스가 스프링의 클래스 패스 스캐닝에서 발견해야할 설정 클래스임을 표기한다. 아직도 클래스 패스 스캐닝을 쓰는것이지만, 모든 빈을 가져오는것 대신 설정 클래스만 선택하기 때문에 부수효과가 적다
- 빈 자체는 설정 클래스 내에 ```@Bean``` 어노테이션이 붙은 팩토리 메서드를 통해 생성. 이를 통해 어떤 빈이 어플리케이션 컨텍스트에 등록될지 제어 가능
- 특정 모듈만 포함하고 그 외의 다른 모듈의 빈은 모킹해서 어플리케이션 컨텍스트를 만들수도 있는데, 이러면 테스트에 큰 유연성이 생김
- 클래스 패스 스캐닝 방식과 달리 ```@Component```를 여기 저기에 강제하지 않아서, 어플리케이션 계층을 스프링 프레임워크에 대한 의존성 없이 깔끔하게 유지 가능
- 단점으로는 설정 클래스가 생성하는 빈이 설정 클래스와 같은 패키지가 아니라면 이 빈들을 public으로 만들어야 함

## 유지보수 가능한 소프트웨어를 만드는덴 어떻게 도움이 될까
- 스프링에게 패키지만 알려주면 스프링이 스스로 애플리케이션을 조립한다
- 코드의 규모가 커지먼 금방 투명성이 낮아지고, 테스트에서 어플리케이션 컨텍스트 일부만 띄우는게 힘들어진다