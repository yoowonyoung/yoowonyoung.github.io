---
layout: post
title: "Clean Architecture 1장 - 계층형 아키텍처의 문제는 무엇일까?"
description: Clean Architecture 1장 
date: 2021-12-08 21:00:00 +09:00
categories: Clean Architecture Study
---

# 계층형 아키텍처의 문제는 무엇일까
- 계층으로 구성된 애플리케이션들을 개발 해본적이 있을 것이다
    * 웹 -> 도메인 -> 영속성 계층으로 구성된 전통적인 웹 애플리케이션 구조
    * 웹 계층: 요청을 받아 도메인 혹은 비즈니스 계층에 있는 서비스로 요청을 보냄
    * 도메인 계층(비즈니스 계층): 서비스에서 필요한 비즈니스 로직을 수행하고 도메인 엔티티의 현재 상태를 조회하거나 변경하기 위해 영속성 계층의 컴포넌트 호출

- 사실 계층형 아키텍처는 견고한 아키텍처 패턴이다. 계층을 잘 이해하고 구성한다면 웹 계층이나 도메인 계층에 독립적으로 도메인 로젝을 작성할 수 있다
- 원한다면 도메인 로직에 영향을 주지 않고 웹 계층과 영속성 계층에 사용된 기술을 변경할수 있으며, 기존 기능에 영향을 주지 않고 새 기능을 개발 할수도 있다
- 하지만 계층형 아키텍처는 코드에 나쁜 습관들이 스며들기 쉽게 만들고, 시간이 지날수록 소프트웨어를 점점 더 변경하기 어렵게 만드는 수많은 허점들을 노출한다

## 계층형 아키텍처는 데이터베이스 주도 설계를 유도한다
- 전통적인 계층형 아키텍처의 토대는 데이터 베이스이다
- 웹 계층은 도메인 계층에 의존하고, 도메인 계층은 영속성 계층에 의존하기 때문에 자연스레 데이터 베이스에 의존하게 된다
- 대부분의 애플리케이션의 목적은 비즈니스를 관장하는 규칙이나 정책을 반영한 모델을 만들어서 사용자가 이러한 규칙이나 정책을 더 편리하게 활용함에 있는데, 이때 우리는 상태가 아닌 행동을 중심으로 모델링 한다
- 그동안의 경험을 토대로 생각해보면, 도메인 로직이 아닌 데이터베이스의 구조를 먼저 생각하고, 이를 토대로 도메인 로직을 구현했을것이다. 이는 전통적인 계층형 아키텍처에서는 합리적이며, 의존성의 방향에 따라 자연스럽게 구현된것이다
- 하지만 비즈니스 관점에서 생각 해보면, 다른 무엇보다도 도메인 로직을 먼저 만들어야 우리가 도메인 로직을 제대로 이해 했는지 확인할수 있다
- 데이터 중심적인 아키텍처가 만들어지는 가장 큰 원인은 ORM 프레임워크인데, ORM 프레임워크가 나쁘단게 아니라, ORM 프레임워크가 계층형 아키텍처와 결합하면 비즈니스 규칙을 영속성 관점과 섞고싶은 유혹을 만들기 때문이다
- ORM에 의해 관리되는 엔티티들은 일반적으로 영속성 계층에 두는데, 도메인 계층에서는 이런 엔티티에 접근 할 수 있으며, 그 결과 영속성 계층과 도메인 계층 사이에 강한 결합이 생긴다
- 서비스는 영속성 모델을 비즈니스 모델처럼 사용하게 되고, 이로 인해 도메인 로직 뿐만 아니라 즉시 로딩, 지연 로딩, 데이터베이스 트랜젝션, 캐시 플러시 등등 영속성과 관련된 작업들을 해야만 한다
- 영속성 코드가 사실상 도메인 코드에 녹아들어가서 둘중 하나만 바꾸는것이 어려워지게 되며, 이는 유연하고 선택의 폭을 넓혀준다던 계층형 아키텍처의 목표와 정확히 반대가 되는 상황이다

## 지름길을 택하기 쉬워진다
- 계층형 아키텍처에서 전체적으로 적용되는 유일한 규칙은, 특정 계층에서는 같은 계층에 있는 컴포넌트나 아래에 있는 계층에만 접근 가능하다는 것이다
- 만약 상위 계층에 위치한 컴포넌트에 접근해야 한다면, 간단하게 컴포넌트를 계층 아래로 내려버리면 된다. 그러면 접근 가능하게 되고 깔끔하게 문제가 해결된다
- 딱 한번쯤은 괜찮을수도 있겟지만, 깨진 창문 이론으로 생각해보면 처음 한번이 어렵지 한번 이렇게 내려버리면 계속 내리게 될것이다
- 영속성 계층은 컴포넌트를 아래 계층으로 내릴수록 비대해지며, 어떤 계층에도 속하지 않는것처럼 보이는 헬퍼나 유틸리티들이 이처럼 아래 계층으로 내릴 가능성이 큰 후보이다

## 테스트 하기 어려워진다
- 계층형 아키텍처를 사용할때 일반적으로 나타나는 변화의 형태는 계층을 건너뛰는것이다. 예를 들어 엔티티의 필드를 단 하나만 조작하면 되는 경우에는 웹 계층에서 바로 영속성 계층에 접근하면 도메인 계층을 건드릴 필요가 없게되는 그런 경우가 있다
- 이런 경우 2가지 문제가 발생하는데, 먼저 첫번째 문제는 도메인 로직을 웹 계층에서 구현하게 된다는것이다. 앞으로 유스케이스가 확장된다면 더 많은 도메인 로직이 웹 계층에 추가될것이고 애플리케이션 전반에 걸쳐 책임이 섞이고 핵심 도메인 로직들이 퍼져나가게 될것이다
,로 생각해보면 처음 한번이 어렵지 한번 이렇게 내려버리면 계속 내리게 될것이다
- 영속성 계층은 컴포넌트를 아래 계층으로 내릴수록 비대해지며, 어떤 계층에도 속하지 않는것처럼 보이는 헬퍼나 유틸리티들이 이처럼 아래 계층으로 내릴 가능성이 큰 후보이다

## 테스트 하기 어려워진다
- 계층형 아키텍처를 사용할때 일반적으로 나타나는 변화의 형태는 계층을 건너뛰는것이다. 예를 들어 엔티티의 필드를 단 하나만 조작하면 되는 경우에는 웹 계층에서 바로 영속성 계층에 접근하면 도메인 계층을 건드릴 필요가 없게되는 그런 경우가 있다
- 이런 경우 2가지 문제가 발생하는데, 먼저 첫번째 문제는 도메인 로직을 웹 계층에서 구현하게 된다는것이다. 앞으로 유스케이스가 확장된다면 더 많은 도메인 로직이 웹 계층에 추가될것이고 애플리케이션 전반에 걸쳐 책임이 섞이고 핵심 도메인 로직들이 퍼져나가게 될것이다
- 두번째 문제는 웹 계층 테스트에서 도메인 계층 뿐만 아니라 영속성 계층도 모킹해야 한다는것이다. 이렇게 되면 단위 테스트의 복잡도가 올라갈것이다
- 시간이 흘러 웹 컴포넌트의 규모가 커지면서 다양한 영속성 컴포넌트에 의존성이 많이 쌓이다보면 테스트의 복잡도가 올라가고, 어느 순간엔 테스트 코드를 작성하는것보다 종속성을 이해하고 mock을 만드는데 더 많은 시간이 걸릴 것이다

## 유스케이스를 숨긴다
- 개발자들은 새로운 유스케이스를 구현하는데 새로운 코드를 짜는것을 선호하지만, 실제로는 새로운 코드를 짜는데 쓰는 시간보다 기존 코드를 바꾸는데 쓰는 시간이 더 많다
- 이때문에 아키텍처는 코드를 빠르게 탐색하는데 도움이 되야 하지만, 도메인 로직이 여러 계층에 걸쳐 흩어져버린다면 새로운 기능을 추가할 적당한 위치를 찾기란 매우 어려울 것이다
- 더 심각한 문제로는, 계층형 아키텍처는 도메인 서비스의 너비에 관한 규칙을 강제하지 않기 때문에 여러개의 유스케이스를 담당하는 아주 넓은 서비스가 만들어지기도 한다는것이다. 넓은 서비스는 영속성 계층에 많은 의존성을 갖게되고, 그럼 테스트하기도 어렵고 난감할것이다

## 동시 작업이 어려워진다
- 계층형 아키텍처는 동시 작업 측면에서는 그다지 도움이 되지 않는다
- 애플리케이션에 새로운 유스케이스를 추가 한다고 생각해보면, 누군가는 웹 계층에, 누군가는 도메인 계층에, 누군가는 영속성 계층에 기능을 추가 할 수 있을까? 계층형 아키텍처에서는 모든것이 영속성 계층 위에 만들어지기 때문에 힘들다. 영속성 계층이 먼저 개발되야 하기 때문이다
- 개발자들이 인터페이스를 먼저 같이 적용하고, 인터페이스들로 작업 하면 된다고 할수도 있지만, 이는 데이터베이스 주도 설계를 하지 않는 경우에만 가능하다
- 코드에 넓은 서비스가 있다면 서로 다른 기능을 동시에 작업하기가 더욱 어려울 것이다

## 유지보수 가능한 소프트웨어를 만드는데 어떻게 도움이 될까?
- 올바르게 구축하고 몇가지 추가적인 규칙들을 적용한 계층형 아키텍처는 유지보수하기 매우 쉽고 코드를 쉽게 변경하거나 추가할 수 있다
- 하지만 엄격한 자기훈련 없이는 시간이 지날수록 품질이 저하되고 유지보수하기가 매우 어려워지기 쉽다
- 계층형 아키텍처로 만들든, 다른 아키텍처 스타일로 만들든, 계층형 아키텍처의 함정을 염두에 두면 지름길을 택하지 않고 유지보수 하기에 더 쉬운 솔루션을 만드는데 도움이 될것이다