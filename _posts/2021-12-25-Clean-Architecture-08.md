---
layout: post
title: "Clean Architecture 8장 - 경계간 매핑하기"
description: Clean Architecture 8장 
date: 2021-12-25 17:45:00 +09:00
categories: Clean Architecture Study
---

# 경계간 매핑하기

## 매핑하지 않기 전략
- 웹 계층에서 웹 컨트롤러가 유스케이스 인터페이스를 호출해서 유스케이스를 실행. 이 인터페이스가 가지고 있는 모델은 웹 계층과 애플리케이션 계층 모두에서쓰임(두 계층이 같은 모델을 사용한다는것)
- 영속성 계층과 애플리케이션 계층도 같은 관계. 모든 계층이 같은 모델을 사용하니 계층간 매핑을 전혀 할 필요가 없음
- 웹 계층과 영속성 계층은 모델에 대해 특별한 요구사항이 있을 수 있음(모델을 JSON으로 직렬화 하기 위해 어노테이션이 필요, 데이터베이스 매핑을 위한 어노테이션 필요)
- 도메인 계층이나 어플리케이션 계층은 웹이나 영속성 계층에 관련된 특수한 요구사항에 관심이 없어도 도메인 모델 클래스가 이 모든 요구사항을 다뤄야함
- 모메인 모델 클래스는 웹, 애플리케이션, 영속성 계층과 관련된 이유료 변경되어야 하니 단일 책임 원칙 위반
- 각 계층이 도메인 모델 클래스에 특정 커스텀 필드를 두도록 요구 할수도 있는데, 오로지 한 계층에서만 필요로 하는 필드를 포함하는 파편화된 도메인 모델로 이어질수도 있음
- 모든 계층이 정확히 같은 구조의, 정확히 같은 정보를 필요로 한다면 이런 전략은 좋음

## 양방향 매핑 전략
- 각 계층은 도메인 모델과는 완전히 다른 구조의 전용 모델을 가지고 있음
- 웹 계층에서는 웹 모델을 인커밍 포트에서 필요한 도메인 모델로 매핑하고, 인커밍 포트에 의해 반환된 도메인 객체를 다시 웹 모델로 매핑
- 영속성 계층은 아웃고잉 포트가 사용하는 도메인 모델과 영속성 모델간의 매핑과 유사한 매핑을 담당
- 두 계층 모두 양방향으로 매핑하기 때문에 양방향 매핑
- 각 계층이 전용 모델을 가지고 있기 떄문에, 각 계층이 전용 모델을 변경하더라도 다른 계층에 영향이 가지 않음
- 웹이나 영속성 관심사로 오염되지 않은 꺠끗한 도메인 모델로 이어짐. 단일 책임의 원칙도 만족
- 또한 매핑 책임이 명확함. 바깥쪽 게층/어댑터는 안쪽 계층의 모델로 매핑하고, 다시 반대방향으로 매핑. 안쪽 계층은 해당 계층의 모델만 알면 됨
- 반면에 너무 많은 보일러플레이트 코드가 생기고, 도메인 모델이 계층 경계를 넘어 통신하는데 사용됨(인커밍 포트와 아웃고잉 포트는 도메인 객체를 입력 파라미터와 반환값으로 사용하기 떄문)

## 완전 매핑 전략
- 각 연산마다 별도의 입출력 모델을 사용
- 계층 경계를 넘어 통신할때는 도메인 모델을 사용하는 대신 각 작업에 특화된 모델을 사용. 이런 모델을 가르켜 Command, Request 등과 같이 씀
- 웹 계층은 입력을 애플리케이션 계층의 커맨드 객체로 매핑할 책임을 가지고 있음. 이러한 커맨드 객체는 애플리케이션 계층의 인터페이스를 해석할 여지 없이 명확하게 만들어줌
- 각 유스케이스는 전용 필드와 유효성 검증 로직을 가진 전용 커맨드를 가짐
- 애플리케이션 계층은 커맨드 객체를 유스케이스에 따라 도메인 모델을 변경하기 위해 필요한 무언가로 매핑할 책임을 가진다
- 매핑에 많은 코드가 필요하지만 여러 유스케이스의 요구사항을 함꼐 다뤄야 하는 매핑구조에 비해 구현하고 유지보수 하기가 쉽다
- 이 매핑 전략은 웹 계층과 애플리케이션 계층 사이에서 상태 변경 유스케이스의 경계를 명확히 할때 가장 빛을 발한다
- 연산의 입력모델에 대해서만 이 매핑을 사용하고, 도메인 객체를 그대로 출력 모델로 사용하는것도 좋다

## 단방향 매핑 전략
- 모든 계층의 모델들이 같은 인터페이스를 구현한다. 이 인터페이스는 관련있는 특성에 대한 getter 메서드를 제공해서 도메인 모델의 상태를 캡슐화 한다
- 도메인 모델 자체는 풍부한 행동을 구현할수있고, 애플리케이션 계층내 서비스에서 이러한 행동에 접근할수있다. 도메인 객체를 바깥계층으로 전달하고싶으면 매핑없이 전달이 가능한데 인터페이스를 구현했기 때문이다
- 바깥계층에서는 상태 인터페이스를 사용할지 전용 모델로 매핑할지 결정할수있는데, 행동을 변경하는것은 인터페이스에 의해 노출되지 않기 때문에 도메인 객체의 상태는 바뀌지 않는다
- 바깥계층에서 애플리케이션 계층으로 전달하는 객체들도 이 상태 인터페이스를 구현 하는데, 애플리케이션 계층에서는 이 객체를 실제 도메인 모델로 매핑해서 도메인 모델의 행동에 접근할수 있게 된다
- 한 계층이 다른 계층으로부터 객체를 받으면 해당 계층에서 사용 가능한 다른 무언가로 매핑하기때문에, 각 계층은 한 방향으로만 매핑해서 단방향 매핑 전략이다. 이 전략은 계층간의 모델이 비슷할때 효과적이다

## 언데 어떤 매핑 전략을 사용할것인가
- 그때 그때 다르다
- 변경 유스케이스를 작업 하고 있다면 웹 계층과 애플리케이션 계층 사이에서는 유스케이스간의 결합을 제거하기 위해 완전 매핑 전략을 첫번째로 선택해야 한다
- 변경 유스케이스를 작업 하고 있다면 애플리케이션과 영속성 계층 사이에서는 매핑 오버헤드를 줄이고 빠르게 코드를 짜기 위해서 매핑하지 않기 전략을 첫번째 선택지로 둔다
- 쿼리 작업을 하고 있다면 매핑 오버헤드를 줄이고 빠르게 코드를 짜기 위해 매핑하지 않기 전략이 웹 계층과 애플리케이션 계층 사이, 애플리케이션 계층과 영속성 계층 사이에서 첫번째 선택지가 돼야 한다. 하지만 애플리케이션 계층에서 영속성 문제나 웹 문제를 다뤄야 한다면 양방향 매핑 전략으로 바꿔야 한다
