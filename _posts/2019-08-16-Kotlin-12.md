---
title: "Kotlin Study - 07 연산자 오버로딩과 기타 관례 -1"
date: 2019-08-16 19:47:00 
categories: kotlin study
---

# 연산자 오버로딩과 기타 관례

## 산술 연산자 오버로딩

### 이항 산술 연산 오버로딩

~~~
data class Point(val x:Int, val y: Int) {
  operator fun plus(other :Point) :Point {
    return Point(x + other.x, y + other.y)
  }
}

val p1 = Point(10,10)
val p2 = Point(20,20)
println(p1 + p2)
==> Point(x=30,y=30)
~~~

* 연산자를 오버로딩 하는 함수 앞에는 꼭 operator가 있어야 한다
* 이러한 연산자는 멤버 함수로 만드는 대신 확장 함수로 정의 할 수도 있다
* 코틀린에서는 프로그래머가 직접 연산자를 만들어 사용 할 수 없고 언어에서 미리 정해둔 연산자만 오버로딩 할 수 있다
  - *(times), /(div), %(mod / 1.1부터는 rem), +(plus), -(minous) 만 된다
* 이러한 연산자의 우선 순위는 언제나 표준 숫자 타입에 대한 연산자 우선순위와 같다
* 연산자를 정의 할 때 두 피연산자가 같은 타입일 필요는 없다
* 하지만 두 타입이 다를 경우, 코틀린은 자동 교환 법칙이 성립하지 않음에 주의 해야 한다
* 함수의 반환 타입이 꼭 두 피연산자중 하나와 일치해야할 필요도 없다
* 코틀린은 표준 숫자 타입에 대한 비트 연산자를 정의 하지 않기 때문에 이에 주의 해야 한다

### 복합 대입 연산자 오버로딩
* + 연산을 오버로딩 할 경우 +와 관련이 있는 += 도 자동으로 오버로딩 된다
* 경우에 따라 += 연산이 객체에 대한 참조를 바꾸기 보단 원래 객체의 내부 상태를 변경하는것으로 쓰고 싶을때는, 반환타입이 Unit 인 plusAssign을 정의 하면된다
  - 코틀린 표준 라이브러리는 변경 가능한 컬렉션에 대해 plusAssign을 정의 한다

### 단항 연산자 오버로딩
~~~
operator fun Point.unaryMinous() :Point {
  return Point(-x,-y)
}

val p = Point(10,20)
println(-p)
==> Point(-10,-20)
~~~

* 단항 연산자를 오버로딩 하기 위해 사용하는 함수는 인자를 취하지 않는다
* 코틀린은 다음과 같은 단항 연산자에 대한 오버로딩을 지원 한다
  - +a(unaryPlus), -a(unaryMinous), !a(not), ++a,a++(inc), --a,a--(dec)

