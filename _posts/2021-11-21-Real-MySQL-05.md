---
layout: post
title: "Real MySQL 08 : 인덱스"
description: Real MySQL 8장 - 인덱스
date: 2021-11-21 12:37:00 +09:00
categories: MySQL RealMySQL Study
---

# 인덱스

## 디스크 읽기 방식
- 데이터베이스의 성능 튜닝은 디스크 I/O를 어떻게 줄이느냐가 관건

### HDD와 SSD
- 디스크의 헤더를 움직이지 않고 한번에 많은 데이터를 읽는 순차 I/O에서는 SSD가 하드디스크보다 조금 더 빠르거나 거의 비슷한 성능
- SSD의 장점은 하드디스크보다 랜덤 I/O가 훨씬 빠르다는것
- 데이터베이스 서버에서 순차 I/O의 비중이 크지 않고 랜덤 I/O를 통해 작은 데이터를 읽고 쓰는 작업이 대부분이므로, SSD의 장점은 RDBMS용 스토리지에 최적이라고 할 수 있음

### 랜덤 I/O와 순차 I/O
- 3개의 데이터를 디스크에 기록 한다고 할 때, 순차 I/O는 3개의 페이지를 디스크에 기록하기 위해 1번 시스템 콜을 하지만, 랜덤 I/O는 3개의 페이지를 디스크에 기록하기 위해 3번 시스템 콜을 요청함. 디스크에 기록할 위치를 찾기 위해 순차 I/O는 디스크의 헤드를 1번 움직이고, 랜덤 I/O는 3번 움직임
- 디스크에 데이터를 읽고 쓰는데 걸리는 시간은 디스크 헤더를 움직여서 읽고 쓸 위치로 옮기는 단계에 의해서 결정. 즉, 디스크의 성능은 디스크 헤더의 위치 이동 없이 얼마나 많은 데이터를 한번에 기록하느냐에 의해 결정. 그래서 여러번 쓰기 또는 읽기를 요청하는 랜덤 I/O 작업이 작업 부하가 훨씬 더 큼
- 쿼리를 튜닝해서 랜덤 I/O를 순차 I/O로 바꿔서 실행할 방법은 그다지 많지 않음. 쿼리를 튜닝하는 것은 랜덤 I/O 자체를 줄여주는것이 목적. 쿼리를 처리하는데 꼭 필요한 데이터만 읽도록 쿼리를 개선하는것

## 인덱스란?
- DBMS도 데이터베이스 테이블의 모든 데이터를 검색해서 원하는 결과를 가져오려면 시간이 오래걸리기 떄문에 칼럼(또는 칼럼들)의 값과 해당 레코드가 저장된 주소를 키와 값의 쌍으로 삼아 인덱스를 만들어 둠
- DBMS의 인덱스는 칼럼의 값을 주어진 순서로 미리 정렬해서 보관
- DBMS의 인덱스는 SortedList와 마찬가지로 저장되는 칼럼의 값을 이용해서 항상 정렬된 상태를 유지(데이터 파일은 ArrayList와 같이 저장된 순서대로 별도의 정렬 없이 그대로 저장)
- DBMS의 인덱스가 많은 테이블은 당연히 INSERT, UPDATE, DELETE 문장의 처리가 느려지지만, SELECT 문장은 아주 빠르게 처리 가능
- 결론적의로 DBMS에서 인덱스는 데이터의 저장(INSERT, UPDATE, DELETE)의 성능을 희생하고 그 대신 데이터의 읽기 속도를 높이는 기능. 테이블의 인덱스를 하나 더 추가할지 말지는 데이터의 저장 속도를 어디까지 희생할 수 있는지, 읽기 속도를 얼마나 더 빠르게 만들어야 하는지에 따라 결정
- SELECT 쿼리 문장의 WHERE 조건절에 사용되는 칼럼이라고 해서 전부 인덱스로 생성하면 데이터 저장 성능이 떨어지고, 인덱스의 크기가 비대해져 오히려 역효과만 불러올 수 있음
- 인덱스를 역할별로 구분하면 프라이머리 키와 세컨더리 키로 구분할 수 있음
    * 프라이머리 키: 레코드를 대표하는 칼럼의 값으로 만들어진 인덱스, 테이블에서 해당 레코드를 식별하는 기준값이기 때문에 식별자 라고도 부르며, NULL을 허용하지 않고 중복을 허용하지 않음
    * 세컨더리 키: 프라이머리 키를 제외한 모든 나머지 인덱스. 유니크 인덱스는 프라이머리 키와 성격이 비슷하고 프라이머리 키를 대체해서 사용 할 수도 있다고 해서 대체키라고 하기도 함

- 인덱스를 데이터 저장 방식(알고리즘)별로 구분하면 대표적으로 B-Tree 인덱스와 Hash 인덱스로 구분 가능
    * B-Tree 알고리즘: 칼럼의 값을 변형하지 않고 원래의 값을 이용해 인덱싱. MySQL에서는 위치 기반 검색을 지원하기 위한 R-Tree 알고리즘도 있지만 R-Tree 알고리즘도 결국 B-Tree의 응용 알고리즘
    * Hash 알고리즘: 칼럼의 값으로 해시값을 계산해서 인덱싱 하는 알고리즘. 매우 빠른 검색 지원. 값을 변형해서 인덱싱 하므로 전방 일치와 같이 값의 일부만 검색하거나 범위를 검색 할때는 해시 인덱스를 사용 할 수 없음. 메모리 기반의 데이터베이스에서 많이 사용

- 데이터의 중복 허용 여부로 분류하면 유니크 인덱스와 유니크 하지 않은 인덱스로 구분
- 인덱스의 기능별로 분류 해보면 전문 검색용 인덱스나 공간 검색용 인덱스등이 있음

## B-Tree
- 데이터 베이스의 인덱싱 알고리즘 가운데 가장 일반적이고, 가장 먼저 도입되었으며, 가장 범용적으로 사용
- B-Tree는 칼럼의 원래 값을 변형시키지 않고 인덱스 구조체 내에서는 항상 정렬된 상태로 유지

### 구조 밎 특성
- B-Tree는 최상위에 하나의 루트 노드가 존재하고 그 하위에 자식 노드가 붙어있는 형태. 트리 구조의 가장 하위 노드를 리프 노드 라고 하며, 루트 노드도 아니고 리프 노드도 아닌 중간의 노드를 브랜치 노드라고 함
- 데이터베이스에서 인덱스와 실제 데이터가 저장된 데이터는 따로 관리 되는데, 인덱스의 리프노드는 항상 실제 데이터 레코드를 쫒아가기 위한 주솟값을 가지고 있음
- 인덱스의 키 값은 모두 정렬 되어있지만, 데이터 파일의 레코드는 정렬 되있지 않고 임의의 순서대로 저장 돼 있음
- 인덱스는 테이블의 키 칼럼만 가지고 있으므로 나머지 칼럼을 읽으러면 데이터 파일에서 해당 레코드를 찾아야 함
- InnoDB 테이블에서 인덱스를 통해 레코드를 읽을 때에는 데이터를 바로 찾아가지 못하고, 인덱스에 저장되어있는 프라이머리 키 값을 이용해 프라이머리 키 인덱스를 한번 더 검색후 프라이머리 키 인덱스의 리프 페이지에 저장 돼있는 레코드를 읽음. 즉, 모든 세컨더리 인덱스 검색에서 데이터 레코드를 읽기 위해 반드시 프라이머리 키를 저장하고 있는 B-Tree를 다시 한번 검색 해야함

### B-Tree 인덱스 추가 및 삭제
- 추가
    * 새로운 키 값이 B-Tree에 저장 될 때에는 테이블의 스토리지 엔진에 따라 새로운 키 값이 즉시 저장 될 수도, 그렇지 않을 수도 있음. MyISAM이나 MEMORY스토리지 엔진은 즉시, InnoDB 스토리지 엔진은 필요시 인덱스 키 추가작업을 지연
    * B-Tree에 저장될 때는 저장될 키 값을 이용해 B-Tree상의 적절한 위치를 검색 해야함. 저장될 위치가 결정되면 레코드의 키 값과 대상 레코드의 주소 정보를 B-Tree의 리프 노드에 저장
    * 리프 노드가 꽉차서 더는 저장 할 수 없을때는 리프 노드가 분리 되야 하는데, 이때 상위 브랜치 노드까지 처리의 범위가 넓어져 B-Tree는 상대적으로 쓰기 작업에 비용이 많이듬

- 삭제
    * 해당 키 값이 저장된 B-Tree의 리프 노드를 찾아 그냥 삭제 마크만 하면 작업이 완료
    * 삭제 마킹된 인덱스 키 공간은 계속 그대로 방치하거나 재활용 가능
    * 인덱스 키 삭제로 인한 마킹 작업 또한 디스크 쓰기가 필요 하므로 디스크 I/O가 필요한 작업. 따라서 버퍼링 되어 지연 처리 가능

- 변경
    * 인덱스의 키 값은 그 값에 따라 저장될 리프 노드의 위치가 결정 되므로 B-Tree의 키 값이 변경되는 경우에는 단순히 인덱스 상의 키 값만 변경하는것은 불가능
    * B-Tree의 키 값 변경 작업은 먼저 키 값을 삭제한 후, 다시 새로운 키 값을 추가하는 형태로 처리

- 검색
    * 인덱스를 검색하는 작업은 B-Tree의 루트 노드부터 시작해서 브랜치 노드를 거쳐 최종 리프 노드까지 이동하면서 비교 작업을 수행 하는데, 이를 트리 탐색이라고 함
    * 인덱스 트리 탐색은 SELECT에서만 사용 하는것이 아니라, UPDATE나 DELETE를 처리하기 위해 항상 해당 레코드를 먼저 검색 해야 할 경우에도 사용
    * B-Tree 인덱스를 이용한 검색은 100% 일치 또는 값의 앞 부분만 일치하는 경우에 사용 가능
    * 부등호(<,>) 비교 조건에서도 인덱스를 활용할 수 있지만, 인덱스를 구성하는 키 값의 뒷부분만 검색하는 용도로는 사용 할 수 없음
    * 인덱스의 키 값에 변형이 가해진 후 비교 되는 경우에는 사용할 수 없는데, 변형된 값은 B-Tree에 존재하는 값이 아니기 때문
    * InnoDB 스토리지 엔진에서는 레코드 잠금이나 넥스트 키락이 검색을 수행한 인덱스를 잠근 후 테이블의 레코드를 잠그는 방식으므로, UPDATE나 DELETE가 실행될 때 테이블에 적절한 인덱스가 없다면 불필요하게 많은 레코드가 잠김

### B-Tree 인덱스 사용에 영향을 미치는 요소
- 키 값의 크기
    * InnoDB 스토리지 엔진에서 디스크에 데이터를 저장하는 가장 기본 단위를 페이지 또는 블록이라고 하며, 디스크의 모든 읽기 및 쓰기 작업의 최소 작업 단위. 버퍼링의 기본 단위이기도 함. 인덱스도 결국 페이지 단위로 관리. 루트와 브랜치 그리고 리프 노드를 구분한 기준이 페이지 단위
    * B-Tree는 자식의 개수가 가변적인 구조 이므로, 기본 페이지 크기값인 16kb기준으로 인덱스의 키가 16바이트라고 가정 하면 하나의 인덱스 페이지에 585개의 자식 노드를 가질 수 있음. 인덱스 키 값이 커지면, 그에 따라 가질 수 있는 자식 노드의 수가 줄어들음
    * 인덱스의 키 값의 길이가 길어진다는 것은 전체적인 인덱스의 크기가 커진다는 것으로, 인덱스를 캐시 해두는 InnoDB의 버퍼 풀은 크기가 제한적이기 때문에, 하나의 레코드를 위한 인덱스 크키가 커지면 커질수록 메모리에 캐시해 둘 수 있는 레코드 수는 줄어들어 메모리의 효율이 떨어짐

- B-Tree 깊이
    * B-Tree 인덱스의 깊이는 상당히 중요 하지만, 직접 제어할 방법은 없음
    * 인덱스 키 값이 늘어나면 늘어날수록 하나의 인덱스 페이지가 담을 수 있는 인덱스 키 값의 개수가 적어지고, 그때문에 같은 레코드 건수라고 하더라도 B-Tree의 깊이가 깊어져 더 많은 디스크 읽기가 필요해짐
    * 일반적으로 5단계 이상 깊어지지 않음

- 선택도(기수성)
    * 선택도 또는 기수성은 거의 같은 의미로 사용 되며, 모든 인덱스 키 값 가운데 유니크한 값의 개수를 의미(전체 인덱스 키 값이 100개인데, 그중 유니크한 값의 개수가 10개라면 기수성은 10)
    * 인덱스 키 값 가운데 중복된 값이 많아지면 많아질수록 기수성이 낮아지고 동시에 선택도 또한 떨어짐
    * 인덱스는 선택도가 높을수록 검색 대상이 줄어들기 때문에 그만큼 빠르게 처리

- 읽어야 하는 레코드의 건수
    * 인덱스를 통해 테이블의 레코드를 읽는 것은 인덱스를 거치지 않고 바로 테이블의 레코드를 읽는 것보다 높은 비용이 드는 작업
    * 일반적인 DBMS의 옵티마이저는 인덱스를 통해 레코드 1건을 읽는 것이 테이블에서 직접 레코드 1건을 읽는 것보다 4~5배 정도 비용이 더 드는 작업인것으로 예측. 즉, 인덱스를 통해 읽어야할 레코드의 건수가 전체 테이블 레코드의 20~25%정도를 넘는다면 인덱스를 이용하지 않고, 직접 테이블을 처음부터 끝까지 읽은 이후 필터링 하는 방식으로 하는것이 효율적

### B-Tree 인덱스를 통한 데이터 읽기
- 인덱스 레인지 스캔
    * 검색해야할 인덱스의 범위가 결정 되었을때 사용하는 방식. 검색하려는 값의 수나 검색 결과 레코드 건수와 관계 없이 레인지 스캔이라고 표현
    * 루트 노드에서부터 비교를 시작해 브랜치 노드를 거치고 리프 노드까지 찾아 들어가야만 필요한 레코드의 시작 지점을 찾을 수 있음. 시작해야할 위치를 찾으면 그때부터는 리프 노드의 레코드만 순서대로 읽으면 됨
    * 이렇게 차례대로 읽는 것을 스캔 이라고 하며, 스캔하다가 리프 노드의 끝까지 읽으면, 리프 노드간의 링크를 통해 다음 리프 노드를 찾아서 다시 스캔. 스캔을 멈춰야할 위치에 다다르면 지금까지 읽은 레코드를 사용자에게 반환하고 쿼리를 종료
    * B-Tree 인덱스에서 루트와 브랜치 노드를 이용해 스캔 시작 위치를 검색하고 그 지점부터 필요한 방향(오름차순 or 내림차순)으로 인덱스를 읽어 나가는데, 어떤 방향으로 스캔하든 관계없이 정렬된 상태로 레코드를 가져옴(인덱스 자체의 정렬 특성 때문에)
    * 인덱스의 리프 노드에서 검색 조건에 일치하는 건들은 데이터 파일에서 레코드를 읽어노는 과정이 필요한데, 레코드 한건 한건 단위로 랜덤 I/O가 한번씩 일어남
    * 쿼리가 필요로 하는 데이터에 따라 최종 레코드를 읽지 않는 경우도 있는데, 이를 커버링 인덱스라고 하며 커버링 인덱스로 처리되는 쿼리는 랜덤 I/O가 그만큼 줄어 성능이 빨라짐

- 인덱스 풀 스캔
    * 인덱스의 처음부터 끝까지 모두 읽는 방식. 쿼리의 조건절에 사용된 칼럼이 인덱스의 첫번째 칼럼이 아닌 경우 인덱스 풀 스캔이 사용(인덱스가 A,B,C 칼럼의 순서로 만들어 졌지만, 쿼리의 조건절은 B 칼럼이나 C 칼럼으로 검색하는 경우)
    * 일반적으로 인덱스의 크기는 테이블의 크기보단 작으므로 직접 테이블을 처음부터 끝까지 검색하는 것보다는 인덱스만 읽는것이 효율적
    * 쿼리가 인덱스에 명시된 컬럼만으로 조건을 처리할 수 있다면 이 방식이 사용 되지만, 인덱스 뿐만 아니라 데이터 레코드까지 모두 읽어야 한다면 절대 이 방식으로는 처리 되지 않음

- 루스 인덱스 스캔
    * 말 그대로 느슨하게 또는 듬성듬성하게 인덱스를 읽는 것을 의미. 인덱스 레인지 스캔과 비슷하게 동작 하지만 중간에 필요하지 않은 인덱스 키 값은 모두 무시하고 다음으로 넘어감
    * 일반적으로 GROUP BY 또는 집합 함수가운데 MAX / MIN 함수에 대해 최적화를 하는 경우에 사용

- 인덱스 스킵 스캔
    * 인덱스의 핵심은 값이 정렬 되어 있다는 것이며, 이로 인해 인덱스를 구성하는 컬럼의 순서가 매우 중요
    * 인덱스를 여러 칼럼으로 구성 한 후에, 인덱스를 구성한 칼럼중 일부만 WHERE 조건절에서 사용 하는 경우 인덱스 사용이 불가능
    * MySQL 옵티마이저가 WHERE 조건에서 사용하지 않은 칼럼에서 유니크한 값들을 모두 조회해서 주어진 쿼리에 조건을 추가해서 쿼리를 다시 실행하는 형태
    * WHERE 조건절에 조건이 없는 인덱스의 선행 칼럼의 유니크한 값의 개수가 적어야 하며, 쿼리가 인덱스에 존재하는 칼럼 만으로 처리가 가능해야(커버링 인덱스)하는 단점이 있음

### 다중 칼럼 인덱스
- 2개 이상의 칼럼으로 구성된 인덱스
- 인덱스의 2번째 칼럼은  첫번째 칼럼에 의존해서 정렬 되어 있음. 2번째 칼럼의 정렬은 첫번째 칼럼이 똑같은 레코드에서만 의미가 있음. 인덱스를 구성하는 칼럼이 많아도 이는 동일
- 다중 칼럼 인덱스에서 인덱스 내에서 각 칼럼의 위치(순서)가 상당히 중요하며, 이를 아주 신중히 정해야 하는 이유

### B-Tree 인덱스의 정렬 및 스캔 방향
- 정렬
    * 일반적인 상용 RDBMS에서는 인덱스를 생성하는 시점에 인덱스를 구성하는 각 칼럼의 정렬을 오름차순 또는 내림차순으로 설정 가능
    * MySQL 8.0 버전부터는 혼합 인덱스도 가능

- 스캔 방향
    * 인덱스가 오름차순으로만 정렬돼 있어도, 인덱스를 최솟값부터 읽으면 오름차순으로 가져올 수 있고, 최댓값 부터 거꾸로 읽으면 내림차순으로 값을 가져올 수 있다는것을 MySQL 옵티마이저는 알고 있음
    * 인덱스 생성 시점에 오름차순 또는 내림차순으로 정렬이 결정 돼지만, 쿼리가 그 인덱스를 사용하는 시점에 인덱스를 읽는 방향에 따라 오름차순 또는 내림차순 정렬 효과를 얻을 수 있음

- 내림차순 인덱스
    * 2개 이상의 칼럼으로 구성된 복합 인덱스에서 각각의 칼럼이 내림차순과 오름차순이 혼합된 경우에는 MySQL 8.0의 내림차순 인덱스로만 해결 될 수 있음
    * 페이지 잠금이 인덱스 Forward 스캔에 적합한 구조이고, 인덱스 레코드가 단방향으로만 연결된 구조라 인덱스 역순 스캔이 정순 스캔보다 느림

### B-Tree 인덱스의 가용성과 효율성
- 비교 조건의 종류와 효율성
    * 다중 컬럼 인덱스에서 각 칼럼의 순서와 그 칼럼에 사용된 조건이 동등비교인지 아니면 범위조건인지에 따라 각 인덱스 칼럼의 활용 형태가 달라지며, 효율도 달라짐
    * 다중 컬럼 인덱스에서 인덱스의 N번째 키 값은 N-1번째 키 값에 대해서 정렬되어 있는 구조 때문에 작업 범위를 좁히는게 중요
    * 작업의 범위를 결정하는 조건을 작업 범위 결정 조건이라 하며, 단순히 쿼리의 조건에 맞는지 검사하는 조건을 필터링 조건이라 할 수 있는데, 작업 범위 결정 조건이 많을수록 쿼리의 처리 성능은 높아지지만, 필터링 조건은 아님

- 인덱스 가용성
    * B-Tree 인덱스의 특징이 왼쪽 값에 기준해서 오른쪽 값이 정렬 되 있다는 건데, 여기서 왼쪽이란 하나의 칼럼 내에서 뿐만 아니라 다중 칼럼 인덱스의 칼럼에 대해서도 함께 적용됨
    * 다중 칼럼 인덱스에서 왼쪽 칼럼의 값을 모르면 인덱스 레인지 스캔을 할 수 없음

- 가용성과 효율성 판단
    * B-Tree 인덱스의 특성상 다음 조건들에서는 작업 범위 결정 조건으로는 사용 할 수 없으며, 경우에 따라 체크 조건으로는 사용할 수 있음
    * NOT-EQUAL로 비교 된 경우 ("<>", "NOT IN", "NOT BETWEEN", "IS NOT NULL")
    * LIKE '%??'(앞부분이 아닌 뒷부분 일치) 형태로 문자열 패턴이 비교 된 경우
    * 스토어드 함수나 다른 연산자로 인덱스 칼럼이 변형된 후 비교되는 경우
    * NOT-DETERMINISTIC 속성의 스토어드 함수가 비교 조건에 사용되는 경우
    * 데이터 타입이 서로 다른 비교(인덱스 칼럼의 타입을 변환해야 비교가 가능한 경우)
    * 문자열 데이터 타입의 콜레이션이 다른 경우
    * 다중 칼럼 인덱스에서 첫번째 칼럼에 대한 조건이 없는 경우
    * 다중 칼럼 인덱스에서 첫번째 칼럼의 비교 조건이 위의 인덱스 사용 불가 조건중 하나인 경우
    * column_1~column_(i-1)까지는 동등 비교 형태 이고, column_i에 대해서는 동등비교, 크다 작다 형태, LIKE로 좌측 일치 패턴 인 경우에는 작업 범위 결정조건으로 가능(i는 2보다 크고 n보다는 작은 임의의 값)

## R-Tree 인덱스 
- 2차원으 데이터를 인덱싱하고 검색하는 목적의 인덱스. 내부 매커니즘은 B-Tree와 흡사하지만, B-Tree는 인덱스를 구성하는 칼럼의 값이 1차원 스칼라 값인 반면, R-Tree인덱스는 2차원 공간 개념값

### 구조 및 특성
- 공간 정보 검색을 위한 R-Tree 알고리즘을 이해하려면 MBR(Minimum Bounding Rectangle, 해당 도형을 감싸는 최소 크기 사각형)을 알고 있어야 함
- MySQL의 공간 정보의 저장 및 검색을 위해 여러가지 기하학적 도형(Geometry)정보를 관리하기 위해 POINT, LINE, POLYGON, GEOMETRY의 데이터 타입을 제공 하는데, 이 데이터 타입들의 MBR에 대한 포함관계를 B-Tree 형태로 구현한 인덱스가 R-Tree 인덱스
- 여러 도형들의 정보가 저장되어 있고, 각 도형들의 MBR이 있을때, 각 MBR중 다른 하위 MBR들을 포함하는 최상위 레벨 MBR이 R-Tree의 루트에 저장되는 정보이며, 차 상위 레벨 MBR이 브랜치, 최 하위 레벨 MBR이 리프노드에 저장 된다

### R-Tree 인덱스의 용도
- 일반적으로 WGS84(GPS) 기준의 위도, 경도 좌표 저장에 주로 사용되며, CAD,CAM 소프트웨어 또는 회로 디자인등 좌표 시스템에 기반을 둔 정보에 대해서 모두 적용 가능
- R-Tree는 각 도형(도형의 MBR)의 포함 관계를 이용해 만들어졌으므로, ST_Contains(), ST_Within()등과 같은 포함 관계를 비교하는 함수로 검색을 수행하는 경우에만 인덱스를 이용 할 수 있다
    * 현재 출시되는 MySQL 에서는 ST_Distance(), ST_Distance_Sphere()함수는 공간 인덱스를 효율적으로 사용하지 못해서, ST_Contains(), ST_Within()을 써야함

## 전문 검색 인덱스
- 문서의 내용 전체를 인덱스화 해서 특정 키워드가 포함된 문서를 검색하는 전문(Full Text)검색에는 일반적인 용도의 B-Tree 인덱스를 사용 할 수 없다
- 문서 전체에 대한 분석과 검색을 위한 인덱싱 알고리즘을 전문 검색 인덱스(Full Text Search) 라고 하는데 일반화된 기능의 명칭이지 전문 검색 알고리즘의 이름을 지칭하는것은 아님

### 인덱스 알고리즘
- 전문 검색에서는 문서 본문의 내용에서 사용자가 검색하게될 키워드를 분석 해내고 빠른 검색용으로 검색 할 수 있게 키워드로 인덱스를 구축한다
- 키워드를 인덱싱 하는 기법에 따라 어근 분석과 n-gram분석 알고리즘으로 구분 할 수있다

### 어근 분석 알고리즘
- MySQL서버의 전문 검색 인덱스는 불용어 처리, 어근 분석의 과정을 거쳐 색인 작업이 수행됨
- 불용어 처리는 검색에서 별 가치가 없는 단어를 모두 필터링해서 제거하는 작업을 말하며, 불용어의 개수는 별로 많지 않기 때문에, 알고리즘을 구현한 코드에 모두 상수로 정의해서 쓰기도 하고, 불용어 자체를 데이터베이스화 해서 사용하기도 함
- 어근 분석은 검색어로 선정된 단어의 뿌리인 원형을 찾는 작업으로, MySQL 서버에서는 오픈소스 형태소 분석 라이브러리인 MeCab을 플러그인 형태로 지원. MeCab을 MySQL에 적용하는것은 어렵지 않지만 한글에 맞게 완성도를 갖추는 작업은 많은 시간과 노력이 필요함

### n-gram 알고리즘
- n-gram은 단순히 키워드를 검색해내기 위한 인덱싱 알고리즘
- 본문을 무조건 몇글자씩 잘라서 인덱싱 하는 방법. 형태소 분석 보다는 알고리즘이 단순하고 국가별 언어에 대한 이해와 준비가 필요 없는 대신, 만들어진 인덱스의 크기가 큰편
- n-gram에서 n은 인덱싱할 키워드의 최소 글자 수를 의미하는데 일반적으로는 2글자 단위로 키워드를 쪼개서 인덱싱 하는 2-gram(Bi-gram)방식이 많이 사용
- 문장을 띄어쓰기와 마침표를 기준으로 단어로 구분한 후, 이 단어들을 n글자씩 중첩해서 토큰으로 분리. 이렇게 구분된 각 토큰을 인덱스에 저장하고, 중복된 코튼은 하나의 인덱스 엔트리로 병합
- MySQL서버는 이렇게 생성된 토큰들에 대해서 불용어를 걸러내는 작업을 하는데, 불용어와 동일하거나 불용어를 포합하는 경우들을 걸러서 버림
- 불용어 처리는 사용자에게 도움이 되기보다는 사용자를 더 혼란스럽게 만들 수 도 있으므로 불용어 처리 자체를 완전히 무시하거나, MySQL 서버에 내장된 불용어 대신 사용자가 직접 불용어를 등록하는 방법을 권장

### 전문 검색 인덱스의 가용성
- 쿼리의 문장이 전문 검색을 위한 문법(MATCH, AGAINST)을 사용하거나, 테이블이 전문 검색 대상 칼럼에 대해서 전문 인덱스를 보유한 경우에만 전문 검색 인덱스를 사용 할 수 있음

## 함수 기반 인덱스
- 칼럼의 값을 변형해서 만들어진 값에 대해 인덱스를 구축 해야 한다면 함수 기반 인덱스를 활용해야함
- MySQL서버에서 함수 기반 인덱스를 구현하려면 가상 칼럼을 이용한 인덱스나 함수를 이용한 인덱스로 함수 기반 인덱스를 구현 가능
- 함수 기반 인덱스는 인덱싱할 값을 계산하는 과정의 차이만 있을뿐 실제 인덱스의 내부적인 구조 및 유지 관리 방법은 B-Tree인덱스와 동일

### 가상 칼럼을 이용한 인덱스
- 가상 칼럼을 생성(VIRTUAL, STORED)을 생성하고 그 칼럼에 인덱스를 생성하면 됨
- 어떤 옵션을 사용해서 생성됬던간에 관계 없이 해당 가상 칼럼에 인덱스 생성 가능
- 가상 칼럼은 테이블에 새로운 칼럼을 추가하는것과 같은 효과를 내기 때문에 실제 테이블의 구조가 변경된다는 단점

### 함수를 이용한 인덱스
- 함수를 직접 사용하는 인덱스는 테이블의 구조를 변경하지 않고 계산된 결괏값의 검색을 빠르게 만들어줌
- 함수 기반 인덱스를 제대로 활용 하려면 반드시 조건절에 함수 기반 인덱스에 명시된 표현이 그대로 사용 되야 함. 결과는 같더라도 표현식이 다르면 MySQL 옵티마이저가 다른 표현식으로 간주해서 함수 기반 인덱스를 사용하지 못함

## 멀티 밸류 인덱스
- 전문 검색 인덱스를 제외한 모든 인덱스는 레코드 1건이 1개의 인덱스 키 값을 가짐
- 멀티 벨류 인덱스는 하나의 데이터 레코드가 여러개의 키 값을 가질 수 있는 형태의 인덱스
- 일반적인 RDBMS기준에는 정규화 위배이지만, RDBMS가 JSON을 지원하기 시작하면서 JSON 배열타입의 필드에 저장된 원소들에 대한 인덱스 요건이 발생하면서 생긴것
- 멀티 벨류 인덱스를 활용하기 위해서는 일반적인 조건 방식을 사용하면 안되고, 반드시 MEMBER_OF, JSON_ONTAINS, JSON_OVERAPS등의 함수를 이용해서 검색해야 옵티마이저가 인덱스를 활용한 실행 계획을 수립

## 클러스터링 인덱스
- MySQL서버에서 클러스터링은 테이블의 레코드를 비슷한것들끼리 묶어서 저장하는 형태로 구현

### 클러스터링 인덱스
- 테이블의 프라이머리 키에 대해서만 적용되는 내용. 프라이머리 키 값이 비슷한 레코드들 끼리 묶어서 저장하는것이 클러스터링 인덱스
- 프라이머리 키 값에 의해 레코드의 저장 위치가 결정되며, 프라이머리 키 값이 변경된다면 레코드의 물리적인 저장 위치도 바뀌어야 하며, 프라이머리 키 값으로 클러스터링 된 테이블은 프라이머리 키 값 자체에 대한 의존이 높으므로 신중히 프라이머리 키를 결정 해야 함
- 사실 인덱스 알고리즘 이라기보단 테이블 레코드의 저장방식이라고도 볼 수 있어, 클러스터링 테이블과 클러스터링 인덱스는 동의어로 사용되기도 함

### 세컨더리 인덱스에 미치는 영향
- InnoDB 테이블의 모든 세컨더리 인덱스는 해당 레코드가 저장된 주소가 아닌 프라이머리 키 값을 저장하도록 구현

### 클러스터링 인덱스의 장점과 단점
- 장점: 프라이머리 키 로 검색할 때는 성능이 매우 빠름, 테이블의 모든 세컨더리 인덱스가 프라이머리 키를 가지고 있어 인덱스만으로 처리될 수 있는 경우가 많음
- 단점: 테이블의 모든 세컨더리 인덱스가 클러스터링 키를 갖기 때문에 클러스터링 키 값이 클수록 전체 인덱스의 크기가 커짐. 세턴더리 인덱스를 통해 검색 하면 프라이머리 키로 다시 검색해야 해서 느려짐. INSERT 할 때 프라이머리 키에 의해 저장 위치가 결정되므로 처리 성능이 느림, 프라이머리 키를 변경할때 DELETE하고 INSERT하는 작업을 하므로 느림

### 클러스터링 테이블 사용시 주의사항
- 클러스터링 인덱스 키의 크기: 프라이머리 키가 커질수록 인덱스의 크기가 기하급수적으로 커지므로 주의
- 프라이머리 키는 AUTO-INCREMENT보다는 업무적인 칼럼으로 생성: 프라이머리 키로 검색 할경우 성능이 매우 좋기 떄문에, 칼럼의 크기가 크더라도 업무적으로 해당 레코드를 대표 할 수 있다면 그 칼럼을 프라이머리 키로 설정
- 프라이머리 키는 반드시 명시할것
- AUTO-INCREMENT 칼럼을 인조 식별자로 사용할 경우: 여러개의 칼럼이 복합으로 프라이머리 키가 만들어져서 프라이머리 키가 길어진다면, AUTO-INCREMENT 칼럼을 추가하고 이것을 프라이머리 키로 사용

## 유니크 인덱스

### 유니크 인덱스와 일반 세컨더리 인덱스 비교
- 인덱스 읽기: 유니크하지 않은 세컨더리 인덱스에서 레코드를 더 읽어야 하는것은 디스크 읽기가 아니라 CPU작업 이므로 성능상 거의 영향 없음
- 인덱스 쓰기: 유니크 인덱스의 키 값을 쓸때는 중복된 값이 있는지 없는지 체크하는 과정이 한단계 더 필요 하므로, 유니크 하지 않은 세컨더리 인덱스보다 쓰기가 느림

### 유니크 인덱스 사용시 주의사항
- 성능이 더 좋아질것으로 생각하고 불필요하게 유니크 인덱스를 생성하는것은 좋지 않음
- 유니크 인덱스와 일반 인덱스를 중복해서 생성할 필요는 없음
- 똑같은 칼럼에 대해 프라이머리 키와 유니크 인덱스를 동일하게 생성하는 경우도 있는데 이 또한 불필요한 중복


## 외래키
- 외래키 제약이 설정되면 자동으로 연관되는 테이블의 칼럼에 인덱스까지 생성됨. 외래키가 제거되지 않은 상태에서는 자동으로 생성된 인덱스 삭제 불가
- 외래키 관리에서는 테이블의 변경(쓰기 잠금)이 발생하는 경우에만 잠금 경합(잠금 대기)이 발생한다는 것과, 외래키가 연관되지 않은 칼럼의 변경은 최대한 잠금 경합을 발생시키지 않아야 한다는 중요한 특징이 있음
- 데이터베이스에서 외래키를 물리적으러 생성하려면 이러한 잠금 경합까지 고려해서 모델링을 진행하는것이 좋음. 잠금이 다른 테이블로 확장되면 쿼리의 동시 처리에 영향을 미치기 때문