---
layout: post
title: "Real MySQL 08 : 인덱스"
description: Real MySQL 8장 - 인덱스
date: 2021-11-21 12:37:00 +09:00
categories: MySQL RealMySQL Study
---

# 인덱스

## 디스크 읽기 방식
- 데이터베이스의 성능 튜닝은 디스크 I/O를 어떻게 줄이느냐가 관건

### HDD와 SSD
- 디스크의 헤더를 움직이지 않고 한번에 많은 데이터를 읽는 순차 I/O에서는 SSD가 하드디스크보다 조금 더 빠르거나 거의 비슷한 성능
- SSD의 장점은 하드디스크보다 랜덤 I/O가 훨씬 빠르다는것
- 데이터베이스 서버에서 순차 I/O의 비중이 크지 않고 랜덤 I/O를 통해 작은 데이터를 읽고 쓰는 작업이 대부분이므로, SSD의 장점은 RDBMS용 스토리지에 최적이라고 할 수 있음

### 랜덤 I/O와 순차 I/O
- 3개의 데이터를 디스크에 기록 한다고 할 때, 순차 I/O는 3개의 페이지를 디스크에 기록하기 위해 1번 시스템 콜을 하지만, 랜덤 I/O는 3개의 페이지를 디스크에 기록하기 위해 3번 시스템 콜을 요청함. 디스크에 기록할 위치를 찾기 위해 순차 I/O는 디스크의 헤드를 1번 움직이고, 랜덤 I/O는 3번 움직임
- 디스크에 데이터를 읽고 쓰는데 걸리는 시간은 디스크 헤더를 움직여서 읽고 쓸 위치로 옮기는 단계에 의해서 결정. 즉, 디스크의 성능은 디스크 헤더의 위치 이동 없이 얼마나 많은 데이터를 한번에 기록하느냐에 의해 결정. 그래서 여러번 쓰기 또는 읽기를 요청하는 랜덤 I/O 작업이 작업 부하가 훨씬 더 큼
- 쿼리를 튜닝해서 랜덤 I/O를 순차 I/O로 바꿔서 실행할 방법은 그다지 많지 않음. 쿼리를 튜닝하는 것은 랜덤 I/O 자체를 줄여주는것이 목적. 쿼리를 처리하는데 꼭 필요한 데이터만 읽도록 쿼리를 개선하는것

## 인덱스란?
- DBMS도 데이터베이스 테이블의 모든 데이터를 검색해서 원하는 결과를 가져오려면 시간이 오래걸리기 떄문에 칼럼(또는 칼럼들)의 값과 해당 레코드가 저장된 주소를 키와 값의 쌍으로 삼아 인덱스를 만들어 둠
- DBMS의 인덱스는 칼럼의 값을 주어진 순서로 미리 정렬해서 보관
- DBMS의 인덱스는 SortedList와 마찬가지로 저장되는 칼럼의 값을 이용해서 항상 정렬된 상태를 유지(데이터 파일은 ArrayList와 같이 저장된 순서대로 별도의 정렬 없이 그대로 저장)
- DBMS의 인덱스가 많은 테이블은 당연히 INSERT, UPDATE, DELETE 문장의 처리가 느려지지만, SELECT 문장은 아주 빠르게 처리 가능
- 결론적의로 DBMS에서 인덱스는 데이터의 저장(INSERT, UPDATE, DELETE)의 성능을 희생하고 그 대신 데이터의 읽기 속도를 높이는 기능. 테이블의 인덱스를 하나 더 추가할지 말지는 데이터의 저장 속도를 어디까지 희생할 수 있는지, 읽기 속도를 얼마나 더 빠르게 만들어야 하는지에 따라 결정
- SELECT 쿼리 문장의 WHERE 조건절에 사용되는 칼럼이라고 해서 전부 인덱스로 생성하면 데이터 저장 성능이 떨어지고, 인덱스의 크기가 비대해져 오히려 역효과만 불러올 수 있음
- 인덱스를 역할별로 구분하면 프라이머리 키와 세컨더리 키로 구분할 수 있음
    * 프라이머리 키: 레코드를 대표하는 칼럼의 값으로 만들어진 인덱스, 테이블에서 해당 레코드를 식별하는 기준값이기 때문에 식별자 라고도 부르며, NULL을 허용하지 않고 중복을 허용하지 않음
    * 세컨더리 키: 프라이머리 키를 제외한 모든 나머지 인덱스. 유니크 인덱스는 프라이머리 키와 성격이 비슷하고 프라이머리 키를 대체해서 사용 할 수도 있다고 해서 대체키라고 하기도 함

- 인덱스를 데이터 저장 방식(알고리즘)별로 구분하면 대표적으로 B-Tree 인덱스와 Hash 인덱스로 구분 가능
    * B-Tree 알고리즘: 칼럼의 값을 변형하지 않고 원래의 값을 이용해 인덱싱. MySQL에서는 위치 기반 검색을 지원하기 위한 R-Tree 알고리즘도 있지만 R-Tree 알고리즘도 결국 B-Tree의 응용 알고리즘
    * Hash 알고리즘: 칼럼의 값으로 해시값을 계산해서 인덱싱 하는 알고리즘. 매우 빠른 검색 지원. 값을 변형해서 인덱싱 하므로 전방 일치와 같이 값의 일부만 검색하거나 범위를 검색 할때는 해시 인덱스를 사용 할 수 없음. 메모리 기반의 데이터베이스에서 많이 사용

- 데이터의 중복 허용 여부로 분류하면 유니크 인덱스와 유니크 하지 않은 인덱스로 구분
- 인덱스의 기능별로 분류 해보면 전문 검색용 인덱스나 공간 검색용 인덱스등이 있음

## B-Tree
- 데이터 베이스의 인덱싱 알고리즘 가운데 가장 일반적이고, 가장 먼저 도입되었으며, 가장 범용적으로 사용
- B-Tree는 칼럼의 원래 값을 변형시키지 않고 인덱스 구조체 내에서는 항상 정렬된 상태로 유지

### 구조 밎 특성
- B-Tree는 최상위에 하나의 루트 노드가 존재하고 그 하위에 자식 노드가 붙어있는 형태. 트리 구조의 가장 하위 노드를 리프 노드 라고 하며, 루트 노드도 아니고 리프 노드도 아닌 중간의 노드를 브랜치 노드라고 함
- 데이터베이스에서 인덱스와 실제 데이터가 저장된 데이터는 따로 관리 되는데, 인덱스의 리프노드는 항상 실제 데이터 레코드를 쫒아가기 위한 주솟값을 가지고 있음
- 인덱스의 키 값은 모두 정렬 되어있지만, 데이터 파일의 레코드는 정렬 되있지 않고 임의의 순서대로 저장 돼 있음
- 인덱스는 테이블의 키 칼럼만 가지고 있으므로 나머지 칼럼을 읽으러면 데이터 파일에서 해당 레코드를 찾아야 함
- InnoDB 테이블에서 인덱스를 통해 레코드를 읽을 때에는 데이터를 바로 찾아가지 못하고, 인덱스에 저장되어있는 프라이머리 키 값을 이용해 프라이머리 키 인덱스를 한번 더 검색후 프라이머리 키 인덱스의 리프 페이지에 저장 돼있는 레코드를 읽음. 즉, 모든 세컨더리 인덱스 검색에서 데이터 레코드를 읽기 위해 반드시 프라이머리 키를 저장하고 있는 B-Tree를 다시 한번 검색 해야함

### B-Tree 인덱스 추가 및 삭제
- 추가
    * 새로운 키 값이 B-Tree에 저장 될 때에는 테이블의 스토리지 엔진에 따라 새로운 키 값이 즉시 저장 될 수도, 그렇지 않을 수도 있음. MyISAM이나 MEMORY스토리지 엔진은 즉시, InnoDB 스토리지 엔진은 필요시 인덱스 키 추가작업을 지연
    * B-Tree에 저장될 때는 저장될 키 값을 이용해 B-Tree상의 적절한 위치를 검색 해야함. 저장될 위치가 결정되면 레코드의 키 값과 대상 레코드의 주소 정보를 B-Tree의 리프 노드에 저장
    * 리프 노드가 꽉차서 더는 저장 할 수 없을때는 리프 노드가 분리 되야 하는데, 이때 상위 브랜치 노드까지 처리의 범위가 넓어져 B-Tree는 상대적으로 쓰기 작업에 비용이 많이듬

- 삭제
    * 해당 키 값이 저장된 B-Tree의 리프 노드를 찾아 그냥 삭제 마크만 하면 작업이 완료
    * 삭제 마킹된 인덱스 키 공간은 계속 그대로 방치하거나 재활용 가능
    * 인덱스 키 삭제로 인한 마킹 작업 또한 디스크 쓰기가 필요 하므로 디스크 I/O가 필요한 작업. 따라서 버퍼링 되어 지연 처리 가능

- 변경
    * 인덱스의 키 값은 그 값에 따라 저장될 리프 노드의 위치가 결정 되므로 B-Tree의 키 값이 변경되는 경우에는 단순히 인덱스 상의 키 값만 변경하는것은 불가능
    * B-Tree의 키 값 변경 작업은 먼저 키 값을 삭제한 후, 다시 새로운 키 값을 추가하는 형태로 처리

- 검색
    * 인덱스를 검색하는 작업은 B-Tree의 루트 노드부터 시작해서 브랜치 노드를 거쳐 최종 리프 노드까지 이동하면서 비교 작업을 수행 하는데, 이를 트리 탐색이라고 함
    * 인덱스 트리 탐색은 SELECT에서만 사용 하는것이 아니라, UPDATE나 DELETE를 처리하기 위해 항상 해당 레코드를 먼저 검색 해야 할 경우에도 사용
    * B-Tree 인덱스를 이용한 검색은 100% 일치 또는 값의 앞 부분만 일치하는 경우에 사용 가능
    * 부등호(<,>) 비교 조건에서도 인덱스를 활용할 수 있지만, 인덱스를 구성하는 키 값의 뒷부분만 검색하는 용도로는 사용 할 수 없음
    * 인덱스의 키 값에 변형이 가해진 후 비교 되는 경우에는 사용할 수 없는데, 변형된 값은 B-Tree에 존재하는 값이 아니기 때문
    * InnoDB 스토리지 엔진에서는 레코드 잠금이나 넥스트 키락이 검색을 수행한 인덱스를 잠근 후 테이블의 레코드를 잠그는 방식으므로, UPDATE나 DELETE가 실행될 때 테이블에 적절한 인덱스가 없다면 불필요하게 많은 레코드가 잠김

### B-Tree 인덱스 사용에 영향을 미치는 요소
- 키 값의 크기
    * InnoDB 스토리지 엔진에서 디스크에 데이터를 저장하는 가장 기본 단위를 페이지 또는 블록이라고 하며, 디스크의 모든 읽기 및 쓰기 작업의 최소 작업 단위. 버퍼링의 기본 단위이기도 함. 인덱스도 결국 페이지 단위로 관리. 루트와 브랜치 그리고 리프 노드를 구분한 기준이 페이지 단위
    * B-Tree는 자식의 개수가 가변적인 구조 이므로, 기본 페이지 크기값인 16kb기준으로 인덱스의 키가 16바이트라고 가정 하면 하나의 인덱스 페이지에 585개의 자식 노드를 가질 수 있음. 인덱스 키 값이 커지면, 그에 따라 가질 수 있는 자식 노드의 수가 줄어들음
    * 인덱스의 키 값의 길이가 길어진다는 것은 전체적인 인덱스의 크기가 커진다는 것으로, 인덱스를 캐시 해두는 InnoDB의 버퍼 풀은 크기가 제한적이기 때문에, 하나의 레코드를 위한 인덱스 크키가 커지면 커질수록 메모리에 캐시해 둘 수 있는 레코드 수는 줄어들어 메모리의 효율이 떨어짐

- B-Tree 깊이
    * B-Tree 인덱스의 깊이는 상당히 중요 하지만, 직접 제어할 방법은 없음
    * 인덱스 키 값이 늘어나면 늘어날수록 하나의 인덱스 페이지가 담을 수 있는 인덱스 키 값의 개수가 적어지고, 그때문에 같은 레코드 건수라고 하더라도 B-Tree의 깊이가 깊어져 더 많은 디스크 읽기가 필요해짐
    * 일반적으로 5단계 이상 깊어지지 않음

- 선택도(기수성)
    * 선택도 또는 기수성은 거의 같은 의미로 사용 되며, 모든 인덱스 키 값 가운데 유니크한 값의 개수를 의미(전체 인덱스 키 값이 100개인데, 그중 유니크한 값의 개수가 10개라면 기수성은 10)
    * 인덱스 키 값 가운데 중복된 값이 많아지면 많아질수록 기수성이 낮아지고 동시에 선택도 또한 떨어짐
    * 인덱스는 선택도가 높을수록 검색 대상이 줄어들기 때문에 그만큼 빠르게 처리

- 읽어야 하는 레코드의 건수
    * 인덱스를 통해 테이블의 레코드를 읽는 것은 인덱스를 거치지 않고 바로 테이블의 레코드를 읽는 것보다 높은 비용이 드는 작업
    * 일반적인 DBMS의 옵티마이저는 인덱스를 통해 레코드 1건을 읽는 것이 테이블에서 직접 레코드 1건을 읽는 것보다 4~5배 정도 비용이 더 드는 작업인것으로 예측. 즉, 인덱스를 통해 읽어야할 레코드의 건수가 전체 테이블 레코드의 20~25%정도를 넘는다면 인덱스를 이용하지 않고, 직접 테이블을 처음부터 끝까지 읽은 이후 필터링 하는 방식으로 하는것이 효율적

### B-Tree 인덱스를 통한 데이터 읽기
- 인덱스 레인지 스캔
    * 검색해야할 인덱스의 범위가 결정 되었을때 사용하는 방식. 검색하려는 값의 수나 검색 결과 레코드 건수와 관계 없이 레인지 스캔이라고 표현
    * 루트 노드에서부터 비교를 시작해 브랜치 노드를 거치고 리프 노드까지 찾아 들어가야만 필요한 레코드의 시작 지점을 찾을 수 있음. 시작해야할 위치를 찾으면 그때부터는 리프 노드의 레코드만 순서대로 읽으면 됨
    * 이렇게 차례대로 읽는 것을 스캔 이라고 하며, 스캔하다가 리프 노드의 끝까지 읽으면, 리프 노드간의 링크를 통해 다음 리프 노드를 찾아서 다시 스캔. 스캔을 멈춰야할 위치에 다다르면 지금까지 읽은 레코드를 사용자에게 반환하고 쿼리를 종료
    * B-Tree 인덱스에서 루트와 브랜치 노드를 이용해 스캔 시작 위치를 검색하고 그 지점부터 필요한 방향(오름차순 or 내림차순)으로 인덱스를 읽어 나가는데, 어떤 방향으로 스캔하든 관계없이 정렬된 상태로 레코드를 가져옴(인덱스 자체의 정렬 특성 때문에)
    * 인덱스의 리프 노드에서 검색 조건에 일치하는 건들은 데이터 파일에서 레코드를 읽어노는 과정이 필요한데, 레코드 한건 한건 단위로 랜덤 I/O가 한번씩 일어남
    * 쿼리가 필요로 하는 데이터에 따라 최종 레코드를 읽지 않는 경우도 있는데, 이를 커버링 인덱스라고 하며 커버링 인덱스로 처리되는 쿼리는 랜덤 I/O가 그만큼 줄어 성능이 빨라짐

- 인덱스 풀 스캔
    * 인덱스의 처음부터 끝까지 모두 읽는 방식. 쿼리의 조건절에 사용된 칼럼이 인덱스의 첫번째 칼럼이 아닌 경우 인덱스 풀 스캔이 사용(인덱스가 A,B,C 칼럼의 순서로 만들어 졌지만, 쿼리의 조건절은 B 칼럼이나 C 칼럼으로 검색하는 경우)
    * 일반적으로 인덱스의 크기는 테이블의 크기보단 작으므로 직접 테이블을 처음부터 끝까지 검색하는 것보다는 인덱스만 읽는것이 효율적
    * 쿼리가 인덱스에 명시된 컬럼만으로 조건을 처리할 수 있다면 이 방식이 사용 되지만, 인덱스 뿐만 아니라 데이터 레코드까지 모두 읽어야 한다면 절대 이 방식으로는 처리 되지 않음

- 루스 인덱스 스캔
    * 말 그대로 느슨하게 또는 듬성듬성하게 인덱스를 읽는 것을 의미. 인덱스 레인지 스캔과 비슷하게 동작 하지만 중간에 필요하지 않은 인덱스 키 값은 모두 무시하고 다음으로 넘어감
    * 일반적으로 GROUP BY 또는 집합 함수가운데 MAX / MIN 함수에 대해 최적화를 하는 경우에 사용

- 인덱스 스킵 스캔
    * 인덱스의 핵심은 값이 정렬 되어 있다는 것이며, 이로 인해 인덱스를 구성하는 컬럼의 순서가 매우 중요
    * 인덱스를 여러 칼럼으로 구성 한 후에, 인덱스를 구성한 칼럼중 일부만 WHERE 조건절에서 사용 하는 경우 인덱스 사용이 불가능
    * MySQL 옵티마이저가 WHERE 조건에서 사용하지 않은 칼럼에서 유니크한 값들을 모두 조회해서 주어진 쿼리에 조건을 추가해서 쿼리를 다시 실행하는 형태
    * WHERE 조건절에 조건이 없는 인덱스의 선행 칼럼의 유니크한 값의 개수가 적어야 하며, 쿼리가 인덱스에 존재하는 칼럼 만으로 처리가 가능해야(커버링 인덱스)하는 단점이 있음

### 다중 칼럼 인덱스
- 2개 이상의 칼럼으로 구성된 인덱스
- 인덱스의 2번째 칼럼은  첫번째 칼럼에 의존해서 정렬 되어 있음. 2번째 칼럼의 정렬은 첫번째 칼럼이 똑같은 레코드에서만 의미가 있음. 인덱스를 구성하는 칼럼이 많아도 이는 동일
- 다중 칼럼 인덱스에서 인덱스 내에서 각 칼럼의 위치(순서)가 상당히 중요하며, 이를 아주 신중히 정해야 하는 이유

### B-Tree 인덱스의 정렬 및 스캔 방향
- 정렬
    * 일반적인 상용 RDBMS에서는 인덱스를 생성하는 시점에 인덱스를 구성하는 각 칼럼의 정렬을 오름차순 또는 내림차순으로 설정 가능
    * MySQL 8.0 버전부터는 혼합 인덱스도 가능

- 스캔 방향
    * 인덱스가 오름차순으로만 정렬돼 있어도, 인덱스를 최솟값부터 읽으면 오름차순으로 가져올 수 있고, 최댓값 부터 거꾸로 읽으면 내림차순으로 값을 가져올 수 있다는것을 MySQL 옵티마이저는 알고 있음
    * 인덱스 생성 시점에 오름차순 또는 내림차순으로 정렬이 결정 돼지만, 쿼리가 그 인덱스를 사용하는 시점에 인덱스를 읽는 방향에 따라 오름차순 또는 내림차순 정렬 효과를 얻을 수 있음

- 내림차순 인덱스
    * 2개 이상의 칼럼으로 구성된 복합 인덱스에서 각각의 칼럼이 내림차순과 오름차순이 혼합된 경우에는 MySQL 8.0의 내림차순 인덱스로만 해결 될 수 있음
    * 페이지 잠금이 인덱스 Forward 스캔에 적합한 구조이고, 인덱스 레코드가 단방향으로만 연결된 구조라 인덱스 역순 스캔이 정순 스캔보다 느림

### B-Tree 인덱스의 가용성과 효율성
- 비교 조건의 종류와 효율성
    * 다중 컬럼 인덱스에서 각 칼럼의 순서와 그 칼럼에 사용된 조건이 동등비교인지 아니면 범위조건인지에 따라 각 인덱스 칼럼의 활용 형태가 달라지며, 효율도 달라짐
    * 다중 컬럼 인덱스에서 인덱스의 N번째 키 값은 N-1번째 키 값에 대해서 정렬되어 있는 구조 때문에 작업 범위를 좁히는게 중요
    * 작업의 범위를 결정하는 조건을 작업 범위 결정 조건이라 하며, 단순히 쿼리의 조건에 맞는지 검사하는 조건을 필터링 조건이라 할 수 있는데, 작업 범위 결정 조건이 많을수록 쿼리의 처리 성능은 높아지지만, 필터링 조건은 아님

- 인덱스 가용성
    * B-Tree 인덱스의 특징이 왼쪽 값에 기준해서 오른쪽 값이 정렬 되 있다는 건데, 여기서 왼쪽이란 하나의 칼럼 내에서 뿐만 아니라 다중 칼럼 인덱스의 칼럼에 대해서도 함께 적용됨
    * 다중 칼럼 인덱스에서 왼쪽 칼럼의 값을 모르면 인덱스 레인지 스캔을 할 수 없음

- 가용성과 효율성 판단
    * B-Tree 인덱스의 특성상 다음 조건들에서는 작업 범위 결정 조건으로는 사용 할 수 없으며, 경우에 따라 체크 조건으로는 사용할 수 있음
    * NOT-EQUAL로 비교 된 경우 ("<>", "NOT IN", "NOT BETWEEN", "IS NOT NULL")
    * LIKE '%??'(앞부분이 아닌 뒷부분 일치) 형태로 문자열 패턴이 비교 된 경우
    * 스토어드 함수나 다른 연산자로 인덱스 칼럼이 변형된 후 비교되는 경우
    * NOT-DETERMINISTIC 속성의 스토어드 함수가 비교 조건에 사용되는 경우
    * 데이터 타입이 서로 다른 비교(인덱스 칼럼의 타입을 변환해야 비교가 가능한 경우)
    * 문자열 데이터 타입의 콜레이션이 다른 경우
    * 다중 칼럼 인덱스에서 첫번째 칼럼에 대한 조건이 없는 경우
    * 다중 칼럼 인덱스에서 첫번째 칼럼의 비교 조건이 위의 인덱스 사용 불가 조건중 하나인 경우
    * column_1~column_(i-1)까지는 동등 비교 형태 이고, column_i에 대해서는 동등비교, 크다 작다 형태, LIKE로 좌측 일치 패턴 인 경우에는 작업 범위 결정조건으로 가능(i는 2보다 크고 n보다는 작은 임의의 값)