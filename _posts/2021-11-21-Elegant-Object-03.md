---
layout: post
title: "Elegant Object - 3장: 취업"
description: Elegant Object 3장
date: 2021-11-21 17:07:00 +09:00
categories: ElegantObject Study
---


# 취업

## 5개 이하의 public 메서드만 노출 하라
- 가장 우아하고, 유지보수가 가능하고, 응집력이 높으면서, 테스트가 용이한 객체는 작은 객체
- 클래스의 크기를 정하는 기준은 public 메서드(protected 포함)의 개수를 사용하기를 권장
- public 메서드가 많을수록 클래스도 커짐. 클래스가 커질수록 유지보수성도 저하되며, 적절한 public 메서드의 수는 5개
- 딱히 5개로 정한 특별한 이유가 있는것은 아니지만, public 메서드 수에 제한이 있고 그 제한이 매우 작다는 사실에 설명하기 위함
- 클래스가 더 작을수록 실수할 가능성이 줄어들기 때문에 작은 클래스는 더 우아함
- 10개의 메서드보다는 3개의 메서드들이 조화를 이루도록 만들기가 더 쉬움
- 작은 클래스는 유지보수하기도 쉬움. 코드양이 더 적고, 메소드 수가 더 적고, 에러를 찾기 더 쉽고, 수정하기도 더 쉽기 때문
- 작은 클래스는 응집도도 높고 테스트 하기도 쉽다

## 정적 메서드를 사용하지 마라
- 정적 메서드 대신에 객체를 사용 해야함
- 정적 메서드와 객체를 사용하는 방식에 큰 차이가 없다고 생각 할 수도 있고, 정적 메서드는 요청시마다 새 객체를 만들 필요도 없어 더 빠름
- 정적 메서드는 객체 생성과 가비지 컬렉션에 신경 쓸 필요도 없으며, 유틸리티 클래스에 정적 메서드를 모아 놓을 수도 있음
- 하지만 이렇게 정적 메서드를 사용하는 방법은 완전히 잘못된것
- 문맥과 상관 없이 정적 메서드를 사용하고 있는지 여부는 OOP를 제대로 이해하지 못한 형편없는 프로그래머를 구별하기 위해 사용할 수 있는 최적의 지표
- 정적 메서드는 소프트웨어를 유지보수 하기 어렵게 만듬

### 객체 대 컴퓨터 사고
- 어셈블리어, C, COBOL 등의 초창기 프로그래밍 언어로 부터 컴퓨터 처럼 생각하는 방법을 물려 받았는데, 이런 언어들의 중점적 패러다임은 컴퓨터가 우리를 위해 일하고 우리는 명시적인 명령어를 제공해 컴퓨터에게 지시를 내린다는것
- 이러한 방식의 장점은 프로그래머가 CPU와 유사한 방식으로 수행될 작업을 CPU에게 직접 지시할 수 있다는 것. 우리가 결정하고 컴퓨터는 따르며 흐름은 항상 순차적이며 스크립트의 위에서 아래로 흐름. 이러한 순차적 사고방식이 컴퓨터 입장에서 생각하기임
- 작은 소프트웨어에서는 이런 접근방법을 적용해도 아무런 문제가 없겠지만, 규모가 더 커지면 순차적인 사고 방식은 한계에 직면함
- 우리는 컴퓨터에게 할일을 지시하는것이 아니라 정의 하는데, 함수형, 논리형, 객체지향 프로그래밍이 절차적 프로그래밍과 차별화 되는점이 바로 이것
- 객체지향적으로 생각 하면 우리는 그저 누가 누구인지만 정의하고, 객체들이 필요로 할 때 스스로 상호작용 하도록 제어를 위임함

```java
class Mam implements Number {
    private final Number a;
    private final Number b;
    public Max(Number left, Number right) {
        this.a = left;
        this.b = right;
    }
}

Max x = new Max(5,9);
```

- 위 코드는 최댓값을 계산하지 않고, 그저 x가 5와 9의 최댓값이라는 사실을 정의할 뿐, Max 클래스의 객체 안에 포함된것이 무엇이고, 이 클래스가 Number 인터페이스를 정확히 어떻게 구현하고 있는지에 대해서는 관심이 없음
- 반대로 OOP의 정적 메서드는 정확하게 C와 어셈블리어의 서브 루틴과 동일. 객체지향 언어의 문법을 이용해 절차적인 코드를 작성하도록 부추길 뿐임

### 선언형 스타일대 명령형 스타일
- 명령형 프로그래밍에서는 프로그램의 상태를 변경하는 문장을 사용해서 계산 방식을 서술
- 선언형 프로그래밍에서는 제어 흐름을 서술하지 않고 계산 로직만 표현
- 명령형 프로그래밍은 컴퓨터처럼 연산을 차례대로 수행, 선언형 프로그래밍은 엔티티와 엔티티 사이의 관계로 구성되는 자연스러운 사고 패러다임에 가까움
- 이 둘의 차이점은 다른 클래스, 객체, 메서드가 이 기능을 사용하는 방법에 있음

```java
public static int between(int l, int r, int x) {
    return Math.min(Math.max(l,x),r);
}

int y = Math.between(5,9,13);

class Between implements Number {
    private final Number num;
    Between(Number left, Number right, Number x) {
        this.num = new Min(new Max(left,x),right);
    }

    @Override
    public int intValue() {
        return this.num.intValue();
    }
}

Number y = new Between(5,9,13);
```

- 정적 메서드로 구현 한다면 기존의 정적 메서드인 Math.min()과 Math.max()를 사용하는 또다른 정적 메서드인 between()을 구현 해야 함. 이것이 유일한 방법. 그리고 계산은 필요한 그 시점에 즉시 수행되기 때문에 between()은 명령형 스타일의 연산자임
- 객체를 사용하는 방식은 CPU에게 숫자를 계산하라고 말하지 않았기 때문에 이는 선언형 스타일임. Between이 무엇인지 정의만 하고 변수 y의 사용자가 intValue()의 값을 계산하는 시점을 결정
- 선언형 방식은 더 빠름. 선언형 방식에서는 우리가 직접 성능 최적화를 제어할 수 있기때문. 오직 하나의 정적 메서드만 호출하는 경우라면 정적 메서드를 호출하는 방식이 더 빠르겟지만, 다수의 정적 메서드를 호출해야하는 경우에는 이야기가 달라짐
- 선언형으로 구현하면 CPU에게 모든것을 계산하라고 말하지 않으며, CPU에게 결과가 실제로 필요한 시점과 위치를 결정하도록 위임하고, CPU는 실제 요청이 있을 경우에만 계산을 실행함
- 선언형이 더 좋은 또 한가지 이유는 다형성 때문. 다형성으로 인해 코드 블록 사이의 의존성을 끊어낼 수 있음. 객체지향 프로그래밍에서 객체는 일급 시민이지만 정적 메서드는 그렇지 않음. 생성자의 인자로 객체는 전달할 수 있지만, 정적 메서드를 전달하는것은 불가
- 객체를 다른 객체로부터 분리하기 위해서는 메서드나 주 생성자 어디에서도 new 연산자를 사용하면 안됨
- 선언형 방식이 또 좋은 이유 3번쨰는 표현력 때문. 선언형 방식은 결과를 이야기 하는데 반해, 명령형 방식은 수행 가능한 한가지 방법을 이야기함. 명령형 방식에서는 결과를 예상하기 위해 먼저 머릿속에서 코드를 실행해야 하기 때문에 덜 직관적임
- 명령형 방식의 코드가 더 짧아서 읽기 편하게 느껴질 수도 있는데, 알고리즘과 실행 되신 객체와 행동 관점에서 사고하기 시작하면 무엇이 올바른지 느껴지게 될 것
- 응집도 측면에서도 선언형 방식이 더 좋은데, 그 행동을 책임지는 모든 코드들이 한곳에 뭉쳐있기 때문에, 실수로라도 분리 할 수 없음. 하지만 명령형 코드에서는 코드의 각 줄을 이어주는 접착제가 없어 코드의 순서를 쉽게 변경할 수 있어, 그로인해 알고리즘에 오류가 발생할 수 있음
- 우리가 사용하는 대부분의 코드는 유틸리티 클래스와 정적메서드로 만들어진 수많은 오픈소스 라이브러리를 사용하고 있음. 이런 부분을 도려내야함

### 유틸리티 클래스
- 유틸리티 클래스란 시렞로는 클래스가 아니라 편의를 위해 다른 메서드들이 사용하는 정적 메서드들을 모아놓은 정적 메서드들의 컬렉션
- 유틸리티 클래스는 클래스의 인스턴스가 생성되는걸 막기 위해 private 생성자를 추가하는것이 좋은데, 이로인해 클래스에 선언된 메서드를 제외하면 어느 누구도 클래스의 인스턴스를 생성할 수 없음
- 유틸리티 클래슨느 절차적인 프로그래머들이 OOP라는 영토에서 거둔 승리의 상징. 유틸리티 클래슨느 나쁜 요소를 놓아놓은 집합체이자 안티패턴 이므로 가까이 하면 안됨

### 싱글톤 패턴
- 싱글톤은 유명한 디자인 패턴이지만 사실은 끔찍한 안티 패턴
- 그럼에도 싱글톤이 많이 사용되는 이유로 "상태를 유지함"이라는 특성을 말하곤 하는데, 이것은 유틸리티 클래스에서도 가능한것. 싱글톤을 구분하는 핵심적인 차이는 싱글톤은 분리가 가능한 의존성으로 연결 되어있는데, 유틸리티 클래스는 분리가 불가능한 하드코딩된 결합도를 가진다는것임
- 싱글톤 패턴을 사용하면 내부에 캡슐화된 정적 객체를 교체해서 전체 개념을 테스트 할 수 있음. 캡슐화된 객체를 변경할 수 있어 유틸리티 클래스보다는 더 좋음
- 하지만 논리적인 관점과 기술적인 관점에서 모두 싱글톤은 전역변수 그 이상 이하도 아니기 때문에, 안티패턴이자 형편없는 개념일 뿐임
- 싱글톤 대신에 캡슐화를 이용해야함. 싱글톤 객체가 필요한 모든 객체 안에서 그 싱글톤 객체를 캡슐화 하면 됨. 클래스가 필요한 작업을 수행하는데 모든 필요한 모든 요소들이 생성자에 의해 제공되고, 내부에 캡슐화 되어야함

### 함수형 프로그래밍
- 객체의 크기가 작고, 상태가 변하지 않으며, 정적 메서드도 포함하지 않는다면 함수형 프로그래밍이 낫지 않느냐는 의문이 있는데, 객체가 우아하게 만들어졌다면 함수와 객체 사이에 많은 부분이 유사해지기 마련. 그럼에도 객체를 사용하는 이유는 OOP의 표현력 때문
- FP에서는 오직 함수만 사용할 수 있지만, OOP에서는 객체와 메서드를 조합 할 수 있음. FP도 좋은 패러다임 이지만 OOP가 더 낫다. 특히 제대로 사용할 경우에는 더 확실해진다
- 이상적인 OOP 언어에서는 클래스와함께 함수가 포함되어야 하머, 이 함수는 하나의 출구만 포함하는 FP 패러다임에 기반하는 진정한 함수여야함

### 조합 가능한 데코레이터
- 데코레이터도 유명한 디자인 패턴이지만, 데코레이터 객체들을 다중 구조로 구성하기 시작하면 다음 예제처럼 조합 가능해짐

```java
names = new Sotred(
    new Unique(
        new Capitialize(
            new Replaced(
                new FileNames(
                    new Directory(
                        "/var/users/*.mxl"
                    )
                ),
                "([^.]+)\\.xml",
                "$1"
            )
        )
    )
);
```

- 이 코드는 매우 깔끔하면서도 객체지향적임. 순수하게 선언형이기 때문. 어떠한 일도 실제로 수행하지는 않지만 디렉토리 안의 모든 파일 이름을 정규식을 이용해서 치환하고 대문자로 변경하고 중복된 이름을 제거해 유일하게 만들고 다시 정렬을 해서 컬렉션에 담은 객체를 선언함
- 이 코드가 깔끔하고 이해하기 쉽다는 사실이 이해되지 않을 수 있음
- 이런 객체들이 조합 가능한 데코레이터 인데, Directory, FileNames, Replaced, Capitialized, Unique, Sorted 클래스들은 각각 하나의 데코레이터. 객체들의 전체적인 행동은 내부에 캡슐화 하고 있는 객체들이 의해 유도됨. 각 데코레이터는 내부에 캡슐화 하고 있는 객체에 별도의 행동을 추가함. 데코레이터의 상태는 내부에 캡슐화 하고있는 객체들의 상태와 동일함
- 올바르게 설계된 객체지향 소프트웨어라면 코드 대부분이 위의 예제와 유사해야함. 프로그래머는 데코레이터를 조합하는일을 제외한 다른 일은 하지 말아야함
- 데코레이터를 조합한 후 어떤 시점에서 app.run()을 호출하면 데코레이터로 된 전체 피라미드가 반응하기 시작할것. if, for, switch, while과 같은 절차적인 문장이 포함되있어선느 안됨
- 이 이야기의 요점은 순수한 OOP언어에서는 C같은 절차적인 언어로부터 물려받은 연산자가 필요하지 않다는 점. 클래스로 구현된 연산자들이 있으면 됨. 객체지향 프로그래밍이란 더 작은 객체들을 기반으로 더 큰 객체들을 조합하는 작업임
- 정적인 메서드는 조합이 불가능함. 따라서 앞서 설명한 모든 일들이 불가능함. 이래서 소프트웨어 어디에서도 static 키워드를 사용해서는 안도미

## 인자의 값으로 NULL을 절대 허용하지 마라
- 코드 어딘가에 Null이 존재 한다면 커다란 실수를 저지르고 있는것. Null이 어디에 있던 이 사실엔 변함이 없음

```java
public Iterable<File> find(String mask) {
    //디렉토리를 탐색해서 "*.txt"와 같은 형식의 마스크에 일치하는 모든 파일을 찾음
    //마스크가 NULL인 경우에는 모든 파일들을 반환
}
```

- 전달할 객체가 없으므로 값이 없는것으로 간주하세요라는 의사를 표현할 수 있도록 사용자에게 진짜 객체 대신 NULL을 전달하도록 허용하는 것은 일반적이고 편리한 방법처럼 보임. 하지만 각각의 객체가 자신의 행동을 온전히 책임진다는 객체 패러다임과는 상반되는 아이디어
- Null이 허용하는 find는 다음과 같이 분기가 필요함

```java
public Iterable<File> find(String mask) {
    if (mask == null) {
        // 모든 파일을 찾음
    } else {
        // 마스크를 사용해서 파일을 찾음
    }
}
```

- 이 코드에서 문제가 되는 부분이 ```mask == null```인데, mask 객체에게 이야기 하는 대신, 이 객체를 피하고 무시함. 이는 예의바른 의사소통 방식이 아님


```java
public Iterable<File> find(Mask mask) {
    Collection<File> files = new LinkedList<>();
    for (File file : /* 모든 파일 */) {
        if(mask.matchs(file))  {
            files.add(file);
        }
    }
    return files;
}
```

- mask 객체를 존중 한다면 조건의 존재 여부를 객체 스스로에게 결정하게 함. 인자의 값으로 Null을 허용하면 ```mask == null``` 과 같은 비교문을 사용해야 하는데, 이렇게 되면 객체와 협력할 때마다 객체의 실체를 확인하는것 말고는 null인지 여부를 판단할 수가 없음
- OOP에서 존재하지 않는 인자 문제는 널 객체를 이용해서 해결해야함. 전달할 것이 없다면 비어있는 것처럼 행동하는 객체를 전달하면 됨. 전달한 인자가 객체인지 Null인지 확인하는 짐을 메소드 구현자에게 떠넘겨서는 안되며, 항상 객체를 전달하되 무리한 요청을 한다면 응답을 거부하도록 객체를 구현 해야함

```java
interface Mask {
    boolean matches(File file);
}

class AnyFile implements Mask {
    @Override
    boolean matches(File file) {
        return true;
    }
}
```

- 따라서 이전의 예제에서는 위와 같은 Mask 인터페이스를 만들고, AnyFile과 같이 널 객체를 만들어야함. find 메서드는 무슨 일이 일어나는지를 전혀 알지 못한채 올바른 Mask가 전달 되었다고 생각 할것
- 메서드의 인자로 Null을 허용하지 않기로 했다고 해도 클라이언트가 여전히 Null을 전달하는 경우엔 2가지 방법으로 대응 가능
- 첫번째는 Null을 체그하고 예외를 던지는 것임
- 두번째는 Null을 무시하는 것인데, 인자가 Null이 아니라고 가정하고 어떤 대비도 하지 않음으로써 NPE가 던져지고 메서드 호출자가 자신이 실수 했다는 사실을 인지하게 하는것임
- 중요하지 않은 Null 확인 로직으로 코드를 오염시켜서는 안되며, NPE는 잘못된 위치에 Null이 전달 되었다는 사실을 알려주는 올바른 지표임

## 충성스러우면서 불변이거나, 아니면 상수 이거나
- 불변 객체만으로 세상을 모델링할 수 없는것은 아님. 상태와 데이터에 관해서 오해하고 있기 때문에 혼란이 발생 하는것

```java
class WebPage {
    private final URI uri;

    WebPage(URI path) {
        this.uri = path;
    }

    public String content() {
        //Logic
    }
}
```

- WebPage는 불변임. content()가 호출 될 때마다 서로 다른 값이 반환되더라도 이 객체는 불변임
- 직관적으로 사람들은 불변 객체의 메서드를 호출 할 때마다 상수처럼 매번 동일한 데이터가 반환되리라 생각하지만 이는 잘못된 생각임
- 객체란 실제 엔티티의 대표자로, 모든 객체는 식별자, 상태, 행동을 포함함. 불변객체와 가변객체의 차이가 불변 객체에는 식별자가 존재하지 않으며 절대로 상태를 변경할 수 없다는것. 불변 객체의 식별자는 객체의 상태와 완전히 동일
- 가변 객체의 상태는 변경 가능하기 떄문에 상태에 독립적인 식별자를 별도로 포함해야 함
- 불변 객체는 실제 객체가 어디에 존재하고 어떤 방식으로 사용해야 하는지를 알고있음. 불변 객체는 좌표를 알고있고 이 좌표가 바로 상태임. 불변 객체는 자신이 대표하는 실세계의 엔티티에 충성함. 즉, 엔티티의 좌표를 절대 변경하지 않음
- 객체가 대표하는 실제 엔티티와 객체의 상태가 동일한 경우가 바로 상수임. 상수 객체는 불변 객체의 특별한 경우임
- 상수 객체가 설계, 유지보수, 이해하기 쉽기 때문에 불변 객체보다는 상수 객체를 쓰는것이 더 나음

## 절대 getter/setter를 사용하지 마라

```c++
struct Cash {
    int dollars;
}

class Cash {
    public:
        Cash(int v): dollars(v) {};
        std::string print() const;
    private:
        int dollars;
}

printf("Cash value is %d", cash.dollars);
printf("Cash value is %s", cash.print());
```

- 자료구조인 struct의 경우 멤버인 dollars에 직접 접근한 후 해당 값을 정수로 취급함. struct를 가지고는 어떤 일도 하지 않으며, struct와는 어떤 의사소통도 하지않고 직접적으로 멤버에 접근함. struct는 어떤 개성도 지니지 않은 데이터 가방일 뿐임
- 클래스는 다른데, 클래스는 어떤식으로든 멤버에게 접근하는것을 허용하지 않으며, 자신의 멤버를 노출하지도 않음. 우리가 할수있는것이라곤 객체에게 자신을 print하라고 요청하는것일 뿐인데, print가 어떤 방식으로 동작하는지도 알 수 없음. 이게 캡슐화임
- 자료구조는 투명하고, 수동적이고 죽어있지만, 객체는 불투명하고 능동적이고 살아있음
- 객체지향적이고 선언형 스타일을 유지하기 위해서는 데이터를 객체 안에 감추고 절대로 외부에 노출해서는 안됨. 정확하게 무엇을 캡슐화 하고있고, 자료구조가 얼마나 복잡한지는 오직 객체만이 알고 있어야함. 이런 의미에서 getter/setter는 캡슐화 원칙을 위반하기 위해서 걸계됨
- getter/setter는 겉으로 보기엔 메서드 처럼 보이지만, 실제로는 우리가 데이터에 직접 접근하고 있다는 불쾌한 현실을 가리고 있을 뿐. 데이터는 무방비로 노출되어있는것과 같음
- getter/setter 안티패턴에서 유해한 부분이 접두사인 get/set임. 이 객체가 자료구조라는 사실을 명확하게 전달함

```java
class Cash {
    private final int value;
    public int dollars() {
        return this.value;
    }
}

class Cash {
    private final int value;
    public int getDollars() {
        return this.value;
    }
}
```

- 어떤 데이터를 반환하는 메서드를 포함하는것은 괜찮지만, 그 메서드의 이름을 get~ 으로 짓는것은 적절치 않음
- getDollars는 "데이터 중에 dollars를 찾고 반환하라"고 이야기 하는것이고, dollars는 "얼마나 많은 달러가 필요한가?"fkrh anesmsrjtdla
- dollars는 데이터를 노출하지 않지만, getDollars는 데이터를 노출함

### 부 생성자 밖에서는 new를 사용하지 마라

```java
class Cash {
    private final int dollars;

    public int euro() {
        return new Exchange().rate("USD","EUR") * this.dollars;
    }
}
``` 

- 위의 예제는 의존성에 문제가 있는 코드의 전형적 모습임. euro메서드 안에서 new 연산자를 통해 Exchange 인스턴스를 생성 하는데, 이것이 하드 코딩된 의존성임. Cash 클래스가 Exchange에 직접 연결되어 있어, 의존성을 끊기 위해서는 Cash 클래스의 내부 코드를 변경하는수밖에 없음
- 이 예제에서 Cash가 Exchange의 인스턴스를 직접 생성하고 이것이 바로 문제임

```java
class Cash {
    private final int dollars;
    private final Exchange exchange;

    Cash(int value, Exchange exch) {
        this.dollars = value;
        this.exchange = exch;
    }

    public int euro() {
        return this.exchange.rate("USD","EUR") * this.dollars;
    }
}
```

- Cash 클래스는 더이상 Exchange 인스턴스를 직접 생성할 수 없고, 오직 생성자를 통해 제공된 Exchange와만 협력할 수 있음. Cash 클래스는 더이상 Exchange에 의존하지 않음. 의존성을 제어하는 주체가 Cash가 아닌 우리 자신임
- 객체가 필요한 의존성을 직접 생성하는 대신, 우리가 생성자를 통해 직접 의존성을 주입함. 이것이 의존성 주입(Dependency Injection)임. 의존성을 주입하는것은 매우 좋은 프랙티스로, 필요한 의존성 전체를 생성자를 통해 전달받기 때문에 Cash의 설계는 매우 훌륭함. 편의를 위해 여러 부 생성자를 추가할수도 있음
- 어떤 객체라도 훌륭하게 설계할 수 있는 간단한 규칙 하나가 바로 부 생성자를 제외한 어떤곳에서도 new를 허용하지 않는것임
- 이 규칙이 의존성 주입과 제어 역전에 관해 알아야 하는 전부라고 생각함. 부 생성자에서만 new를 사용해야한다는 규칙과 불변 객체를 조합하면 코드는 깔끔해지고 언제든지 의존성을 주입할 수 있게됨

## 인트로스팩션과 캐스팅을 피하라
- 타입 인트로스팩션과 캐스팅을 사용하고 싶은 유혹에 빠지더라도 절대 사용해서는 안됨. instanceof 연산자와 Class.cast()메서드도 포함됨
- 타입 인트로스팩션은 리플렉션이라고 불리는 여러 기법중 하나인데, 리플랙션은 매우 강력하지만 코드를 유지보수하기 어렵게 만드는 매우 너저분한 기법임

```java
public <T> int size(Iterable<T> items) {
    if(items instanceof Collection) {
        return Collection.class.cast(item).size();
    }

    int size = 0;
    for(T item : items) {
        ++size;
    }
    return size;
}
```

- 위 코드는 타입에 따라 객체를 차별하기 때문에 OOP의 기본 사상을 심각하게 훼손시킴. 객체를 차별하지말고 누구건 상관없이 자신의 일을 할 수 있도록 해야 함
- 런타임에 객체의 타입을 조사하는것은 클래스 사이의 결합도도 높아지기 때문에 기술적 관점에서도 좋지 않음. 또 메서드를 효과적으로 사용하기 위해서는 메서드 내부 동작을 이해할 필요가 있다는 문제가 있음


```java
public <T> int size(Collection<T> items) {
    return items.size();
}

public <T> int size(Iterable<T> items) {
    int size = 0;
    for (T item : items) {
        ++size;
    }
    return size;
}
```

- 위와 같이 메서드 오버로딩을 하면 더 나은 설계로 만들 수 있음
- 사전에 약속하지 않았던 새로운 계약을 따르도록 강제하는 클래스 캐스팅에도 동일하게 적용됨
- instanceof 연산자를 사용하거나 클래스를 캐스팅 하는일은 안티패턴이기 떄문에 사용해서는 안됨
