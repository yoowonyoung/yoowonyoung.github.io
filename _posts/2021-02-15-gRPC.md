---
layout: post
title: "gRPC"
description: gRPC 공부
date: 2021-02-15 21:12:00 +09:00
categories: gRPC Study
permalink: '/gRPC'
---

# gRPC 소개
- 클라우드 네이티브 애플리케이션이나 마이크로서비스용 동기적 요청-응답 스타일의 통신을 구축할때에는 주로 RESTful 서비스로 구성하는데, 많은 경우 RESTful 서비스는 프로세스간 통신을 구축할때 부피가 크고 비효율적이며, 에러가 쉽게 발생되기 때문에 좀더 효율적이고 확장 가능하며 느슨하게 결합되는 프로세스간 통신이 종종 요구된다. 이러한 배경에서 gRPC가 등장하게 되었다
- gRPC는 주로 통신에 동기적 요청-응답 스타일을 사용하지만, 초기 통신이 설정되면 완전 비동기식이거나 스트리밍 모드에서도 동작이 가능하다

## gRPC
- gRPC 애플리케이션을 개발할 때 가장 먼저 해야 할일은 서비스 인터페이스를 정의하는 것인데, 서비스를 사용하는 방법, 원격을 호출되는 메서드 종류, 해당 메서드를 호출하기 위한 파라미터, 메시지 형식등을 포함한다. 이와같은 서비스 정의에 사용되는 언어를 인터페이스 정의 언어라고 한다
- 서비스 정의를 사용해 서버 스켈레톤이라는 서버 코드를 생성할 수 있는데, 저수준의 통신 추상화를 통해 서버측 로직을 단순화 할 수 있다
- 클라이언트도 비슷하게 클라이언트 스텁 이라는 코드를 생성 할 수 있는데, 다양한 프로그래밍언어에 대한 낮은 수준의 통신을 추상화 함으로써, 클라이언트측 통신을 단순화 시킨다
- 서비스 인터페이스 정의에 지정된 메서드는 로컬 함수를 호출하는것처럼 쉽게 클라이언트측에서 원격으로 호출 할 수 있고, gRPC프레임워크는 엄격한 서비스 규격 확인, 데이터 직렬화, 네트워크 통신, 인증, 엑세스 제어, 관찰 가능성등과 관련된 모든 복잡한 부분을 처리한다

## 서비스 정의
- gRPC는 프로토콜 버퍼를 인터페이스 정의 언어로 사용해 서비스 인터페이스를 정의한다
- 서비스 인터페이스 정의는 프로토 파일(*.proto)에 표현되며, 프로토콜 버퍼 메시지로 gRPC 메서드 파라미터 및 반환 타입과 함께 gRPC 서비스를 일반 프로토콜 버퍼 형식으로 정의 한다. 그리고 이 서비스 정의는 프로토콜 버퍼 형식의 확장이므로 프로토 파일에서 코드를 생성하고자 gRPC 플러그인이 사용 된다
- 서비스는 원격으로 호출 될 수 있는 메서드의 모음이며, 각 메서드에는 서비스의 일부로 정의 되거나 다른 프로토콜 버퍼 정의로 가져올 수 있는 입력 파라미터와 반환 타입을 갖고 있다
- 입력과 출력 파라미터는 사용자 정의 타입이거나 프로토콜 버퍼의 이미 알려진 타입일 수 있고, 이런 타입들은 메시지로 구조화 되는데, 각 메시지는 필드라는 일련의 값 - 이름 을 포함하는 작은 논리적 레코드이며, 메시지 바이너리 형식에서 필드를 식별하기 위한 고유 필드 번호를 갖는다

## gRPC 서버
- 서비스 정의가 완료되면 프로토콜 버퍼 컴파일러인 protoc를 사용해 서버나 클라이언트 코드를생성 할 수 있다
- 프로토콜 버퍼용 gRPC 플러그인을 사용하면, gRPC의 서버측과 클라이언트 측 코드 뿐만 아니라, 정의된 타입의 데이터 지정, 직렬화, 데이터 취득등의 일반 프로토콜 버퍼 코드도 생성이 가능하다
- 서버측에서는 다음과 같은 처리를 해야 한다
    * 상위 서비스 클래스 로직을 오버라이드 함으로써 생성된 서버 스켈레톤의 서비스 로직을 구현한다
    * gRPC서버를 실행해 클라이언트 요청을 수신하고 응답한다

## gRPC 클라이언트
- 서버와 마찬가지로 서비스 정의를 사용해 클라이언트 스텁을 생성한다. 스텁은 서버와 동일한 메서드를 제공하는데, 클라이언트 코드에서 메서드들의 호출을 네트워크상의 원격 메서드 호출로 변환하는 것이다

## 클라이언트 - 서버 메시지 흐름
- gRPC 클라이언트가 gRPC서비스를 호출할 때, 클라이언트의 gRPC 라이브러리는 프로토콜 버퍼를 사용해 원격 프로시저 호출 프로토콜 버퍼 형식으로 마샬링 해서 HTTP/2를 통해 전송한다
- 서버 측에서는 언마샬링하고 각 프로시저 호출은 프로토콜 버퍼에 의해 실행된다
- 전송 프로토콜로는 양방향 메시지를 지원하는 고성능 바이너리 프로토콜인 HTTP/2를 사용한다

## gRPC 장점
- 프로세스간 통신 효율성: JSON이나 XML대신 프로토콜 버퍼 기반의 바이너리 프로토콜을 사용해 HTTP/2로 구현되어 통신속도가 빠르다
- 간단 명확한 서비스 인퍼테이스와 스키마: 서비스 인터페이스를 먼저 정의한 후에 나중에 구현 세부사항을 작업한다
- 업격한 타입 점검 형식: 프로토콜 버퍼를 사용하기 때문에 gRPC 서비스 계약은 애플리케이션간의 통신에 사용할 데이터 타입을 명확하게 정의한다
- 폴리글랏: gRPC는 여러 프로그래밍 언어와 작동하도록 설계됬고, 특정 언어에 구애받지 않는다
- 이중 스트리밍: gRPC는 클라이언트나 서버측 스트리밍을 기본적으로 지원하며, 서비스 정의 자체에 포함되기 때문에, 스트리밍 서비스나 스트리밍 클라이언트를 훨씬 쉽게 개발할 수 있다
- 유용한 내장 기능 지원: gRPC는 인증, 암호화, 복원력, 메타데이터 교환, 압축, 로드밸런싱, 서비스 검색과 같은 특수 기능을 기본적으로 지원한다
- 클라우드 네이티브 생태계와의 통합: CNCF의 일부이며 최신 프레임워크와 기술은 gRPC를 기본적으로 지원한다

## gRPC 단점
- 외부 서비스 부적합: 계약 기반이면서 강력한 타입속성을 가지므로, 외부 당사자에게 노출되는 서비스의 유연성이 방해될 수 있으며, 사용자는 훨씬 적은 제어권을 갖는다
- 서비스 정의의 급격한 변경에 따른 개발 프로세스의 복잡성: 서비스 정의가 급격하게 변경되면 클라이언트와 서버 코드를 모두 변경 해야 한다
- 상대적으로 적은 생태계

