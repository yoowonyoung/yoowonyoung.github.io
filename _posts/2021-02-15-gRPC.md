---
layout: post
title: "gRPC"
description: gRPC 공부
date: 2021-02-15 21:12:00 +09:00
categories: gRPC Study
permalink: '/gRPC'
---

# gRPC 소개
- 클라우드 네이티브 애플리케이션이나 마이크로서비스용 동기적 요청-응답 스타일의 통신을 구축할때에는 주로 RESTful 서비스로 구성하는데, 많은 경우 RESTful 서비스는 프로세스간 통신을 구축할때 부피가 크고 비효율적이며, 에러가 쉽게 발생되기 때문에 좀더 효율적이고 확장 가능하며 느슨하게 결합되는 프로세스간 통신이 종종 요구된다. 이러한 배경에서 gRPC가 등장하게 되었다
- gRPC는 주로 통신에 동기적 요청-응답 스타일을 사용하지만, 초기 통신이 설정되면 완전 비동기식이거나 스트리밍 모드에서도 동작이 가능하다

## gRPC
- gRPC 애플리케이션을 개발할 때 가장 먼저 해야 할일은 서비스 인터페이스를 정의하는 것인데, 서비스를 사용하는 방법, 원격을 호출되는 메서드 종류, 해당 메서드를 호출하기 위한 파라미터, 메시지 형식등을 포함한다. 이와같은 서비스 정의에 사용되는 언어를 인터페이스 정의 언어라고 한다
- 서비스 정의를 사용해 서버 스켈레톤이라는 서버 코드를 생성할 수 있는데, 저수준의 통신 추상화를 통해 서버측 로직을 단순화 할 수 있다
- 클라이언트도 비슷하게 클라이언트 스텁 이라는 코드를 생성 할 수 있는데, 다양한 프로그래밍언어에 대한 낮은 수준의 통신을 추상화 함으로써, 클라이언트측 통신을 단순화 시킨다
- 서비스 인터페이스 정의에 지정된 메서드는 로컬 함수를 호출하는것처럼 쉽게 클라이언트측에서 원격으로 호출 할 수 있고, gRPC프레임워크는 엄격한 서비스 규격 확인, 데이터 직렬화, 네트워크 통신, 인증, 엑세스 제어, 관찰 가능성등과 관련된 모든 복잡한 부분을 처리한다

## 서비스 정의
- gRPC는 프로토콜 버퍼를 인터페이스 정의 언어로 사용해 서비스 인터페이스를 정의한다
- 서비스 인터페이스 정의는 프로토 파일(*.proto)에 표현되며, 프로토콜 버퍼 메시지로 gRPC 메서드 파라미터 및 반환 타입과 함께 gRPC 서비스를 일반 프로토콜 버퍼 형식으로 정의 한다. 그리고 이 서비스 정의는 프로토콜 버퍼 형식의 확장이므로 프로토 파일에서 코드를 생성하고자 gRPC 플러그인이 사용 된다
- 서비스는 원격으로 호출 될 수 있는 메서드의 모음이며, 각 메서드에는 서비스의 일부로 정의 되거나 다른 프로토콜 버퍼 정의로 가져올 수 있는 입력 파라미터와 반환 타입을 갖고 있다
- 입력과 출력 파라미터는 사용자 정의 타입이거나 프로토콜 버퍼의 이미 알려진 타입일 수 있고, 이런 타입들은 메시지로 구조화 되는데, 각 메시지는 필드라는 일련의 값 - 이름 을 포함하는 작은 논리적 레코드이며, 메시지 바이너리 형식에서 필드를 식별하기 위한 고유 필드 번호를 갖는다

## gRPC 서버
- 서비스 정의가 완료되면 프로토콜 버퍼 컴파일러인 protoc를 사용해 서버나 클라이언트 코드를생성 할 수 있다
- 프로토콜 버퍼용 gRPC 플러그인을 사용하면, gRPC의 서버측과 클라이언트 측 코드 뿐만 아니라, 정의된 타입의 데이터 지정, 직렬화, 데이터 취득등의 일반 프로토콜 버퍼 코드도 생성이 가능하다
- 서버측에서는 다음과 같은 처리를 해야 한다
    * 상위 서비스 클래스 로직을 오버라이드 함으로써 생성된 서버 스켈레톤의 서비스 로직을 구현한다
    * gRPC서버를 실행해 클라이언트 요청을 수신하고 응답한다

## gRPC 클라이언트
- 서버와 마찬가지로 서비스 정의를 사용해 클라이언트 스텁을 생성한다. 스텁은 서버와 동일한 메서드를 제공하는데, 클라이언트 코드에서 메서드들의 호출을 네트워크상의 원격 메서드 호출로 변환하는 것이다

## 클라이언트 - 서버 메시지 흐름
- gRPC 클라이언트가 gRPC서비스를 호출할 때, 클라이언트의 gRPC 라이브러리는 프로토콜 버퍼를 사용해 원격 프로시저 호출 프로토콜 버퍼 형식으로 마샬링 해서 HTTP/2를 통해 전송한다
- 서버 측에서는 언마샬링하고 각 프로시저 호출은 프로토콜 버퍼에 의해 실행된다
- 전송 프로토콜로는 양방향 메시지를 지원하는 고성능 바이너리 프로토콜인 HTTP/2를 사용한다

## gRPC 장점
- 프로세스간 통신 효율성: JSON이나 XML대신 프로토콜 버퍼 기반의 바이너리 프로토콜을 사용해 HTTP/2로 구현되어 통신속도가 빠르다
- 간단 명확한 서비스 인퍼테이스와 스키마: 서비스 인터페이스를 먼저 정의한 후에 나중에 구현 세부사항을 작업한다
- 업격한 타입 점검 형식: 프로토콜 버퍼를 사용하기 때문에 gRPC 서비스 계약은 애플리케이션간의 통신에 사용할 데이터 타입을 명확하게 정의한다
- 폴리글랏: gRPC는 여러 프로그래밍 언어와 작동하도록 설계됬고, 특정 언어에 구애받지 않는다
- 이중 스트리밍: gRPC는 클라이언트나 서버측 스트리밍을 기본적으로 지원하며, 서비스 정의 자체에 포함되기 때문에, 스트리밍 서비스나 스트리밍 클라이언트를 훨씬 쉽게 개발할 수 있다
- 유용한 내장 기능 지원: gRPC는 인증, 암호화, 복원력, 메타데이터 교환, 압축, 로드밸런싱, 서비스 검색과 같은 특수 기능을 기본적으로 지원한다
- 클라우드 네이티브 생태계와의 통합: CNCF의 일부이며 최신 프레임워크와 기술은 gRPC를 기본적으로 지원한다

## gRPC 단점
- 외부 서비스 부적합: 계약 기반이면서 강력한 타입속성을 가지므로, 외부 당사자에게 노출되는 서비스의 유연성이 방해될 수 있으며, 사용자는 훨씬 적은 제어권을 갖는다
- 서비스 정의의 급격한 변경에 따른 개발 프로세스의 복잡성: 서비스 정의가 급격하게 변경되면 클라이언트와 서버 코드를 모두 변경 해야 한다
- 상대적으로 적은 생태계

# gRPC 시작

## 서비스 정의 작성
- gRPC 애플리케이션을 개발할때 가장 먼저 해야할 일은 프로토콜 버퍼로 소비자가 원격으로 호출 할 수 있는 메서드와, 메서드 파라미터, 사용할 메시지 포맷등을 포함하는 서비스 인터페이스를 정의하는것

## 메시지 정의
- 메시지는 클라이언트와 서비스간에 교환되는 데이터 구조
- 메시지의 각 필드에 지정된 번호는, 메시지에서 필드를 교유하게 식별하는데 사용되기 때문에, 같은 메시지 정의 안에서 서로 다른 두 필드에 같은 번호를 사용 할 수 없다

## 서비스 정의
- 서비스는 클라이언트에 제공되는 원격 메서드의 모음이다
- 프로토콜 버퍼 규칙에 따르면 원격 메서드에는 하나의 입력 파라미터만 가질수 있으며, 하나의 값만 반환 할 수 있다
- 메서드에 여러 값을 전달해야 하는 경우, 메시지 타입을 정의하고 모든 값을 메시지 타입으로 그룹화 해야 한다

## 구현
- gRPC의 원격 메서드들은 서버에 의해 제공되며, gRPC 클라이언트는 서버에 연결해 해당 원격 메서드를 호출 한다
- gRPC는 기본적으로 Java, Go, Pyhton, Ruby, C, C++, Node등 여러 프로그래밍 언어를 지원한다

## 서비스 개발
- 서비스 스켈레톤 코드를 생성하면 gRPC 통신, 관련 메시지 타입, 인터페이스를 생성하는데 필요한 저수준의 코드가 제공된다
- 이를 이용해 비즈니스 로직을 구현하면 된다

# gRPC 통신 패턴

## 단순 RPC(단일 RPC)
- 단순 RPC에서는 클라이언트가 서버의 원격 기능을 호출하고자 단일 요청을 서버로 보내고, 상태에 대한 세부 정보 및 후행 메타 데이터와 함께 단일 응답을 받는다

## 서버 스트리밍 RPC
- 서버 스트리밍 RPC에서는 서버가 클라이언트의 요청 메시지를 받은 후 일련의 응답을 다시 보낸다. 이러한 일련의 응답을 스트림이라고 한다
- 모든 서버 응답을 보낸후에 서버는 서버의 상태 정보를 후행 메타데이터로 클라이언트에 전송해 스트림의 끝을 알린다
- 메서드 정의는 단순 RPC와 매우 유사하지만, 프로토 서비스 정의 파일에서 반환 파라미터로 returns(stream message)와 같은 형식을 사용해 스트림을 지정하고있다

## 클라이언트 스트리밍 RPC
- 클라이언트 스트리밍 RPC에서는 클라이언트가 하나의 요청이 아닌 여러 메시지를 서버로 보내고, 서버는 클라이언트에게 단일 응답을 보낸다
- 서버는 클라이언트에서 모든 메시지를 수신해 응답을 보낼때까지 기다릴 필요는 없다. 필요한 로직에 따라 스트림에서 하나 또는 여러개의 메시지를 읽은 후 또는 모든 메시지를 읽은 후 응답을 보낼 수 있다

## 양방향 스트리밍 RPC
- 양방향 스트리밍 RPC에서 클라이언트는 메시지 스트림으로 서버에 요청을 보내고, 서버는 메시지 스트림으로도 응답한다. 호출은 클라이언트에서 시작하지만 그 후 통신은 gRPC 클라이언트와 서버의 애플리케이션 로직에 따라 완전히 다르다
- 일단 RPC메서드가 호출되면 클라이언트나 서비스가 임의의 시간에 메시지를 보낼 수 있다는것이다
- 클라이언트는 동일한 스트림을 동시에 읽고 쓸 수 있으며 수신 스트림과 발신 스트림 모두 독립적으로 동작한다

## 마이크로 서비스 통신을 위한 gRPC
- gRPC의 주요 활동중 하나는 마이크로 서비스와 이들 서비스간 통신을 구현하는 것이다
- 마이크로 서비스에서 서비스간 통신에서 gRPC는 다른 통신 프로토콜과 함께 사용되며, 일반적으로 gRPC는 폴리글랏 서비스(다른 프로그래밍 언어로 개발)로 구현된다
- 대부분의 동기식 메시지 전달 시나리오에서도 gRPC를 사용할 수 있으며, 영속성 메시징이 필요한 특정 비동기 메시징 시나리오인 경우에는 카프카, 액티브MQ, 래빗MQ 등과 같은 메시지 브로커를 사용할 수 있다
- 특정 비즈니스 기능을 외부에 제공해야 하는 경우는 기존 REST/OpenAPI 기반 서비스나, 그래프QL 서비스를 사용하기도 한다


# gRPC 동작원리

## RPC흐름
- RPC시스템에서 서버는 원격으로 호출되는 일련의 기능을 구현하고, 클라이언트 애플리케이션은 서버에서 제공하는 동일한 함수에대한 추상화를 제공하는 스텁을 생성해 클라이언트 애플리케이션이 서버 애플리케이션의 원격 함수를 호출하는 직접 호출한다
- 호출 흐름
    - 클라이언트 프로세스는 생성된 스텁에 있는 원격 함수를 호출
    - 클라이언트 스텁은 인코딩 메시지로 HTTP POST 요청을 생성
        - gRPC에서는 모든 요청이 application/grpc 접두어가 붙는 콘텐츠 타입을 가진 HTTP POST 요청
        - 호출하는 원격 함수는 별도의 HTTP 헤더로 전송
    - HTTP 요청 메시지는 네트워크를 통해 서버 머신으로 전송
    - 서버가 메시지를 수신하여, 메시지 헤더를 검사해 어떤 서비스 함수를 호출해야하는지 확인하고, 메시지를 서비스 스텁에 넘긴다
    - 서비스 스텁은 메시지 바이트를 언어별 데이터 구조로 파싱
    - 파싱된 메시지를 사용해 로컬 함수를 호출
    - 서비스의 함수의 응답이 인코딩되어 클라이언트로 다시 전송(응답 메시지는 클라이언트와 동일한 절차를 따름)

## 프로토콜 버퍼를 사용한 메시지인코딩
- gRPC는 프로토콜 버퍼를 사용해 gRPC 서비스의 서비스 정의를 작성한다
- 프로토콜 버퍼의 서비스 정의는 원격 메서드 정의와 네트워크를 통해 보내려는 메시지 정의를 포함
- 메시지를 정의하는 방법에 따라 메시지 인코딩방식이 결정되므로 메시지를 올바르게 정의하는게 중요하다
- 메시지를 인코딩하고 바이트로 변환할때, 메시지 정의에 따라 생성된 소스코드에 의해 메시지 변환이 처리된다
- 메시지 인스턴스를 만들면 이에 해당되는 바이트는 값 필드의 식별자와 인코딩된 값으로 구성되는데, 이 필드 식별자는 태그 라고도 한다
    - 태그는 필드 인덱스와 와이어타입 두가지 값으로 구성
    - 필드 인덱스는 프로토 파일에서 메시지를 정의할 때 각 메시지 필드에 할당된 고유 번호
    - 와이어 타입은 필드가 가질수 있는 데이터 타입인 필드 타입을 기반, 값의 길이를 찾기 위한 정보를 제공
- 인코딩기술
    - 가변 길이 정수
    - 부호 있는 정수
    - 비가변 길이 정수 숫자
    - 문자열 타입

## 길이-접두사 프레이밍
- 상대방에게 전송할 인코딩 데이터가 있으면 당사자가 쉽게 정보를 추출할수있는 방식을 데이터로 패키징 해야 한다. gRPC에서는 네트워크를 통해 전송할 메시지를 패키지화 하고자 길이-접두사 지정 프레이밍이라는 메시지 프레이밍 기술을 사용한다
- gRPC의 통신은 최대 4GB크기의 모든 메시지를 처리 할 수 있다
- 수신측에서 메시지를 받으면 먼저 첫번째 바이트를 읽어 메시지의 압축 여부를 확인해야 한다. 그 다음 수신자는 4바이트를 더 읽어 인코딩된 바이너리 메시지의 크기를 얻는다

## HTTP/2를 통한 gRPC
- gRPC채널은 HTTP/2연결인 엔드포인트에 대한 연결을 나타낸다
- 클라이언트 애플리케이션이 gRPC채널을 만들면 내부적으로 서버와 HTTP/2 연결을 만드는데, 채널이 생성되면 서버로 여러개의 원격 호출을 보낼수 있도록 재사용된다
- 요청 메시지
    - 원격 호출을 시작하는 메시지
    - gRPC에서 요청 메시지는 항상 클라이언트 애플리케이션에 의해 트리거
    - 클라이언트가 요청 헤더를 보내면 원격 호출이 시작되고 길이-접두사 지정 메시지가 해당 호출로 전송
    - 마지막으로 스트림 종료 플래그가 전송되 수신자에게 요청 메시지 전송이 완료됬음을 알림
- 요청 헤더 예제

```
HEADERS (flags = END_HEADERS)
:method = POST -> gRPC는 항상 POST
:scheme = http
:path = /ProductInfo/getProduct
:authority = abc.com
te = trailers -> 호환되지 않는 프록시 탐지를 정의. gRPC의 경우 "trailers"여야 한다
grpc-timeout = 15
content-type = application/grpc -> grpc는 항상 applicaition/grpc로 시작해야 한다
grpc-encodint = gzip
authorization = Bearer xxxx
```

- 응답 메시지
    - 응답 메시지는 클라이언트 요청에 대한 응답으로 서버에 의해 생성
    - 응답 헤더, 길이-접두사 지정 메시지, 트레일러의 세가지 주요 요소로 구성
    - 클라이언트에 응답으로 보낼 길이-접두사 지정 메시지가 없는 경우 응답 메시지는 헤더와 트레일러로만 구성
- 응답 메시지 예제

```
HEADERS (flags = END_HEADERS)
:status = 200
grpc-encoding = gzip
content-type = application/grpc
```

## gRPC 통신 패턴에서의 메시지 흐름 이해
- 단순 RPC
    - 단순 RPC에서는 gRPC서버와 gRPC클라이언트간의 통신에서 항상 단일 요청과 단일 응답이 있다
    - 단일 요청 메시지에는 헤더와 하나 이상의 데이터 프레임에 걸쳐 있을수 있는 길이-접두사 지정 메시지가 포함된다
    - 클라이언트측에서 연결 절반 종료(연결을 닫아 더 서버로 메시지를 보낼순 없지만, 받는건 가능) 하려면 요청 메시지의 끝에 스트림 종료 플래그를 추가한다
- 서버 스트리밍 RPC
    - 서버는 하나의 응답 메시지를 클라이언트에 보내지 않고 여러 메시지를 보낸다
    - 서버는 전체 요청 메시지를 수신할때까지 기다렸다가 응답 헤더와 여러 길이-접두사 지정 메시지를 보낸다
- 클라이언트 스트리밍 RPC
    - 클라이언트가 여러 메시지를 서버로 보내고 서버는 응답으로 하나의 응답 메시지만 보낸다
    - 클라이언트는 먼저 헤더 프레임을 전송해 서버와의 연결을 설정, 그 이후 여러 길이-접두사 지정 메시지를 데이터 프레임으로 서버에 보낸다
    - 최종적으로 클라이언트는 마지막 데이터 프레임에 EOS플래그를 전송해 연결 절반을 닫는다
    - 모든 메시지를 받으면 서버는 후행 헤더와 함께 응답 메시지를 보내므로 연결을 닫는다
- 양방향 스트리밍 RPC
    - 클라이언트가 헤더 프레임을 전송해 연결을 설정한다
    - 클라이언트와 서버는 모두 상대방이 끝날때까지 기다리지 않고 길이-접두사 지정 메시지를 보낸다

## gRPC 구현 아키텍처
- gRPC구현은 여러 레이어로 구성되고, 기본 레이어는 gRPC코어 레이어이다
- 이 레이어는 얇은층으로 상위 레이어의 모든 작업을 추상화해 애플리케이션 개발자가 네트워크를 통해 RPC호출을 쉽게 수행할 수 있게 한다

