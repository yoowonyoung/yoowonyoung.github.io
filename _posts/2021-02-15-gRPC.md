---
layout: post
title: "gRPC"
description: gRPC 공부
date: 2021-02-15 21:12:00 +09:00
categories: gRPC Study
permalink: '/gRPC'
---

# gRPC 소개
- 클라우드 네이티브 애플리케이션이나 마이크로서비스용 동기적 요청-응답 스타일의 통신을 구축할때에는 주로 RESTful 서비스로 구성하는데, 많은 경우 RESTful 서비스는 프로세스간 통신을 구축할때 부피가 크고 비효율적이며, 에러가 쉽게 발생되기 때문에 좀더 효율적이고 확장 가능하며 느슨하게 결합되는 프로세스간 통신이 종종 요구된다. 이러한 배경에서 gRPC가 등장하게 되었다
- gRPC는 주로 통신에 동기적 요청-응답 스타일을 사용하지만, 초기 통신이 설정되면 완전 비동기식이거나 스트리밍 모드에서도 동작이 가능하다

## gRPC
- gRPC 애플리케이션을 개발할 때 가장 먼저 해야 할일은 서비스 인터페이스를 정의하는 것인데, 서비스를 사용하는 방법, 원격을 호출되는 메서드 종류, 해당 메서드를 호출하기 위한 파라미터, 메시지 형식등을 포함한다. 이와같은 서비스 정의에 사용되는 언어를 인터페이스 정의 언어라고 한다
- 서비스 정의를 사용해 서버 스켈레톤이라는 서버 코드를 생성할 수 있는데, 저수준의 통신 추상화를 통해 서버측 로직을 단순화 할 수 있다
- 클라이언트도 비슷하게 클라이언트 스텁 이라는 코드를 생성 할 수 있는데, 다양한 프로그래밍언어에 대한 낮은 수준의 통신을 추상화 함으로써, 클라이언트측 통신을 단순화 시킨다
- 서비스 인터페이스 정의에 지정된 메서드는 로컬 함수를 호출하는것처럼 쉽게 클라이언트측에서 원격으로 호출 할 수 있고, gRPC프레임워크는 엄격한 서비스 규격 확인, 데이터 직렬화, 네트워크 통신, 인증, 엑세스 제어, 관찰 가능성등과 관련된 모든 복잡한 부분을 처리한다

## 서비스 정의
- gRPC는 프로토콜 버퍼를 인터페이스 정의 언어로 사용해 서비스 인터페이스를 정의한다
- 서비스 인터페이스 정의는 프로토 파일(*.proto)에 표현되며, 프로토콜 버퍼 메시지로 gRPC 메서드 파라미터 및 반환 타입과 함께 gRPC 서비스를 일반 프로토콜 버퍼 형식으로 정의 한다. 그리고 이 서비스 정의는 프로토콜 버퍼 형식의 확장이므로 프로토 파일에서 코드를 생성하고자 gRPC 플러그인이 사용 된다
- 서비스는 원격으로 호출 될 수 있는 메서드의 모음이며, 각 메서드에는 서비스의 일부로 정의 되거나 다른 프로토콜 버퍼 정의로 가져올 수 있는 입력 파라미터와 반환 타입을 갖고 있다
- 입력과 출력 파라미터는 사용자 정의 타입이거나 프로토콜 버퍼의 이미 알려진 타입일 수 있고, 이런 타입들은 메시지로 구조화 되는데, 각 메시지는 필드라는 일련의 값 - 이름 을 포함하는 작은 논리적 레코드이며, 메시지 바이너리 형식에서 필드를 식별하기 위한 고유 필드 번호를 갖는다

## gRPC 서버
- 서비스 정의가 완료되면 프로토콜 버퍼 컴파일러인 protoc를 사용해 서버나 클라이언트 코드를생성 할 수 있다
- 프로토콜 버퍼용 gRPC 플러그인을 사용하면, gRPC의 서버측과 클라이언트 측 코드 뿐만 아니라, 정의된 타입의 데이터 지정, 직렬화, 데이터 취득등의 일반 프로토콜 버퍼 코드도 생성이 가능하다
- 서버측에서는 다음과 같은 처리를 해야 한다
    * 상위 서비스 클래스 로직을 오버라이드 함으로써 생성된 서버 스켈레톤의 서비스 로직을 구현한다
    * gRPC서버를 실행해 클라이언트 요청을 수신하고 응답한다

## gRPC 클라이언트
- 서버와 마찬가지로 서비스 정의를 사용해 클라이언트 스텁을 생성한다. 스텁은 서버와 동일한 메서드를 제공하는데, 클라이언트 코드에서 메서드들의 호출을 네트워크상의 원격 메서드 호출로 변환하는 것이다

## 클라이언트 - 서버 메시지 흐름
- gRPC 클라이언트가 gRPC서비스를 호출할 때, 클라이언트의 gRPC 라이브러리는 프로토콜 버퍼를 사용해 원격 프로시저 호출 프로토콜 버퍼 형식으로 마샬링 해서 HTTP/2를 통해 전송한다
- 서버 측에서는 언마샬링하고 각 프로시저 호출은 프로토콜 버퍼에 의해 실행된다
- 전송 프로토콜로는 양방향 메시지를 지원하는 고성능 바이너리 프로토콜인 HTTP/2를 사용한다

## gRPC 장점
- 프로세스간 통신 효율성: JSON이나 XML대신 프로토콜 버퍼 기반의 바이너리 프로토콜을 사용해 HTTP/2로 구현되어 통신속도가 빠르다
- 간단 명확한 서비스 인퍼테이스와 스키마: 서비스 인터페이스를 먼저 정의한 후에 나중에 구현 세부사항을 작업한다
- 업격한 타입 점검 형식: 프로토콜 버퍼를 사용하기 때문에 gRPC 서비스 계약은 애플리케이션간의 통신에 사용할 데이터 타입을 명확하게 정의한다
- 폴리글랏: gRPC는 여러 프로그래밍 언어와 작동하도록 설계됬고, 특정 언어에 구애받지 않는다
- 이중 스트리밍: gRPC는 클라이언트나 서버측 스트리밍을 기본적으로 지원하며, 서비스 정의 자체에 포함되기 때문에, 스트리밍 서비스나 스트리밍 클라이언트를 훨씬 쉽게 개발할 수 있다
- 유용한 내장 기능 지원: gRPC는 인증, 암호화, 복원력, 메타데이터 교환, 압축, 로드밸런싱, 서비스 검색과 같은 특수 기능을 기본적으로 지원한다
- 클라우드 네이티브 생태계와의 통합: CNCF의 일부이며 최신 프레임워크와 기술은 gRPC를 기본적으로 지원한다

## gRPC 단점
- 외부 서비스 부적합: 계약 기반이면서 강력한 타입속성을 가지므로, 외부 당사자에게 노출되는 서비스의 유연성이 방해될 수 있으며, 사용자는 훨씬 적은 제어권을 갖는다
- 서비스 정의의 급격한 변경에 따른 개발 프로세스의 복잡성: 서비스 정의가 급격하게 변경되면 클라이언트와 서버 코드를 모두 변경 해야 한다
- 상대적으로 적은 생태계

# gRPC 시작

## 서비스 정의 작성
- gRPC 애플리케이션을 개발할때 가장 먼저 해야할 일은 프로토콜 버퍼로 소비자가 원격으로 호출 할 수 있는 메서드와, 메서드 파라미터, 사용할 메시지 포맷등을 포함하는 서비스 인터페이스를 정의하는것

## 메시지 정의
- 메시지는 클라이언트와 서비스간에 교환되는 데이터 구조
- 메시지의 각 필드에 지정된 번호는, 메시지에서 필드를 교유하게 식별하는데 사용되기 때문에, 같은 메시지 정의 안에서 서로 다른 두 필드에 같은 번호를 사용 할 수 없다

## 서비스 정의
- 서비스는 클라이언트에 제공되는 원격 메서드의 모음이다
- 프로토콜 버퍼 규칙에 따르면 원격 메서드에는 하나의 입력 파라미터만 가질수 있으며, 하나의 값만 반환 할 수 있다
- 메서드에 여러 값을 전달해야 하는 경우, 메시지 타입을 정의하고 모든 값을 메시지 타입으로 그룹화 해야 한다

## 구현
- gRPC의 원격 메서드들은 서버에 의해 제공되며, gRPC 클라이언트는 서버에 연결해 해당 원격 메서드를 호출 한다
- gRPC는 기본적으로 Java, Go, Pyhton, Ruby, C, C++, Node등 여러 프로그래밍 언어를 지원한다

## 서비스 개발
- 서비스 스켈레톤 코드를 생성하면 gRPC 통신, 관련 메시지 타입, 인터페이스를 생성하는데 필요한 저수준의 코드가 제공된다
- 이를 이용해 비즈니스 로직을 구현하면 된다

# gRPC 통신 패턴

## 단순 RPC(단일 RPC)
- 단순 RPC에서는 클라이언트가 서버의 원격 기능을 호출하고자 단일 요청을 서버로 보내고, 상태에 대한 세부 정보 및 후행 메타 데이터와 함께 단일 응답을 받는다

## 서버 스트리밍 RPC
- 서버 스트리밍 RPC에서는 서버가 클라이언트의 요청 메시지를 받은 후 일련의 응답을 다시 보낸다. 이러한 일련의 응답을 스트림이라고 한다
- 모든 서버 응답을 보낸후에 서버는 서버의 상태 정보를 후행 메타데이터로 클라이언트에 전송해 스트림의 끝을 알린다
- 메서드 정의는 단순 RPC와 매우 유사하지만, 프로토 서비스 정의 파일에서 반환 파라미터로 returns(stream message)와 같은 형식을 사용해 스트림을 지정하고있다

## 클라이언트 스트리밍 RPC
- 클라이언트 스트리밍 RPC에서는 클라이언트가 하나의 요청이 아닌 여러 메시지를 서버로 보내고, 서버는 클라이언트에게 단일 응답을 보낸다
- 서버는 클라이언트에서 모든 메시지를 수신해 응답을 보낼때까지 기다릴 필요는 없다. 필요한 로직에 따라 스트림에서 하나 또는 여러개의 메시지를 읽은 후 또는 모든 메시지를 읽은 후 응답을 보낼 수 있다

## 양방향 스트리밍 RPC
- 양방향 스트리밍 RPC에서 클라이언트는 메시지 스트림으로 서버에 요청을 보내고, 서버는 메시지 스트림으로도 응답한다. 호출은 클라이언트에서 시작하지만 그 후 통신은 gRPC 클라이언트와 서버의 애플리케이션 로직에 따라 완전히 다르다
- 일단 RPC메서드가 호출되면 클라이언트나 서비스가 임의의 시간에 메시지를 보낼 수 있다는것이다
- 클라이언트는 동일한 스트림을 동시에 읽고 쓸 수 있으며 수신 스트림과 발신 스트림 모두 독립적으로 동작한다

## 마이크로 서비스 통신을 위한 gRPC
- gRPC의 주요 활동중 하나는 마이크로 서비스와 이들 서비스간 통신을 구현하는 것이다
- 마이크로 서비스에서 서비스간 통신에서 gRPC는 다른 통신 프로토콜과 함께 사용되며, 일반적으로 gRPC는 폴리글랏 서비스(다른 프로그래밍 언어로 개발)로 구현된다
- 대부분의 동기식 메시지 전달 시나리오에서도 gRPC를 사용할 수 있으며, 영속성 메시징이 필요한 특정 비동기 메시징 시나리오인 경우에는 카프카, 액티브MQ, 래빗MQ 등과 같은 메시지 브로커를 사용할 수 있다
- 특정 비즈니스 기능을 외부에 제공해야 하는 경우는 기존 REST/OpenAPI 기반 서비스나, 그래프QL 서비스를 사용하기도 한다


# gRPC 동작원리

## RPC흐름
- RPC시스템에서 서버는 원격으로 호출되는 일련의 기능을 구현하고, 클라이언트 애플리케이션은 서버에서 제공하는 동일한 함수에대한 추상화를 제공하는 스텁을 생성해 클라이언트 애플리케이션이 서버 애플리케이션의 원격 함수를 호출하는 직접 호출한다
- 호출 흐름
    - 클라이언트 프로세스는 생성된 스텁에 있는 원격 함수를 호출
    - 클라이언트 스텁은 인코딩 메시지로 HTTP POST 요청을 생성
        - gRPC에서는 모든 요청이 application/grpc 접두어가 붙는 콘텐츠 타입을 가진 HTTP POST 요청
        - 호출하는 원격 함수는 별도의 HTTP 헤더로 전송
    - HTTP 요청 메시지는 네트워크를 통해 서버 머신으로 전송
    - 서버가 메시지를 수신하여, 메시지 헤더를 검사해 어떤 서비스 함수를 호출해야하는지 확인하고, 메시지를 서비스 스텁에 넘긴다
    - 서비스 스텁은 메시지 바이트를 언어별 데이터 구조로 파싱
    - 파싱된 메시지를 사용해 로컬 함수를 호출
    - 서비스의 함수의 응답이 인코딩되어 클라이언트로 다시 전송(응답 메시지는 클라이언트와 동일한 절차를 따름)

## 프로토콜 버퍼를 사용한 메시지인코딩
- gRPC는 프로토콜 버퍼를 사용해 gRPC 서비스의 서비스 정의를 작성한다
- 프로토콜 버퍼의 서비스 정의는 원격 메서드 정의와 네트워크를 통해 보내려는 메시지 정의를 포함
- 메시지를 정의하는 방법에 따라 메시지 인코딩방식이 결정되므로 메시지를 올바르게 정의하는게 중요하다
- 메시지를 인코딩하고 바이트로 변환할때, 메시지 정의에 따라 생성된 소스코드에 의해 메시지 변환이 처리된다
- 메시지 인스턴스를 만들면 이에 해당되는 바이트는 값 필드의 식별자와 인코딩된 값으로 구성되는데, 이 필드 식별자는 태그 라고도 한다
    - 태그는 필드 인덱스와 와이어타입 두가지 값으로 구성
    - 필드 인덱스는 프로토 파일에서 메시지를 정의할 때 각 메시지 필드에 할당된 고유 번호
    - 와이어 타입은 필드가 가질수 있는 데이터 타입인 필드 타입을 기반, 값의 길이를 찾기 위한 정보를 제공
- 인코딩기술
    - 가변 길이 정수
    - 부호 있는 정수
    - 비가변 길이 정수 숫자
    - 문자열 타입

## 길이-접두사 프레이밍
- 상대방에게 전송할 인코딩 데이터가 있으면 당사자가 쉽게 정보를 추출할수있는 방식을 데이터로 패키징 해야 한다. gRPC에서는 네트워크를 통해 전송할 메시지를 패키지화 하고자 길이-접두사 지정 프레이밍이라는 메시지 프레이밍 기술을 사용한다
- gRPC의 통신은 최대 4GB크기의 모든 메시지를 처리 할 수 있다
- 수신측에서 메시지를 받으면 먼저 첫번째 바이트를 읽어 메시지의 압축 여부를 확인해야 한다. 그 다음 수신자는 4바이트를 더 읽어 인코딩된 바이너리 메시지의 크기를 얻는다

## HTTP/2를 통한 gRPC
- gRPC채널은 HTTP/2연결인 엔드포인트에 대한 연결을 나타낸다
- 클라이언트 애플리케이션이 gRPC채널을 만들면 내부적으로 서버와 HTTP/2 연결을 만드는데, 채널이 생성되면 서버로 여러개의 원격 호출을 보낼수 있도록 재사용된다
- 요청 메시지
    - 원격 호출을 시작하는 메시지
    - gRPC에서 요청 메시지는 항상 클라이언트 애플리케이션에 의해 트리거
    - 클라이언트가 요청 헤더를 보내면 원격 호출이 시작되고 길이-접두사 지정 메시지가 해당 호출로 전송
    - 마지막으로 스트림 종료 플래그가 전송되 수신자에게 요청 메시지 전송이 완료됬음을 알림
- 요청 헤더 예제

```
HEADERS (flags = END_HEADERS)
:method = POST -> gRPC는 항상 POST
:scheme = http
:path = /ProductInfo/getProduct
:authority = abc.com
te = trailers -> 호환되지 않는 프록시 탐지를 정의. gRPC의 경우 "trailers"여야 한다
grpc-timeout = 15
content-type = application/grpc -> grpc는 항상 applicaition/grpc로 시작해야 한다
grpc-encodint = gzip
authorization = Bearer xxxx
```

- 응답 메시지
    - 응답 메시지는 클라이언트 요청에 대한 응답으로 서버에 의해 생성
    - 응답 헤더, 길이-접두사 지정 메시지, 트레일러의 세가지 주요 요소로 구성
    - 클라이언트에 응답으로 보낼 길이-접두사 지정 메시지가 없는 경우 응답 메시지는 헤더와 트레일러로만 구성
- 응답 메시지 예제

```
HEADERS (flags = END_HEADERS)
:status = 200
grpc-encoding = gzip
content-type = application/grpc
```

## gRPC 통신 패턴에서의 메시지 흐름 이해
- 단순 RPC
    - 단순 RPC에서는 gRPC서버와 gRPC클라이언트간의 통신에서 항상 단일 요청과 단일 응답이 있다
    - 단일 요청 메시지에는 헤더와 하나 이상의 데이터 프레임에 걸쳐 있을수 있는 길이-접두사 지정 메시지가 포함된다
    - 클라이언트측에서 연결 절반 종료(연결을 닫아 더 서버로 메시지를 보낼순 없지만, 받는건 가능) 하려면 요청 메시지의 끝에 스트림 종료 플래그를 추가한다
- 서버 스트리밍 RPC
    - 서버는 하나의 응답 메시지를 클라이언트에 보내지 않고 여러 메시지를 보낸다
    - 서버는 전체 요청 메시지를 수신할때까지 기다렸다가 응답 헤더와 여러 길이-접두사 지정 메시지를 보낸다
- 클라이언트 스트리밍 RPC
    - 클라이언트가 여러 메시지를 서버로 보내고 서버는 응답으로 하나의 응답 메시지만 보낸다
    - 클라이언트는 먼저 헤더 프레임을 전송해 서버와의 연결을 설정, 그 이후 여러 길이-접두사 지정 메시지를 데이터 프레임으로 서버에 보낸다
    - 최종적으로 클라이언트는 마지막 데이터 프레임에 EOS플래그를 전송해 연결 절반을 닫는다
    - 모든 메시지를 받으면 서버는 후행 헤더와 함께 응답 메시지를 보내므로 연결을 닫는다
- 양방향 스트리밍 RPC
    - 클라이언트가 헤더 프레임을 전송해 연결을 설정한다
    - 클라이언트와 서버는 모두 상대방이 끝날때까지 기다리지 않고 길이-접두사 지정 메시지를 보낸다

## gRPC 구현 아키텍처
- gRPC구현은 여러 레이어로 구성되고, 기본 레이어는 gRPC코어 레이어이다
- 이 레이어는 얇은층으로 상위 레이어의 모든 작업을 추상화해 애플리케이션 개발자가 네트워크를 통해 RPC호출을 쉽게 수행할 수 있게 한다


# 고급 기능

## 인터셉터
- gRPC에서는 인터셉터라는 확장 메커니즘을 사용해 로깅, 인증, 메트릭등과 같은 특정 요구사항 충족을 위해 RPC실행을 가로챌 수 있고, 클라이언트와 서버 gRPC 애플리케이션에서 인터셉터를 구현하고 설치하기 위한 간단한 API를 제공한다
- 단순 RPC의 경우 단일 인터셉터를 사용할 수 있지만, 스트리밍 RPC의 경우 스트리밍 인터셉터를 사용해야 한다

## 서버측 인터셉터 
- 클라이언트가 gRPC 서비스의 원격 메서드를 호출할 때 서버에서 인터셉터를 사용해 원격 메서드 실행 전에 공통 로직을 실행 할 수 있다
- gRPC서버에 하나 이상의 인터셉터를 연결 할 수 있다
- 서버에서 단순 인터셉터를 사용하면 단순 RPC호출을 인터셉트 할 수 있으며, 스트리밍 인터셉터는 스트리밍 RPC를 인터셉트 한다

### 단일 인터셉터
- 서버에서 gRPC 서비스의 단일 RPC를 가로채려면 gRPC서버에 단일 인터셉터를 구현해야 한다
- UnaryServerInterceptor타입의 함수를 구현하고 gRPC서버를 생성할때 해당 함수를 등록해 이를 실행 할 수 있다

```
func (ctx context.Context, req interface{}, info *UnaryServerInfo, handler UnaryHandler) (resp interface{}, err error)
```

- 서버측 단일 인터셉터 구현은 일반적으로 전처리, RPC메서드 호출, 후처리의 세부분으로 나눌 수 있다
- 전처리 단계는 RPC호출에서 원래의 원격 메서드를 호출하기 전에 실행 된다
- 호출 단계에서 RPC메서드를 호출 하려면 gRPC UnaryHandler를 호출해야 하며, RPC가 호출된 이후 후처리 단계가 실행된다

### 스트리밍 인터셉터
- gRPC서버가 처리하는 모든 스트리밍 RPC호출을 인터셉트 한다
- 스트리밍 인터셉터는 전처리 단계와 스트림 동작 인터셉트 단계를 포함한다
- StreamServerInterceptor는 서버측 스트리밍 인터셉터의 타입이다

```
func (srv interface{}, ss ServerStream, info *StreamServerInfo, handler StreamHandler) error
```

- 단일 인터셉터처럼 전처리 단계에서 스트리밍 RPC호출이 서비스 구현으로 이동하기전에 인터셉트 할 수 있고, 전처리 단계 후에 원격 메서드의 RPC호출을 실행하고자 StreamHandler를 호출한다
- grpc.ServerStream 인터페이스를 구현하는 래퍼스트림이라는 인터페이스를 사용해 스트리밍 RPC 메시지를 가로챌 수 있다
- grpc.ServerStream 래퍼는 gRPC서비스에서 보내거나 받는 스트리밍 메시지를 가로챈다
- SendMsg와 RecvMsg 함수를 구현해 서비스가 RPC스트리밍 메시지를 받거나 보낼때 호출된다

## 클라이언트 측 인터셉터
- 클라이언트가 gRPC서비스의 원격 메서드를 호출하고자 RPC를 할 때 클라이언트에서 해당 RPC 호출을 가로챌 수 있다
- 클라이언트 측 인터셉터를 사용하면 스트리밍 RPC호출 뿐만 아니라 단일 RPC 호출도 인터셉트 할 수 있다

### 단일 인터셉터
- 클라이어트 측 단일 RPC 인터셉터는 단일 RPC 클라이언트를 인터셉터 하는데 사용하며 UnaryClientInterceptor는 다은과 같은 시그니처를 갇는다

```
func (ctx context.Context, method string, req, reply interface{}, cc *ClientConn, invoker UnaryInvoker, opts ...CallOption) error
```

- 전처리 단계에서 원격 메서드를 호출하기 전에 RPC호출을 가로챌 수 있다
- 서버 애플리케이션으로 전송되기 전에 원래 RPC호출을 수정하는 것도 가능하다

### 스트리밍 인터셉터
- 클라이언트 측 스트리밍 인터셉터는 gRPC클라이언트가 처리하는 모든 스트리밍 RPC 호출을 인터셉트하며, 구현은 서버측 구현과 매우 유사하다

```
func(ctx content.Context, desc *StreamDesc, cc *ClientConn, method string, streamer Streamer, opts ...CallOption) (ClientSteeam, error)
```

- 스트림에 대한 인터셉트는 grpc.ClientStream을 래핑하는 새로운 구조체를 구현하는 스트림의 래퍼 구현을 통해 처리된다
- RecvMsg와 SendMsg를 구현해야 하며, 인터셉트의 등록은 단일 인터셉터와 동일하며 grpc.Dial 함수에서 수행된다

## 데드라인
- 타임아웃은 클라이언트 애플리케이션이 RPC가 완료될 때 까지 에러와 함께 끝나기 전에 얼마나 기다리는지를 지정한다
- 일반적으로 타임아웃은 기간으로 지정되며 각 클라이언트에 개별로 적용된다
- 요청 전체 수명주기에는 직접 적용할 수가 없으므로, 이럴 때에는 데드라인을 사용해야 한다
- 데드라인은 요청 시작 시간을 기준으로 특정 시간으로 표현되며, 여러 서비스 호출에 걸쳐 적용된다
- 요청을 시작하는 애플리케이션이 데드라인을 설정하면 전체 요청은 데드라인까지 응답해야 한다
- 여러가지 이유로 항상 gRPC 애플리케이션에서 데드라인을 지정하는것이 바람직 하다
- 데드라인을 사용하지 않고 클라이언트 애플리케이션을 개발하면 시작된 RPC요청에 대한 응답을 무한정 기다리며, 모든 진행 중인 요청에 대해 리소스가 계속 유지된다
- 데드라인 내에 RPC호출이 응답하지 않으면 DEADLINE_EXCEEDED에러와 함께 RPC호출이 종료된다
- 데드라인의 이상적인 값은 엔드 투 엔드 지연시간, RPC의 직렬화 여부, 병렬 호출 여부, 기본 네트워크의 지연시간과 다운스트림 서비스의 데드라인 값등을 고려해야 한다
- 클라이언트와 서버 모두 RPC의 성공 여부에 대해 독립적이고 개별적인 결정을 내릴수 있는데, 클라이언트가 DEADLINE_EXCEEDED 상태가 되더라도, 서비스는 여전히 응답 시도를 할 수 있다
- 서버에서 클라이언트가 RPC를 호출 할 때 지정된 데드라인이 초과됬는지 감지 할 수도 있다

## 취소 처리
- 클라이언트와 서버 애플리케이션 사이의 gRPC연결에서 클라이언트와 서버는 모두 통신 성공 여부를 독립적이고 개별적으로 결정한다
- 클라이언트나 서버 애플리케이션은 RPC를 중단시키려고 할 때 RPC를 취소 하면 된다
- RPC가 취소되면 더이상 RPC관련 메시징을 처리할 수 없고 당사자가 RPC를 취소 했다는 사실이 상대방에게 전파된다

## 에러 처리
- 클라이언트 애플리케이션은 발생 가능한 모든 에러와 에러 상태를 처리하는 방식으로 작성해야 한다
- 서버 애플리케이션도 에러를 처리하고 해당 상태 코드로 적절한 에러를 생성해야 한다
- gRPC는 에러 상태의 자세한 정보를 제공하는 선택적 에러 메시지와 함께 에러 상태 코드를 반환한다
- 대표적인 상태 코드는 다음과 같다
    - OK: 성공적인 상태로 에러가 없다
    - CANCELLED: 처리가 취소됨
    - DEADLINE_EXCEEDE: 처리가 완료되기전에 데드라인이 만료
    - INVALID_ARGUMENT: 클라이언트가 유효하지 않은 인자를 지정
- gRPC와 함꼐 제공되는 에러 모델은 기본적으로 gRPC 데이터 형식과 무관하며 매우 제한적이기 때문에, 프로토콜 버퍼를 데이터 형식으로 사용하는 경우 google.rpc 패키지의 Google API가 제공하는 더 풍부한 에러 모델을 활용 할 수 있다

## 멀티플렉싱
- gRPC를 사용하면 동일한 gRPC서버에서 여러 gPRC서비스를 실행 할 수 있고, 여러 gRPC 클라이언트 스텁에 동일한 gRPC연결을 사용 할 수 있다. 이를 멀티플렉싱이라고 한다
- 하나의 gRPC서버에서 주문 관리 목적에 필요한 다른 서비스를 실행해 클라이언트 애플리케이션이 동일한 연결을 재사용 해서 두 서비스를 모두 호출 할 수 있다고 가정하자. 이 경우 각각의 서버 등록 기능을 통해 두 서비스를 동일한 gRPC서버에 등록할 수 있다
- 두 gRPC서비스가 하나의 gRPC 서버에서 실행중이면 하나의 gRPC연결만 만들어 다른 서비스에 대한 gRPC 클라이언트 인스턴스를 만들때에 함께 사용 할 수 있다
- 마이크로 서비스와 같은 일반적인 사례에서는 두 서비스간에 동일한 gRPC서버 인스턴스를 공유하지 않는다

## 메타데이터
- 대부분의 경우 서비스의 비즈니스 로직 및 소비자와의 직접 관련된 정보는 원격 메서드 호출인자의 일부이다
- 특정 조건에서 RPC의 비즈니스 콘텍스트와 관련이 없는 RPC 호출 정보를 공유할 수 있는데, 이는 RPC인자의 일부가 돼서는 안된다
- 이런 경우 gRPC서비스나 gRPC클라이언트에서 보내거나 받을 수 있는 gRPC 메타데이터를 사용할 수 있다
- 메타데이터의 가장 일반적인 사용은 gRPC 애플리케이션의 gRPC 애플리케이션간에 보안 헤더를 교환하는것이다
- 마찬가지로 gRPC 애플리케이션 사이에 임의의 정보를 교환하는데 사용 할 수 있고, gRPC 메타데이터 API는 개발되는 인터셉터 내부에서 많이 쓰인다

## 메타데이터 생성과 조회
- 메타데이터는 Go 에서 일반 맵으로 표현되며, metadata.New 형식으로 만들거나, 동일한 키를 가진 메타데이터를 목록으로 합치기 위해 metadata.Pairs를 사용해 메타데이터를 만들 수 있다
- 클라이언트나 서버에서 메타데이터를 읽으려면 metadata.FromIncomingContext(ctx)와 함께 RPC 호출의 수신 콘텍스트를 사용해 수행할 수 있다

## 메타데이터 전송과 수신: 클라이언트측
- 메타데이터를 생성하고 RPC 호출 콘텍스트에 지정함으로써 클라이언트에 gRPC 서비스로 메타데이터를 보낼 수 있다
- NewOutgoingContext를 사용해 새 콘텍스트를 생성하면서 새 메타데이터를 생성하거나, AppendToOutgoingContext를 사용해 기존 메타데이터에 추가 할 수 있다
- NewOutgoingContext를 사용하면 기존의 메타데이터가 대체되므로 주의해야 한다

## 메타데이터 전송과 수신: 서버측
- metadata.FromIncomingContext(ctx)를 사용해 메타데이터를 간단히 얻을 수 있다
- 서버에서 메타데이터를 보내려면 메타데이터가 있는 헤더를 보내거나 메타데이터가 있는 트레일러를 지정한다
- 단일 및 스트리밍 모두에서 grpc.SendHeader 메서드를 사용해 메타데이터를 보낼 수 있다
- 트레일러의 일부로 메타데이터를 보내려면 해당 스트림의 grpc.SetTrailer나 SetTrailer 메서드를 사용해 콘텍스트의 트레일러 일부로 메타데이터를 설정해야 한다

## 네임 리졸버
- 네임 리졸버는 서비스 이름에 대한 백엔드 IP의 목록을 반환한다
- 로드밸런싱을 할때 네임 리졸버가 쓰인다

## 로드밸런싱
- gRPC 애플리케이션을 개발 할때는 애플리케이션이 고가용성과 확정성 요구를 충족시킬수 있게 해야 한다
- 서비스들 사이에 RPC 호출을 분산시키려면 일부 엔티티에서 처리해야 하는데 이것이 로드밸런싱의 역할이다
- gRPC에는 일반적으로 로드밸런서 프록시와 클라이언트측 로드밸런싱이라는 2가지 주요 로드밸런싱매커니즘이 사용된다

### 로드밸런서 프록시
- 클라이언트가 로드밸런스 프록시에 RPC를 요청하고, 로드밸런서 프록시는 호출을 처리하는 실제 로직을 구현한 사용 가능한 백엔드 gRPC서버중 하나에게 RPC 호출을 분배한다
- 로드밸런서 프록시는 각 백엔드 서버의 로드를 추적하고, 백엔드 서비스간에 로드를 분배하기 위한 다양한 로드밸런싱 알고리즘을 제공한다
- 백엔드 서비스의 포톨로지는 gRPC 클라이언트에 공개되지 않으며, 클라이언트는 로드밸런서의 엔드포인트만 알고있다
- 백엔드 서비스는 로드 상태를 로드 밸런서에 다시 알릴 수 있다
- 이론적으로는 gRPC애플리케이션이 로드밸런서 프록시로 HTTP/2를 지원하는 모든 로드밸런서를 선택할 수 있지만, 온전히 HTTP/2를 지원해야 하므로 Nginx나, Emvoy Proxy같은 로드밸런싱 솔루션을 쓰는게 좋다

## 클라이언트 측 로드밸런싱
- gRPC 클라이언트 래벨에서 로드밸런싱 로직을 구현할 수 있는데, 클라이언트는 여러 백엔드 gRPC 서버를 인식하고 각 RPC에 사용할 하나의 서버를 선택한다
- 로드밸런싱 로직은 클라이언트 애플리케이션의 일부로 개발되거나, 룩어사이드 로드밸런서라고 하는 전용 서버에서 구현 될 수 있다
- 클라이언트는 연결할 최상의 gRPC 서버를 얻고자 질의 할 수 있고, 클라이언트는 룩어사이드 로드밸런서에서 얻은 gRPC서버 주소에 직접 연결한다

## 압축
- 네트워크 대역폭을 효율적으로 사용하기 위해 클라이언트와 서비스 사이에서 RPC가 실행 될 때 압축을 사용할 수 있다. 클라이언트에서 gRPC 압축 사용은 RPC를 수행할 때 압축기를 설정해 구현한다
- 서버에서는 등록된 압축기가 자동으로 요청 메시지를 디코딩하고 응답을 인코딩 한다
- 서버는 항상 클라이언트가 지정한것과 동일한 압축 방법을 사용해 응답하는데, 해당 압축기가 등록되지 않은 경우 Unimplemented 상태가 클라이언트에 반환된다