---
title: "Kotlin Study - 04 클래스, 객체, 인터페이스 -1 "
date: 2019-08-01 21:47:00 
categories: kotlin study
---

# 클래스, 객체, 인터페이스

## 클래스 계층의 정의

### 인터페이스
~~~
interface Clickable {
  fun click()
  fun showOff() = println("Clicked")
}

interface Focusable {
  fun setFocus(b: Boolean) =
    println("Focus")
  fun showOff() = println("Focused")
}

class Button: Clickable, Focusable {
  override fun click() = println("Click")
  override showOff() {
    super<Clickable>.showOff()
    super<Focusable>.showOff()
  }
}
~~~
* 코틀린의 인터페이스는 java 8의 인터페이스와 비슷하다
* 하지만 추상 메소드 뿐만 아니라 구현이 있는 메소드도 정의 할 수 있으며, 아무런 상태(필드)도 들어갈 수 없다
* java에서는 extends 와 implements 키워드로 상속과 구현을 구분 하지만 코틀린에서는 : 하나로 모두 처리 한다
* java와 동일 하게 인터페이스는 원하는 만큼 구현 할 수 있지만, 상속은 하나만 가능하다
* java의 @Override와 동일한 override 변경자가 있다. 하지만 java와 달리 무조건 사용해야 한다.
* super를 통해 상위 타입을 지정 할 때, super<상위타입> 처럼 꺽쇠 안에 기반 타입을 지정한다

### open, final, abstract 변경자: 기본적으로 final
* 코틀린의 클래스와 메소드는 기본적으로 final 이다 
* 어떤 클래스의 상속을 허용 하려면 클래스 앞에 open 변경자를 붙여야 하며, 이는 메소드와 프로퍼티 모두 동일 하다
  ~~~
  open class RichButto: Clickable {
    fun disable() {}  <- fianl, override 할 수 없다
    open fun animate() {} <- override 할 수 있다
    override fun click() {} <- 상위 클래스에서 선언된 메서드를 오버라이드 했다. 이 경우 기본 open 이다
  }
  ~~~
  - 만약 상속받은 메서드나 프로퍼티를 override 하지 못하게 막고싶은 경우 final을 명시 하면 된다
* java와 동일하게 abstract 클래스를 만들 수 있으며, 추상클래스는 인스턴스화 할 수 없다
* 추상 클래스의 추상 멤버는 하위 클래스에서 항상 오버라이드 해야 하므로, 기본으로 open이며, 이는 명시 할 필요 없다

### 가시성 변경자: 기본적으로 공개
* java와 비슷하게 public, private, protected가 있다. package는 존재하지 않는다
* 코틀린에서 아무것도 선언하지 않으면 public이다. 코틀린의 package는 namespace 관리용으로만 쓰인다
* 코틀린에서는 internal 가시성 변경자가 존재하며, 이는 모듈단위 즉 한꺼번에 컴파일 되는 코틀린 파일들에서만 볼 수 있다
* 코틀린에서는 최상위 선언에 대해 private를 허용 한다.이는 같은 파일 내부에서만 쓸 수 있다.
~~~
internal open class TalktiveButton: Focusable {
  private fun yell() = println("Hey!")
  protected fun whisper() = println("Let's talk")
}

fun TalktiveButton.giveSpeech() { <- 생략했으니 public인 멤버가 TalktiveButton을 노출한다. 오류
  yell() <- yell은 상위클래스의 private라 접근 할 수없다. 오류
  whisper() <- whisper는 상위 클래스의 protected라 접근 할 수 없다. 오류
}
~~~

### 내부 클래스와 중첩된 클래스: 기본적으로 중첩 클래스
