---
layout: post
title: "Effective Kotlin - 아이템26: 함수 내부의 추상화 레벨을 통일하라"
description: 함수 내부의 추상화 레벨을 통일하라
date: 2022-02-25 22:55:00 +09:00
categories: EffectiveKotlin Study
---


# 추상화 설계

## 아이템 26 : 함수 내부의 추상화 레벨을 통일하라
- 계층이 잘 분리되어있다면 어떤 계층에서 작업을 할 때 그 아래의 계층은 이미 완성되어 있으므로 해당 계층만 이해하면 됨. 즉 전체를 이해할 필요가 ㅇ벗어짐

### 추상화 레벨
- 높은 추상화 레벨 일수록 단순함을 얻지만, 제어력을 잃음

### 추상화 레벨 통일
- 함수도 레벨을 구분해서 사용해야 한다는 추상화 레벨 통일의 원칙(Single Level of Abstraction, SLA)이 있음
- 커피머신을 나타내는 다음과 같은 클래스가 있다고 가정

```kotlin
class CoffeeMachine {
    fun makeCoffee() {
        // 수백개의 변수 선언
        // 복잡한 로직을 처리
        // 낮은 수준의 최적화 진행
    }
}
```

- 이렇게 코드가 작성되면 makeCoffee라는 함수가 수백줄이 될 수도 있는데, 그러면 읽고 이해하는것이 불가능해짐

```kotlin
class CoffeeMachine {
    fun makeCoffee() {
        boilWater()
        brewCoffee()
        pourCoffee()
        pourMilk()
    }

    private fun boilWater() {
        // ...
    }

    private fun brewCoffee() {
        // ...
    }

    private fun pourCoffee() {
        // ...
    }

    private fun pourMilk() {
        // ...
    }
}
```

- 위와 같이 함수를 계층처럼 나눠서 활용 해야 함. 이러면 이 함수가 어떤식으로 동작하는지 확실하게 확인 할 수 있음
- 함수는 이처럼 간단해야 함. 이는 '함수는 작아야 하며, 최소한의 책임만을 가져야 한다' 라는 일반적인 규칙임
- 어떤 함수가 다른 함수보다 좀 복잡하다면, 일부 부분을 추출해서 추상화 하는것이 좋음
- 함수가 추출된다면 재사용과 테스트도 쉬워짐

### 프로그램 아키텍처의 추상 레벨
- 추상화 계층이라는 개념은 함수보다 높은 레벨에서도 적용 할 수 있음
- 추상화를 구분하는 이유는 서브 시스템의 세부 사항을 숨김으로써 상호 운영성과 플랫폼 독립성을 얻기 위함임
- 모듈 시스템을 설계할때도 중요한데, 모듈을 분리하면 계층 고유의 요소를 숨길 수 있고, 이렇게 계층화가 잘 된 프로젝트는 어떤 계층 위치에서 코드를 보아도 일관적인 관점을 얻을 수 있음
