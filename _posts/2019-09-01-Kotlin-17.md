---
title: "Kotlin Study - 09 제너릭스 -2"
date: 2019-09-01 12:57:00 
categories: kotlin study
---

# 제너릭스

## 변성: 제너릭과 하위 타입

### 변성이 있는 이유: 인자를 함수에 넘기기
* List<Any> 타입의 파라미터를 받는 함수에 List<String>을 넘기면  안전하지 않다
* 어떤 함수가 List의 원소를 추가하거나 변경하면 타입 불일치가 생길 수 있기 때문이다( 그 이외엔 안전 하다고 볼 수 있다 )
* 이러한 문제를 막기 위해 코틀린 에서는 리스트의 변경 가능성에 따라 적절한 인터페이스를 선택하면 안전하지 못한 호출을 막을 수 있다

### 클래스, 타입, 하위타입
* 제너릭 클래스가 아닌 클래스들은 클래스 이름을 타입으로 바로 쓸 수 있다(널이 될 수 있는 타입을 포함해, 클래스가 2개 이상의 타입을 구성할수있다)
* 제너릭 클래스에서는 조금 복잡해진다. 각기 제너릭 타입은 무수히 많은 타입을 만들 수 있지만,
올바른 타입을 얻으려면 제너릭 타입의 타입 파라미터를 구체적인 타입 인자로 바꿔야 하기 때문이다
* 타입 사이의 관계를 논하기 위해서 하위 타입이라는 개념을 알아야 한다. 어떤 타입 A의 값이 필요한 장소에 B를 넣어도 아무 문제가 없다면 B는 A의 하위이다
* 하위타입이 중요한 이유는 컴파일러가 변수 대입이나 함수 인자 전달 시 하위 타입 검사를 매번 수행하기 때문이다
* 간단한 경우 하위 타입은 하위 클래스와 근본적으로 같지만, 널이 될 수 있는 타입은 아니다(Int를 받는곳에 Int?을 넘길 수 없다!)
* 제너릭 타입을 인스턴스화 할때 타입 인자로 서로 다른 타입이 들어가면 인스턴스 타입 사이의 하위 타입 관계가 성립하지 않을 수 있다
* 이떄 그 제너릭 타입을 서로 무공변 이라고 하고, 그 반대 경우를 공변적 이라고 말한다

### 공변성: 하위 타입 관계를 유지

~~~
open class Animal {
  fun feed() {...}
}

class Cat : Animal() {
  fun cleanLitter() {...}
}

class Herd<out T: Animal> {
  val size: Int get() = ...
  operator fun get(i : Int) :T {...}
}

fun feedAll(animals: Herd<Animal>) {
  for(i in 0 until animals.size) {
    animals[i].feed()
  }
}

fun takeCareOfCats(cats: Herd<Cat>) {
  for(i in 0 until cats.size) {
    cats[i].cleanLitter()
  }
  feedAll(cats)
}
~~~

* 코틀린에서 제너릭 클래스가 타입 파라미터에 대해 공변적임을 표시 하려면 타입 파라미터 이름 앞에 out 이라고 명시 해야 한다
* 클래스의 타입 파라미터를 공변적으로 만들면 함수 정의에 사용한 파라미터 타입과 타입 인자의 타입이 정확히 일치 하지 않아도,
그 클래스의 인스턴스를 함수 인자나 반환 값으로 사용 할 수 있다
* Herd의 타입 파라미터를 공변성으로 지정 하였기 때문에, feedAll에 Cats를 넘겨도 아무런 문제가 없으며, 캐스팅을 할 필요도 없다
* 하지만 타입 파라미터를 공변적으로 지정하면 클래스 내부에서 그 파라미터를 사용하는 방법이 제한 된다
* 타입의 안정성을 보장하기 위해 공변적 파라미터는 항상 out 위치에 있으며, 이는 클래스가 T타입의 값을 생산 할 수 있지만, 소비 할수 없다는뜻이다
  - 함수 파라미터 타입은 in 위치, 반환 타입은 out 위치 이다
  - fun tasnform(t : T) : T 에서 (t: T) 에 있는 T는 in 위치, : T 에 있는 T는 out 위치 이다
* 즉 타입 파라미터에 붙은 out은 공변성(하위 타입 관계 유지)와 사용제한( T를 아웃 위치에서만 사용 할 수 있다) 를 의미 한다
* 코틀린의 List는 읽기 전용임을 생각 하면, List<T>는 T타입의 원소를 반환하는 get은 있지만, T타입을 추가하거나 변경하는 메소드는 없다는걸 알수있다
* 즉, List는 T에 대해서 공변적인 것이다
* 역으로 말해 MutableList<T>는 T에대해서 공변적으로 선언할 수 없음을 알 수 있다
* 생성자 파라미터는 인이나 아웃 그 어느쪽도 아니기 때문에, 타입 파라미터가 out이여도 그 타입을 생성자 파라미터 선언 안에 사용 할 수 있다
* 생성자는 나중에 호출 할 수 있는 메서드가 아니기 때문에 생성자는 위험 할 여지가 없기 때문이다
* 이러한 변성의 특징을 이용해 위험할 여지가 있는 메소드를 호출 할 수 없게 만듦으로써 잘못 사용하는 일이 없게 방지 할 수 있다
* 하지만 val 이나 var를 생성자 파라미터 안에 적는다면 getter/setter를 정의 하는것과 마찬가지 이므로 out에 제한이 생길 수 있다
* 또한 이러한 위치 규칙은 public, protected, internal 에서만 적용 되며 private 메소드에는 적용 되지 않는다

