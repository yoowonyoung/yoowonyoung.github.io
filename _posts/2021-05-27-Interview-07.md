---
layout: post
title: "리트코드 Medium 문제풀이"
description: 리트코드 문제풀이
date: 2021-05-27 22:46:00 +09:00
categories: Interview
---

# Basic - 기출 문제

1. Basic Calculator 2

    - 계산기 구현 문제

```java
    public static int calculate(String s) {
        s = s.replaceAll(" ","");

        if(s.contains("*") || s.contains("/")) {
            StringBuilder newS = new StringBuilder();
            for(int i = 0; i < s.length(); i++) {
                if(s.charAt(i) == '*' || s.charAt(i) == '/') {
                    String newString = newS.toString();
                    String left;
                    if(newString.lastIndexOf("+") > newString.lastIndexOf("-")) {
                        left = newString.substring(newString.lastIndexOf("+") + 1);
                        newS.delete(newString.lastIndexOf("+") + 1,newS.length());
                    } else {
                        left = newString.substring(newString.lastIndexOf("-") + 1);
                        newS.delete(newString.lastIndexOf("-") + 1,newS.length());
                    }

                    StringBuilder rightBuilder = new StringBuilder();
                    int cur = i+1;
                    while (cur < s.length() && (s.charAt(cur) != '*' && s.charAt(cur) != '-' && s.charAt(cur) != '+' && s.charAt(cur) != '/')) {
                        rightBuilder.append(s.charAt(cur++));
                    }
                    String right = rightBuilder.toString();

                    if(!right.equals("")) {
                        String calculated;
                        if(s.charAt(i) == '*') {
                            calculated = String.valueOf(Integer.parseInt(left) * Integer.parseInt(right));
                        } else {
                            calculated = String.valueOf(Integer.parseInt(left) / Integer.parseInt(right));
                        }
                        newS.append(calculated);
                    } else {
                        newS.append(left);
                    }

                    i = cur-1;
                } else {
                    newS.append(s.charAt(i));
                }
            }

            s = newS.toString();
        }

        StringBuilder left = new StringBuilder();
        StringBuilder right = new StringBuilder();
        char lastOperator = ' ';
        boolean isLeft = true;
        for(int i = 0; i < s.length(); i++) {
            if(s.charAt(i) != '+' && s.charAt(i) != '-') {
                if(isLeft) left.append(s.charAt(i));
                else right.append(s.charAt(i));
            } else {
                if(isLeft) {
                    isLeft = false;
                } else {
                    int leftValue = Integer.parseInt(left.toString());
                    int rightValue = Integer.parseInt(right.toString());

                    int calculated;
                    if(lastOperator == '+') {
                        calculated = leftValue + rightValue;
                    } else {
                        calculated = leftValue - rightValue;
                    }

                    left = new StringBuilder(String.valueOf(calculated));
                    right = new StringBuilder();
                }
                lastOperator = s.charAt(i);
            }
        }

        if(lastOperator != ' ') {
            if(lastOperator == '+') {
                return Integer.parseInt(left.toString()) + Integer.parseInt(right.toString());
            } else {
                return Integer.parseInt(left.toString()) - Integer.parseInt(right.toString());
            }
        } else {
            return Integer.valueOf(s);
        }

    }
```

2. Merge Intervals
    - Sorting & Searching 6번

3. Sliding Window Maximum
    - DP
    - 그냥하면 타임아웃남
    - 배열에서 주어진 k 개씩 원소를 가지는 블록으로 나눔(맨 마지막은 k개가 안될 수도 있음)
    - 배열 2개를 선언(left, right)
    - left는 해당 블록내에서 왼쪽 -> 오른쪽으로 가면서 최대값을 기록(블록 지날때마다 리셋)
    - right는 해당 블록 내에서 오른쪽 -> 왼쪽으로 가면서 최대값을 기록
    - 만약 윈도우의 범위가 i~j 라면 Max(right[i],left[j])하면 해당 윈도우에서 최대값이 나옴 

```java
public int[] maxSlidingWindow(int[] nums, int k) {
    int n = nums.length;
    if (n * k == 0) return new int[0];
    if (k == 1) return nums;

    int [] left = new int[n];
    left[0] = nums[0];
    int [] right = new int[n];
    right[n - 1] = nums[n - 1];
    for (int i = 1; i < n; i++) {
        // from left to right
        if (i % k == 0) left[i] = nums[i];  // block_start
        else left[i] = Math.max(left[i - 1], nums[i]);

        // from right to left
        int j = n - i - 1;
        if ((j + 1) % k == 0) right[j] = nums[j];  // block_end
        else right[j] = Math.max(right[j + 1], nums[j]);
    }

    int [] output = new int[n - k + 1];
    for (int i = 0; i < n - k + 1; i++)
        output[i] = Math.max(left[i + k - 1], right[i]);

    return output;
}
```

4. Find First and Last Position of Element in Sorted Array
    - Sorting and Search 5번

5. Meeting Rooms II
    - Sorting and Search 8번

6. Word Break
    - DFS
    - 해당 위치에서 조금씩 크기를 키워 나가며(end = start +1, end ++) substring 했을때 그 substring이 주어진 worddict에 있나 보고, 있으면 일단 해당 start 지점에서는 만들어질수 있는거니 end를 queue에 집어넣고, visit[start] = true
    - 그 다음에 큐에서 하나씩 꺼내가면서(그 위치로 이동해서) 반복

    ```java
    public boolean wordBreak(String s, List<String> wordDict) {
        Set<String> wordSet = new HashSet<>(wordDict);
        Queue<Integer> queue = new LinkedList<>();
        boolean visited[] = new boolean[s.length()];
        Arrays.fill(visited,false);

        queue.add(0);
        while (!queue.isEmpty()) {
            int start = queue.remove();
            if(visited[start]) continue;

            for(int end = start + 1; end <= s.length(); end++) {
                if(wordSet.contains(s.substring(start,end))) {
                    queue.add(end);
                    if(end == s.length()) return true;
                }
            }

            visited[start] = true;
        }
        return false; 
    }
    ```

7. Daily Temperatures
    - DP
    - 일단 답의 맨 마지막은 항상 0임 (자기 이후 더 나올 날짜가 없으므로)
    - 맨 마지막에서 하루 전날 부터 시작. 하루씩 더 더 시작일에 가까워 지면서 반복
    - 일단 자신의 기본 카운트값은 1(다음날을 보고 있으므로)
    - 이제 자기 이후의 날짜들을 체크(i + count), 체크 조건은 범위를 벗어나지 않으며 자기보다 온도가 낮은 날짜들 
    - 만약 이동한 그 날짜(다음날~ )의 카운트값이 0이면 = 맨 마지막 날짜, 혹은 그 이후로 더 온도가 높은날이 없다는 소리니 자신 카운트 0 만들고 반복 종료
    - 그게 아니라면 카운트에 해당 날짜의 카운트값을 더해줌(그 날짜만큼 이동)
    - 그렇게 몇칸씩 가다보면 자기보다 큰 숫자를 만나서 종료되거나(반복 조건 종료), 자기보다 작은데 0인 숫자를 발견해서(이 이후 더 높은날짜가 없다)해서 종료
    - 그렇게 해서 만들어진 해당 날짜의 카운트값을 입력

    ```java
    public int[] dailyTemperatures(int[] temperatures) {
        int[] predictions = new int[temperatures.length];
        predictions[predictions.length - 1] = 0;
        for (int i = predictions.length - 2; i >= 0; --i) {
            int count = 1;
            while (i + count < predictions.length && temperatures[i] >= temperatures[i + count]) {
                if (predictions[i + count] == 0) {
                    count = 0;
                    break;
                }
                count += predictions[i + count];
            }
            predictions[i] = count;
        }
        return predictions;
    }
    ```

# Basic - 정렬 알고리즘

1. 시간 복잡도 비교
    - 선택 정렬: O(n^2)
    - 버블 정렬: O(n^2)
    - 삽입 정렬: O(n^2)
    - 합병 정렬: O(nlogn)
    - 퀵 정렬: O(nlogn)
    - 힙 정렬: O(nlogn)

2. 공간 복잡도 비교
    - 선택 정렬: O(n^2)
    - 버블 정렬: O(n)
    - 삽입 정렬: O(n^2)
    - 합병 정렬: O(nlogn)
    - 퀵 정렬: O(nlogn)
    - 힙 정렬: O(nlogn)

```java
class Sort {
    
    
    /**
     * 선택 정렬(Selection Sort)은 
     * 전체 원소들 중에서 기준위치에 맞는 원소를 선택하여 자리를 교환하는 방식으로 정렬 
     * 
     * @param a
     */
    public void selectionSort(int a[]) {
        
        for(int i=0; i<a.length-1; i++) {
            int min = i;
            for(int j=i+1; j<a.length; j++) { 
                if(a[j] < a[min]) { //오름차순 
                    min = j;
                }
            }
            swap(a, min, i); 
            System.out.printf("\n선택 정렬 %d 단계 : ", i+1);
            for(int v : a) {
                System.out.printf("%3d ", v);
            }
            //System.out.println(Arrays.toString(a));            
        }
        System.out.println();
    }
    
    /**
     * 버블 정렬(Bubble Sort)은 인접한 두개의 원소를 비교하여 자리를 교환하는 방식으로 정렬
     * 첫번째 원소부터 인접한 원소끼리 계속 자리를 교환하면서 맨 마지막자리로 이동하는 모습이
     * 물속에서 물 위로 올라오는 물방울 모양과 같다고 해서 버블 정렬이라고 한다.
     */
    public void bubbleSort(int a[]) {
        int size = a.length;
        for(int i=size-1; i>0; i--) {
            System.out.printf("\n버블 정렬 %d 단계 : ", size-i);
            for(int j=0; j<i; j++) {
                if(a[j] > a[j+1]) {
                    swap(a,j,j+1);
                }
                System.out.printf("\n\t");
                for(int v : a) {
                    System.out.printf("%3d ", v);
                }
            }            
        }
        System.out.println();
    }
    
    /**
     * 삽입 정렬(Insert Sort)은 정렬되어 있는 부분집합에 새로운 원소의 위치를 찾아 삽입하는 정렬방식
     *                          S(Sorted)와 U(Unsorted) 
     * @param a
     */
    public void insortionSort(int a[]) {
        int size = a.length;        
        for(int i=1; i<size; i++) {
            int temp = a[i];
            int j = i;
            while((j>0) && (a[j-1]>temp)) {
                a[j] = a[j-1];
                j--;
            }
            
            a[j] = temp;
            System.out.printf("\n삽입정렬 %d 단계 : ",i);
            for(int v : a) {
                System.out.printf("%3d ", v);
            }            
        }
        System.out.println();
    }
    
    public  void swap(int a[], int idx1, int idx2) {
        int temp = a[idx1];
        a[idx1] = a[idx2];
        a[idx2] = temp;
    }    
    
    /**
    * 퀵정렬
    */
    public static int partition(int arr[], int left, int right) {

        int pivot = arr[(left + right) / 2];

        while (left < right) {
            while ((arr[left] < pivot) && (left < right))
                left++;
            while ((arr[right] > pivot) && (left < right))
                right--;

            if (left < right) {
                int temp = arr[left];
                arr[left] = arr[right];
                arr[right] = temp;
            }
        }

        return left;
    }

    public static void quickSort(int arr[], int left, int right) {

        if (left < right) {
            int pivotNewIndex = partition(arr, left, right);

            quickSort(arr, left, pivotNewIndex - 1);
            quickSort(arr, pivotNewIndex + 1, right);
        }

    }

}
```


# Array & String

1. 3 Sum
    - 원문: Given an integer array nums, return all the triplets [nums[i], nums[j], nums[k]] such that i != j, i != k and j != k, and nums[i] + nums[j] + nums[k] == 0. Notice that the solution set must not contain duplicate triplets.
    - 해석: 주어진 배열 내에서 서로다른 수 i,j,k가 있을때 num[i] + num[j] + num[k] == 0 인 i,j,k가 존재하는지
    - 접근법
        * 일단 더해서 0이 나와야 하기에 0 이하의 수가 필요함(양수끼리는 더해선 0이 나올수 없으니깐)
        * 배열을 오름차순으로 정렬하고, 0이하의 수를 하나 선택한다음에 나머지 2개의 수를 찾아서 맨처음 선택된수가 나오는지 확인
        * 0 이하의 수를 선택한 이후엔, 그 lo (그 다음으로 작은수)와 hi(제일 큰수)를 골라서 더해본다음에 0이하가 나오면 그 lo의 위치를 한칸 오른쪽으로 이동(++), 0 이상이 나오면 맨 hi를 하나 왼쪽(--)으로 이동하면서 0이 되는지 체크
        * 만약 0이 나온다면 해당 답안을 기록하고, 중복을 제거하기 위해서 그 lo가 같은경우를 스킵
        * lo < hi 인 동안 반복
    - 시간복잡도: O(n)짜리인 twoSum이 n번 불려서 O(n^2)
    - 공간복잡도: O(n)
    - 코드

    ```java
    public List<List<Integer>> threeSum(int[] nums) {
        List<List<Integer>> ans = new ArrayList<>();
        Arrays.sort(nums);
        for(int i = 0; i < nums.length && nums[i] <= 0; i++) {
            if(i == 0 || nums[i-1] != nums[i]) {
                twoSum(nums,i,ans);
            }
        }
        return ans;
    }

    public void twoSum(int nums[], int i, List<List<Integer>> ans) {
        int lo = i + 1;
        int hi = nums.length -1;
        while (lo < hi) {
            int sum = nums[i] + nums[lo] + nums[hi];
            if(sum < 0) {
                lo++;
            } else if(sum > 0) {
                hi--;
            } else {
                ans.add(Arrays.asList(nums[i],nums[lo++],nums[hi--]));
                while (lo < hi && nums[lo] == nums[lo-1]) lo++;
            }
        }
    }
    ```

2. Set Matrix Zeroes
    - 원문: Given an m x n matrix. If an element is 0, set its entire row and column to 0. Do it in-place.
    - 해석: 주어진 행렬에서 0 있는 행과 열을 모두 0으로 바꿔서 출력. 주어진 메모리 내에서 할것
    - 접근법
        * 주어진 메모리 공간 코드는 잘 이해가 안감
        * 그래서 결국 고전적인 DFS를 하기로 했음
        * DFS하면서 한 방향으로 쭉 갈수있도록 방향도 추가 하였고, 갓던데 또 안가도록 visit도 체크 했음
        * 실제론 더 가야하지만 visit체크때문에 못가는 경우도 발생 할 수 있어서, visit체크에 걸리더라도 한번 그 방향으로 쭉 끝까지 가보도록 했음
    
    - 코드

    ```java
    int dx[] = {0, 0, 1, -1};
    int dy[] = {1,-1,0,0};
    
    public void setZeroes(int[][] matrix) {
        int h = matrix.length;
        int w = matrix[0].length;
        boolean visit[][] = new boolean[h][w];
        for(int i = 0; i < h; i++) {
            for(int j = 0; j < w; j++) {
                visit[i][j] = false;
            }
        }

        for(int i = 0; i < h; i++) {
            for(int j = 0; j < w; j++) {
                if(!visit[i][j] && matrix[i][j] == 0) {
                    visit[i][j] = true;
                    for(int k = 0; k < 4; k++) {
                        dfs(matrix,visit,i,j,h,w,k);
                    }
                }
            }
        }
    }
    
    public void dfs(int[][] matrix, boolean visit[][], int x, int y, int h, int w, int dir) {
        int tx = x + dx[dir];
        int ty = y + dy[dir];
        if(tx >= 0 && ty >= 0 && tx < h && ty < w) {
            if(!visit[tx][ty] && matrix[tx][ty] != 0) {
                matrix[tx][ty] = 0;
                visit[tx][ty] = true;
                dfs(matrix,visit,tx,ty,h,w,dir);
            } else {
                while(tx >= 0 && ty >= 0 && tx < h && ty < w) {
                    if(!visit[tx][ty] && matrix[tx][ty] != 0) {
                        matrix[tx][ty] = 0;
                        visit[tx][ty] = true;
                        dfs(matrix,visit,tx,ty,h,w,dir);
                    } else {
                        tx = tx + dx[dir];
                        ty = ty + dy[dir];
                    }
                }
            }
        }
    }
    ```
    
3. Group Anagrams
    - 원문: Given an array of strings strs, group the anagrams together. You can return the answer in any order.
    - 해석: 주어진 문자열 배열에서, 애너그램인것끼리 묶어서 출력하시오
    - 접근법
        * 애너그램은 결국 같은 문자가 같은 수만큼있으면 애너그램인것을 이용
        * 해당 문자열 내에서 같은 문자가 몇번 나왔는지 숫자를 세서 그걸 Hash Key로 갖는 HashMap에 할당
        * Hash Map의 Value를 ```List<String>```으로 두어서 같은 Key를 같은 경우엔 Value에 add하도록
        * 코너케이스로 같은 문자가 10번이상 나오면 문제가 발생할수 있어서 #을 문자 갯수 사이사이마다 넣어서 문제 해결(ex> a10번 = a1번 b0번)
    - 시간복잡도: O(N K) - N: 문자열 갯수, K: 제일 긴 문자열 길이
    - 공간복잡도: O(N K) - N: 문자열 갯수, K: 제일 긴 문자열 길이
    - 코드

    ```java
    public List<List<String>> groupAnagrams(String[] strs) {
        List<List<String>> ans = new ArrayList<>();

        int cnt[] = new int[26];
        Map<String,List<String>> map = new HashMap<>();

        for(String s : strs) {
            Arrays.fill(cnt,0);
            int length = s.length();
            for(int i = 0; i < length; i++) cnt[s.charAt(i) - 'a']++;

            StringBuilder sb = new StringBuilder();
            for(int i = 0; i < 26; i++) {
                sb.append("#");
                sb.append(cnt[i]);
            }
            
            String key = sb.toString();
            if(map.containsKey(key)) {
                List<String> temp = map.get(key);
                temp.add(s);
                map.put(key,temp);
            } else {
                List<String> temp = new ArrayList<>();
                temp.add(s);
                map.put(key,temp);
            }
        }

        map.keySet().forEach(key -> ans.add(map.get(key)));
        return ans;
    }
    ```

4. Longest Substring Without Repeating Characters
    - 원문: Given a string s, find the length of the longest substring without repeating characters.
    - 해석: 반복되는 문자가 없는 가장 긴 부분문자열 찾기
    - 접근법
        * 슬라이딩 윈도우 형식의 접근법
        * left, right를 지정 후 left ~ right 범위에서 문자의 반복이 일어나는지 체크해가면서 진행
        * 문자의 반복은 해당 문자가 몇번나왔는지 카운트 하는것으로 체크
        * 반복 커서가 right의 위치에 도착 -> 해당 문자 카운트 ++ -> 해당문자의 카운트가 1보다 크면(즉 이미 나온 문자면), left를 ++ 시키면서(문자열의 앞글자를 하나씩 빼면서) 해당 문자 카운트 --
        * 중간에 나온 결과값과 max값 비교, right ++

    - 시간 복잡도: O(n)
    - 공간 복잡도: O(min(n,m)) - n: 문자열 길이, m: 알파벳 갯수
    - 코드

    ```java
    public int lengthOfLongestSubstring(String s) {
        int[] chars = new int[128];

        int left = 0;
        int right = 0;

        int res = 0;
        while (right < s.length()) {
            char r = s.charAt(right);
            chars[r]++;

            while (chars[r] > 1) {
                char l = s.charAt(left);
                chars[l]--;
                left++;
            }

            res = Math.max(res, right - left + 1);

            right++;
        }
        return res;
    }
    ```

5. Longest Palindromic Substring
    - Given a string s, return the longest palindromic substring in s.
    - 문자열이 주어지면, 가장긴 팰린드롬 부분문자열 구하기
    - 접근법
        * 팰린드롬은 가운데를 중심으로 좌우가 모두 같은 특징을 이용
        * 문자열을 한글자씩 순회하면서 그 문자를 중심으로 팰린드롬이 만들어지는지 확인
        * 만들어질때마다 max갱신

    - 시간복잡도: O(n^2)
    - 공간복잡도: O(1)
    - 코드
    
    ```java
    public String longestPalindrome(String s) {
        if (s == null || s.length() < 1) return "";
        int start = 0, end = 0;
        for (int i = 0; i < s.length(); i++) {
            int len1 = expandAroundCenter(s, i, i);
            int len2 = expandAroundCenter(s, i, i + 1);
            int len = Math.max(len1, len2);
            if (len > end - start) {
                start = i - (len - 1) / 2;
                end = i + len / 2;
            }
        }
        return s.substring(start, end + 1);
    }
    
    private int expandAroundCenter(String s, int left, int right) {
        int L = left, R = right;
        while (L >= 0 && R < s.length() && s.charAt(L) == s.charAt(R)) {
            L--;
            R++;
        }
        return R - L - 1;
    }
    ```

6. Increasing Triplet Subsequence
    - Given an integer array nums, return true if there exists a triple of indices (i, j, k) such that i < j < k and nums[i] < nums[j] < nums[k]. If no such indices exists, return false
    - 정수 배열이 주어지고 i < j < k 가 주어지면 nums[i] < nums[j] < nums[k] 가 있는지 확인
    - 접근법
        * 있는지 없는지만 확인하면 되고, 그게 어떤 경우인지는 확인 안해도됨
        * 그냥 순회하면서 최소값이 만들어지고, 그 다음으로 작은값이 만들어지고, 그 다음으로 작은값이 만들어지는지 체크
    - 시간복잡도: O(n)
    - 공간복잡도: O(1)
    - 코드
    
    ```java
    public boolean increasingTriplet(int[] nums) {
        int min1 = Integer.MAX_VALUE;
        int min2 = Integer.MAX_VALUE;
        for(int num : nums) {
            if(num <= min1) {
                min1 = num;
            }else if(num <= min2) {
                min2 = num;
            } else {
                return true;
            }
        }
        return false;
    }
    ```

7. Missing Ranges
    - You are given an inclusive range [lower, upper] and a sorted unique integer array nums, where all elements are in the inclusive range. A number x is considered missing if x is in the range [lower, upper] and x is not in nums. Return the smallest sorted list of ranges that cover every missing number exactly. That is, no element of nums is in any of the ranges, and each missing number is in one of the ranges.
    - lower, upper 라는 범위가 주어지고, 정렬된 정수배열이 주어질때, 범위내에서 정수 배열이 커버하지 못하는 범위를 출력
    - 접근법
        * 범위의 시작을 나타내는 prev 변수 1개 선언
        * 주어진 배열의 원소를 하나씩 확인하면서 prev + 1  ~ 현재 - 1 까지의 범위 기록
        * prev를 현재로 변경
        * 배열의 범위 끝까지하고 마지막으로 upper까지를 체크
    - 시간복잡도: O(n)
    - 공간복잡도: O(1)
    - 코드

    ```java
    public List<String> findMissingRanges(int[] nums, int lower, int upper) {
        List<String> ans = new ArrayList<>();

        int prev = lower-1;
        for(int i = 0; i <= nums.length; i++){
            int cur = i < nums.length ? nums[i] : upper + 1;
            if(prev + 1 <= cur -1) {
                ans.add(getString(prev + 1, cur -1));
            }
            prev = cur;
        }

        return ans;
    }
    
    public String getString(int lower, int upper) {
        if(lower == upper) {
            return String.valueOf(lower);
        }
        return String.valueOf(lower) + "->" + String.valueOf(upper);
    }
    ```


# Linked List

1. Add Two Numbers
    - You are given two non-empty linked lists representing two non-negative integers. The digits are stored in reverse order, and each of their nodes contains a single digit. Add the two numbers and return the sum as a linked list. You may assume the two numbers do not contain any leading zero, except the number 0 itself.
    - 2개의 링크드리스트가 주어지면 노드 하나씩 더하기
    - 접근법
        * 그냥 링크드리스트 원소 하나씩 순회하면서 더하기
        * 덧셈하다 자리올림 발생하는지 체크하면서 다음 원소로 이송
        * 한쪽이 다 떨어지면 걍 0 더해서 출력해주면됨
        * 맨 마지막에 자리올림 발생했엇는지 한번 더 체크

    - 시간복잡도: O(max(m,n)) - n,m 각 링크드리스트 노드 갯수
    - 공간복잡도: O(max(m,n))
    - 코드

    ```java
    public ListNode addTwoNumbers(ListNode l1, ListNode l2) {
        ListNode ans = new ListNode(0);
        ListNode p1 = l1;
        ListNode p2 = l2;
        ListNode curr = ans;
        int carry = 0;
        while(p1 != null || p2 != null) {
            int x = (p1 != null) ? p1.val : 0;
            int y = (p2 != null) ? p2.val : 0;
            int sum = x + y + carry;
            carry = sum/10;
            curr.next = new ListNode(sum % 10);
            curr = curr.next;
            if(p1 != null) p1 = p1.next;
            if(p2 != null) p2 = p2.next;
        }
        
        if(carry > 0) curr.next = new ListNode(carry);
        
        return ans.next;
    }
    ```

2. Odd Even Linked List
    - Given the head of a singly linked list, group all the nodes with odd indices together followed by the nodes with even indices, and return the reordered list. The first node is considered odd, and the second node is even, and so on. Note that the relative order inside both the even and odd groups should remain as it was in the input.
    - 링크드리스트가 주어지면 홀수번째 노드 / 짝수번째 노드 나눠서 홀수노드들 -> 짝수노드들 순서로 이어지게 바꿔서 리턴
    - 접근법
        * 홀수 노드가 저장되는 링크드리스트, 짝수 노드가 저장되는 링크드리스트 2개로 나눠서 저장해서 나중에 합침

    - 시간 복잡도: O(n)
    - 공간 복잡도: O(1)
    - 코드

    ```java
    public ListNode oddEvenList(ListNode head) {
        if (head == null) return null;
        ListNode odd = head, even = head.next, evenHead = even;
        while (even != null && even.next != null) {
            odd.next = even.next;
            odd = odd.next;
            even.next = odd.next;
            even = even.next;
        }
        odd.next = evenHead;
        return head;
    }
    ```

3. Intersection of Two Linked Lists
    - Given the heads of two singly linked-lists headA and headB, return the node at which the two lists intersect. If the two linked lists have no intersection at all, return null.
    - 두 링크드리스트가 주어지면, 그 링크드리스트가 겹치는 위치의 노드 반환(안겹치면 null)
    - 접근법
        * 겹친다 = 두개의 노드가 같다 를 이용
        * 각각의 링크드리스트를 움직이면서 같아지는지를 체크 
        * 만약 한쪽이 끝까지 갓는데 아직도 안같아졌다면 다른 녀석의 head를 거기에 붙여서 이어감
        * 이렇게 하면 두개의 링크드리스트 길이가 같아지게되고, 같은부분이 나온다면 무조건 걸림

    - 시간 복잡도: O(N+M) - N,M 각 링크드리스트 길이
    - 공간 복잡도: O(1) - 공간 복잡도
    - 코드

    ```java
    public ListNode getIntersectionNode(ListNode headA, ListNode headB) {
        ListNode pA = headA;
        ListNode pB = headB;
        while (pA != pB) {
            pA = pA == null ? headB : pA.next;
            pB = pB == null ? headA : pB.next;
        }
        return pA;
    }
    ```

# Tree and Graphs

1. Binary Tree Inorder Traversal
    - Given the root of a binary tree, return the inorder traversal of its nodes' values.
    - 이진트리가 주어지면 중위순회해서 출력
    - 접근법
        * 고전적인 트리 탐색인 dfs 를 활용
        * dfs를 재귀로 구현 하면서, dfs(왼쪽 자식) -> 자기 숫자 기록 -> dfs(오른쪽 자식)하면 중위순회

    - 시간 복잡도: O(n)
    - 공간 복잡도: O(n)
    - 코드
    
    ```java
    public List<Integer> inorderTraversal(TreeNode root) {
        List<Integer> ans = new ArrayList<>();
        dfs(root,ans);
        return ans;
    }
    
    public void dfs(TreeNode root, List<Integer> ans) {
        if(root != null) {
            if(root.left != null) dfs(root.left,ans);
            ans.add(root.val);
            if(root.right != null) dfs(root.right,ans);
        }
    }
    ```

2. Binary Tree Zigzag Level Order Traversal
    - Given the root of a binary tree, return the zigzag level order traversal of its nodes' values. (i.e., from left to right, then right to left for the next level and alternate between).
    - 이진트리의 루트가 주어지면 지그재그 순서대로 출력(한번은 왼쪽 -> 오른쪽, 한레벨 내려가면 역전)
    - 접근법
        * DFS를 사용
        * 레벨별로 결과를 저장하는 리스트를생성
        * 레벨별로 순서에 따라 결과 저장 리스트에 뒤에 삽입 or 앞에 삽입
    - 시간 복잡도: O(n)
    - 공간 복잡도: O(H) - 트리 높이
    - 코드
    
    ```java
    protected void DFS(TreeNode node, int level, List<List<Integer>> results) {
        if (level >= results.size()) {
            LinkedList<Integer> newLevel = new LinkedList<Integer>();
            newLevel.add(node.val);
            results.add(newLevel);
        } else {
            if (level % 2 == 0)
                results.get(level).add(node.val);
            else
                results.get(level).add(0, node.val);
        }

        if (node.left != null) DFS(node.left, level + 1, results);
        if (node.right != null) DFS(node.right, level + 1, results);
    }

    public List<List<Integer>> zigzagLevelOrder(TreeNode root) {
        if (root == null) {
            return new ArrayList<List<Integer>>();
        }
        List<List<Integer>> results = new ArrayList<List<Integer>>();
        DFS(root, 0, results);
        return results;
    }
    ```

3. Construct Binary Tree from Preorder and Inorder Traversal
    - Given two integer arrays preorder and inorder where preorder is the preorder traversal of a binary tree and inorder is the inorder traversal of the same tree, construct and return the binary tree.
    - 전위순회랑 중위순회로 순회한 결과가 들어있는 2개의 배열이 주어지면, 실제 트리 그리기
    - 접근법
        * 전위순회는 Root -> Left -> Right라서 Root를 알아내기 쉬움
        * 중위순회는 Left -> Root -> Right인데 Root을 이미 알아냈으니 왼쪽 서브트리와, 오른쪽 서브트리로 나눌 수 있음
        * 위를 재귀적으로 반복하며 전위순회 배열에서 루트를 알아내고, 중위순회에서 서브트리로 분해
        * 전위순회에서 어디까지 확인했는지 알수있게 커서 하나 생성, 중위순회에서 해당 노드의 값을 키로가지고 인덱스를 벨류로 가지는 맵 생성
        * 재귀를 하면서 전위순회의 커서가 있는곳을 root으로 만들어주고 커서++
        * 루트의 왼쪽 자식은 시작범위 ~ 맵에 있는 root의 인덱스값 -1, 오른쪽 자식은 맵에 있는 root의 인덱스값 +1 ~ 끝범위

    - 시간 복잡도: O(n)
    - 공간 복잡도: O(n)
    - 코드

    ```java
    int preorderIndex;
    Map<Integer, Integer> inorderIndexMap;
    public TreeNode buildTree(int[] preorder, int[] inorder) {
        preorderIndex = 0;
        // build a hashmap to store value -> its index relations
        inorderIndexMap = new HashMap<>();
        for (int i = 0; i < inorder.length; i++) {
            inorderIndexMap.put(inorder[i], i);
        }

        return arrayToTree(preorder, 0, inorder.length - 1);
    }

    private TreeNode arrayToTree(int[] preorder, int left, int right) {
        // if there are no elements to construct the tree
        if (left > right) return null;

        // select the preorder_index element as the root and increment it
        int rootValue = preorder[preorderIndex++];
        TreeNode root = new TreeNode(rootValue);

        // build left and right subtree
        // excluding inorderIndexMap[rootValue] element because it's the root
        root.left = arrayToTree(preorder, left, inorderIndexMap.get(rootValue) - 1);
        root.right = arrayToTree(preorder, inorderIndexMap.get(rootValue) + 1, right);
        return root;
    }
    ```

4. Populating Next Right Pointers in Each Node
    - Populate each next pointer to point to its next right node. If there is no next right node, the next pointer should be set to NULL. Initially, all next pointers are set to NULL.
    - 완전 이진트리가 주어지면, 트리 내의 각 노드의 옆노드를 지정해서 반환
    - 접근법
        * 루트의 Next는 무조건 null이고, 부모노드에서 자식 노드사이의 관계를 바로 볼수있는것을 이용
        * root.left.next = root.right & root.right.next = root.next.left 라는 규칙이 나옴
        * 해당 레벨에서 가장 왼쪽을 가리키는 포인터 하나(leftmost)와, 그 레벨을 순회할 포인터 하나(head)를 만들어서 순회
        * 해당 레벨의 순회가 끝나면 leftmost를 leftmost = leftmost.left로 한레벨 낮춰줌
    - 시간 복잡도: O(N)
    - 공간 복잡도: O(1)

    ```java
    public Node connect(Node root) {
        if (root == null) {
            return root;
        }
        
        Node leftmost = root;
        
        while (leftmost.left != null) {
            Node head = leftmost;
            while (head != null) {
                head.left.next = head.right;
                if (head.next != null) {
                    head.right.next = head.next.left;
                }
                head = head.next;
            }
            leftmost = leftmost.left;
        }
        return root; 
    }
    ```

5. Kth Smallest Element in a BST
    - Given the root of a binary search tree, and an integer k, return the kth (1-indexed) smallest element in the tree
    - 이진탐색트리가 주어지면, 그중에 k번째로 작은 원소 출력
    - 접근법
        * 이진탐색트리는 전위순회를 하면 작은순으로 나온다는것을 이용
        * dfs를 통해 전위순회를 구현하고, 순회 결과를 담는 list를 하나 만듬
        * 결과 list에서 k-1번째를 반환

    - 시간 복잡도: O(N)
    - 공간 복잡도: O(N)
    - 코드

    ```java
    public int kthSmallest(TreeNode root, int k) {
        List<Integer> preOrder = new ArrayList<>();
        dfs(root,preOrder);
        return preOrder.get(k-1);
    }
    
    public void dfs(TreeNode root, List<Integer> preOrder) {
        if(root.left != null) dfs(root.left, preOrder);
        preOrder.add(root.val);
        if(root.right != null) dfs(root.right, preOrder);
    }
    ```

6. Inorder Successor in BST
    - Given the root of a binary search tree and a node p in it, return the in-order successor of that node in the BST. If the given node has no in-order successor in the tree, return null. The successor of a node p is the node with the smallest key greater than p.val.
    - 이진 탐색 트리의 루트와 그 트리의 노드 하나가 주어질때, 그 노드의 중위순회 후속자를 구해라
    - 접근법
        * 문제에도 써져 있듯이 후속자는 p보다 크지만, 그중에 가장 작은 노드임
        * 이진 탐색 트리기 때문에, 트리의 왼쪽은 루트보다 작고, 오른쪽은 루트보다 큰것을 이용

    - 시간 복잡도 : O(N)
    - 공간 복잡도 : O(1)
    - 코드

    ```java
    public TreeNode inorderSuccessor(TreeNode root, TreeNode p) {
        TreeNode successor = null;   
        while (root != null) {
            if (p.val >= root.val) {
                root = root.right;
            } else {
                successor = root;
                root = root.left;
            }
        }
        
        return successor;
    }
    ```

7. Number of Islands
    - Given an m x n 2D binary grid grid which represents a map of '1's (land) and '0's (water), return the number of islands. An island is surrounded by water and is formed by connecting adjacent lands horizontally or vertically. You may assume all four edges of the grid are all surrounded by water.
    - 맵이 주어지고 거기에 땅은 1, 물은 0으로 표시될때, 섬의 갯수(물로 둘러쌓인 땅 덩어리)
    - 접근법
        * 일단 전체 맵을 순회 하면서 땅을 발견하면 그 지점부터 DFS / BFS를 하면서 그 섬의 전체를 마킹
        * 한번 마킹 할때마다 카운트 ++
        * 카운트 반환
    - 시간 복잡도: O(N*M)
    - 공간 복잡도: O(N*M)
    - 코드

    ```java
    void dfs(char[][] grid, int r, int c) {
        int nr = grid.length;
        int nc = grid[0].length;

        if (r < 0 || c < 0 || r >= nr || c >= nc || grid[r][c] == '0') {
            return;
        }

        grid[r][c] = '0';
        dfs(grid, r - 1, c);
        dfs(grid, r + 1, c);
        dfs(grid, r, c - 1);
        dfs(grid, r, c + 1);
    }

    public int numIslands(char[][] grid) {
        if (grid == null || grid.length == 0) {
            return 0;
        }

        int nr = grid.length;
        int nc = grid[0].length;
        int num_islands = 0;
        for (int r = 0; r < nr; ++r) {
            for (int c = 0; c < nc; ++c) {
                if (grid[r][c] == '1') {
                    ++num_islands;
                    dfs(grid, r, c);
                }
            }
        }

        return num_islands;
    }
  ````

# Backtracking

1. Letter Combinations of a Phone Number
    - Given a string containing digits from 2-9 inclusive, return all possible letter combinations that the number could represent. Return the answer in any order. A mapping of digit to letters (just like on the telephone buttons) is given below. Note that 1 does not map to any letters.
    - 2~9의 숫자로 이뤄진 문자열이 입력되면, 휴대폰 자판에서 그 숫자들로 가능한 알파벳 조합을 리턴(2 -> abc, 3 -> def 이런거)
    - 접근법
        * 재귀방법을 이용해서 풀이
        * 한 문자씩 붙여나가다가 붙여 나가는 문자열 길이가 같아지면 만든 문자열 반환하고 끝
        * Length 0일때만 따로 처리

    - 시간 복잡도: O(4^N * N)
    - 공간 복잡도: O(N)
    - 코드

    ```java
    private List<String> combinations = new ArrayList<>();
    private Map<Character, String> letters = Map.of(
        '2', "abc", '3', "def", '4', "ghi", '5', "jkl", 
        '6', "mno", '7', "pqrs", '8', "tuv", '9', "wxyz");
    private String phoneDigits;
    
    public List<String> letterCombinations(String digits) {
        if (digits.length() == 0) {
            return combinations;
        }
        
        phoneDigits = digits;
        backtrack(0, new StringBuilder());
        return combinations;
    }
    
    private void backtrack(int index, StringBuilder path) {
        // If the path is the same length as digits, we have a complete combination
        if (path.length() == phoneDigits.length()) {
            combinations.add(path.toString());
            return; // Backtrack
        }
        
        // Get the letters that the current digit maps to, and loop through them
        String possibleLetters = letters.get(phoneDigits.charAt(index));
        for (char letter: possibleLetters.toCharArray()) {
            // Add the letter to our current path
            path.append(letter);
            // Move on to the next digit
            backtrack(index + 1, path);
            // Backtrack by removing the letter before moving onto the next
            path.deleteCharAt(path.length() - 1);
        }
    }
    ```

2. Generate Parentheses
    - Given n pairs of parentheses, write a function to generate all combinations of well-formed parentheses.
    - n이 주어지면 n개의 괄호쌍으로 만들수있는 조합 출력. 조합은 완전해야함
    - 접근법
        * 백트래킹이니 역시 재귀
        * n개의 여는 괄호와, n개의 닫는 괄호가 나와야 한다는점에 착안
        * 열린괄호 숫자 < n 이면 괄호 열고 다음 반복, 닫는괄호 숫자 < n 이면 괄호 닫고 다음 반복
        * 문자열 길이가 2*n에 도달하면 재귀 종료

    - 코드

    ```java
    public List<String> generateParenthesis(int n) {
        List<String> ans = new ArrayList();
        backtrack(ans, new StringBuilder(), 0, 0, n);
        return ans;  
    }
    
    public void backtrack(List<String> ans, StringBuilder cur, int open, int close, int max){
        if (cur.length() == max * 2) {
            ans.add(cur.toString());
            return;
        }

        if (open < max) {
            cur.append("(");
            backtrack(ans, cur, open+1, close, max);
            cur.deleteCharAt(cur.length() - 1);
        }
        if (close < open) {
            cur.append(")");
            backtrack(ans, cur, open, close+1, max);
            cur.deleteCharAt(cur.length() - 1);
        }
    }
    ```

3. Permutations
    - Given an array nums of distinct integers, return all the possible permutations. You can return the answer in any order.
    - 숫자 배열이 주어지면 가능한 모든 조합을 출력
    - 접근법
        * 전통적인 순열 알고리즘
    - 코드

    ```java
    public void backtrack(int n,
                        ArrayList<Integer> nums,
                        List<List<Integer>> output,
                        int first) {
    // if all integers are used up
    if (first == n)
      output.add(new ArrayList<Integer>(nums));
    for (int i = first; i < n; i++) {
      // place i-th integer first 
      // in the current permutation
      Collections.swap(nums, first, i);
      // use next integers to complete the permutations
      backtrack(n, nums, output, first + 1);
      // backtrack
      Collections.swap(nums, first, i);
    }
  }

  public List<List<Integer>> permute(int[] nums) {
    // init output list
    List<List<Integer>> output = new LinkedList();

    // convert nums into list since the output is a list of lists
    ArrayList<Integer> nums_lst = new ArrayList<Integer>();
    for (int num : nums)
      nums_lst.add(num);

    int n = nums.length;
    backtrack(n, nums_lst, output, 0);
    return output;
  }
  ```

4. Subsets
    - Given an integer array nums of unique elements, return all possible subsets (the power set). The solution set must not contain duplicate subsets. Return the solution in any order.
    - 중복이 없는 숫자로 이뤄진 집합이 주어지면, 그 집합의 전체 부분집합을 구하기
    - 접근법
        * 전통적인 조합 공식
        * 수열을 순회하면서 해당 위치의 값을 포함하는 재귀한번, 불포함하는 재귀 한번 하면 됨
    
    - 시간 복잡도: O(N*2^N)
    - 공간 복잡도: O(N)
    - 코드

    ```java
    public void powerset(int cur, int length, int[] nums, List<Integer> currString,              List<List<Integer>> ans) {
        if(cur == length) {
            ans.add(new ArrayList<>(currString));
        } else {
            currString.add(nums[cur]);
            powerset(cur+1, length, nums, currString, ans);

            currString.remove(currString.size()-1);
            powerset(cur+1, length, nums, currString, ans);
        }
    }

    public List<List<Integer>> subsets(int[] nums) {
        List<List<Integer>> ans = new ArrayList<>();
        powerset(0,nums.length,nums,new ArrayList<Integer>(),ans);
        return ans;
    }
    ```

5. Word Search
    - Given an m x n grid of characters board and a string word, return true if word exists in the grid. The word can be constructed from letters of sequentially adjacent cells, where adjacent cells are horizontally or vertically neighboring. The same letter cell may not be used more than once.
    - m x n 사이즈의 문자 2차원 배열과, 문자열이 들어오면 해당 문자 2차원 배열에 해당 문자열이 있는지 확인
    - 접근법
        * dfs

    - 시간 복잡도: O(N * 3^L) - L word 의 길이
    - 공간 복잡도: O(L)
    - 코드

    ```java
    private char[][] board;
    private int ROWS;
    private int COLS;

    public boolean exist(char[][] board, String word) {
        this.board = board;
        this.ROWS = board.length;
        this.COLS = board[0].length;

        for (int row = 0; row < this.ROWS; ++row)
            for (int col = 0; col < this.COLS; ++col)
                if (this.backtrack(row, col, word, 0))
                    return true;
        return false;
    }

    protected boolean backtrack(int row, int col, String word, int index) {
        /* Step 1). check the bottom case. */
        if (index >= word.length())
            return true;

        /* Step 2). Check the boundaries. */
        if (row < 0 || row == this.ROWS || col < 0 || col == this.COLS
                || this.board[row][col] != word.charAt(index))
            return false;

        /* Step 3). explore the neighbors in DFS */
        boolean ret = false;
        // mark the path before the next exploration
        this.board[row][col] = '#';

        int[] rowOffsets = {0, 1, 0, -1};
        int[] colOffsets = {1, 0, -1, 0};
        for (int d = 0; d < 4; ++d) {
            ret = this.backtrack(row + rowOffsets[d], col + colOffsets[d], word, index + 1);
            if (ret)
                break;
        }

        /* Step 4). clean up and return the result. */
        this.board[row][col] = word.charAt(index);
        return ret;
    }
    ```

# Sorting and Searching

1. Sort Colors
    - Given an array nums with n objects colored red, white, or blue, sort them in-place so that objects of the same color are adjacent, with the colors in the order red, white, and blue. We will use the integers 0, 1, and 2 to represent the color red, white, and blue, respectively. You must solve this problem without using the library's sort function.
    - 0,1,2로 이뤄진 배열이 들어오면 같은 숫자끼리 뭉쳐서 출력. 주어진 공간 내에서 정렬 할것
    - 접근법
        * 주어진 공간 내에서 해야 하므로 삽입정렬이 적절할것으로 보임

    - 시간 복잡도: O(N^2)
    - 공간 복잡도: O(N)
    - 코드

    ```java
    static void insertionSort(int list[]){
        int i, j, key;

        // 인텍스 0은 이미 정렬된 것으로 볼 수 있다.
        for(i=1; i<list.length; i++){
            key = list[i]; // 현재 삽입될 숫자인 i번째 정수를 key 변수로 복사

            // 현재 정렬된 배열은 i-1까지이므로 i-1번째부터 역순으로 조사한다.
            // j 값은 음수가 아니어야 되고
            // key 값보다 정렬된 배열에 있는 값이 크면 j번째를 j+1번째로 이동
            for(j=i-1; j>=0 && list[j]>key; j--){
                list[j+1] = list[j]; // 레코드의 오른쪽으로 이동
            }
            list[j+1] = key;
        }
    }
    ```

2. Top K Frequent Elements
    - Given an integer array nums and an integer k, return the k most frequent elements. You may return the answer in any order.
    - 배열과 정수가 주어지면 해당 배열에서 k번째로 빈도가 높은 숫자까지 출력
    - 접근법
        * 힙(우선순위큐)로 접근
        * map을 이용해서 해당 숫자의 카운트를 숫자값과 같이 저장하고, 해당 맵에 있는 카운트 기준으로 힙이 정렬되도록해서 출력

    - 시간 복잡도: O(NlogK)
    - 공간 복잡도: O(N + K)
    - 코드

    ```java
    public static int[] topKFrequent(int[] nums, int k) {
        int ans[] = new int[k];
        Map<Integer,Integer> count = new HashMap<>();
        PriorityQueue<Integer> pq = new PriorityQueue<>((n1,n2) -> count.get(n2) - count.get(n1));
        for(int i = 0; i < nums.length; i++) {
            count.put(nums[i],count.getOrDefault(nums[i],0) + 1);
        }

        for(Integer key : count.keySet()) {
            pq.add(key);
        }

        for(int i = 0; i < k; i++) {
            ans[i] = pq.poll();
        }

        return ans;
    }
    ```

3. Kth Largest Element in an Array
    - Given an integer array nums and an integer k, return the kth largest element in the array. Note that it is the kth largest element in the sorted order, not the kth distinct element.
    - 배열이 주어지고 K가 주어지면, 배열에서 K번째로 큰 원소 출력
    - 접근법    
        * 힙으로 접근
        * 배열의 원소를 모두 힙에 넣고, 힙을 큰수부터 나오게 하고, K번째껄 출력
    - 시간 복잡도: O(NlogK)
    - 공간 복잡도: O(N)
    - 코드

    ```java
    public int findKthLargest(int[] nums, int k) {
        PriorityQueue<Integer> pq = new PriorityQueue<>(Collections.reverseOrder());
        int ans = 0;
        for(int num : nums) {
            pq.add(num);
        }

        for(int i = 0; i < k; i++) {
            ans = pq.poll();
        }
        return ans;
    }
    ```

4. Find Peak Element
    - A peak element is an element that is strictly greater than its neighbors. Given an integer array nums, find a peak element, and return its index. If the array contains multiple peaks, return the index to any of the peaks. You may imagine that nums[-1] = nums[n] = -∞. You must write an algorithm that runs in O(log n) time.
    - 배열이 주어지면, 자신의 양 이웃보다 큰 배열 원소의 인덱스 출력
    - 접근법
        * 선형 탐색 해서 그냥 자신의 다음보다 큰 원소가 있으면 그것 인덱스 반환

    - 시간복잡도: O(N)
    - 공간복잡도: O(1)
    - 코드

    ```java
    public int findPeakElement(int[] nums) {
        for(int i = 0; i < nums.length-1; i ++) {
            if(nums[i] > nums[i+1]) return i;
        }
        return nums.length -1;
    }
    ```

5. Search for a Range
    - Given an array of integers nums sorted in ascending order, find the starting and ending position of a given target value. If target is not found in the array, return [-1, -1]. You must write an algorithm with O(log n) runtime complexity.
    - 정렬된 배열이 주어지고, 타겟이 있으면 배열 내에서 타겟이 존재하는 범위를 출력. 타겟이 배열 내에 없으면 {-1,-1}
    - 접근법
        * 선형 탐색해서 처음 출현한 인덱스 기록하고, 이후 새로 발견될때마다 계속 나중 인덱스 업뎃해서 그거 반환

    - 시간 복잡도: O(N)
    - 공간 복잡도: O(1)
    - 코드

    ```java
    public int[] searchRange(int[] nums, int target) {
        int ans[] = { -1, -1};
        if(nums.length == 0) return ans;
        int cur = 0;
        for(int i = 0; i < nums.length; i++) {
            if(nums[i] == target && cur == 0) {
                ans[0] = i;
                ans[1] = i;
                cur++;
            } else if (nums[i] == target) {
                ans[1] = i;
            }
        }
        
        return ans;
    }
    ```

6. Merge Intervals
    - Given an array of intervals where intervals[i] = [starti, endi], merge all overlapping intervals, and return an array of the non-overlapping intervals that cover all the intervals in the input.
    - 주어진 배열들의 중복되는 범위를 합쳐서 출력 ( [0,2], [1,3] -> [0,3])
    - 접근법
        * 일단 주어진 배열들을 범위의 시작값 기준으로 정렬
        * 그 이후 하나씩 순회하면서 결과 리스트가 비어있거나, 마지막으로 저장된 범위의 끝값이 지금 값보다 작은경우 추가
        * 그게 아닌 경우 마지막으로 저장된 범위값의 끝값과 지금 범위의 끝값중 큰값으로 변경

    - 시간 복잡도: O(nlogn)
    - 공간 복잡도: O(logN)
    - 코드
    
    ```java
    public int[][] merge(int[][] intervals) {
        Arrays.sort(intervals, (a, b) -> Integer.compare(a[0], b[0]));
        LinkedList<int[]> merged = new LinkedList<>();
        for (int[] interval : intervals) {
            // if the list of merged intervals is empty or if the current
            // interval does not overlap with the previous, simply append it.
            if (merged.isEmpty() || merged.getLast()[1] < interval[0]) {
                merged.add(interval);
            }
            // otherwise, there is overlap, so we merge the current and previous
            // intervals.
            else {
                merged.getLast()[1] = Math.max(merged.getLast()[1], interval[1]);
            }
        }
        return merged.toArray(new int[merged.size()][]);
    }
    ```

7. Search in Rotated Sorted Array
    - There is an integer array nums sorted in ascending order (with distinct values). Prior to being passed to your function, nums is rotated at an unknown pivot index k (0 <= k < nums.length) such that the resulting array is [nums[k], nums[k+1], ..., nums[n-1], nums[0], nums[1], ..., nums[k-1]] (0-indexed). For example, [0,1,2,4,5,6,7] might be rotated at pivot index 3 and become [4,5,6,7,0,1,2]. Given the array nums after the rotation and an integer target, return the index of target if it is in nums, or -1 if it is not in nums. You must write an algorithm with O(log n) runtime complexity.
    - 해석이 잘 안됨
    - 접근방법
        * 이진탐색
    - 시간 복잡도: O(logN)
    - 공간 복잡도: O(1)
    - 코드

    ```java
    public int search(int[] nums, int target) {
        int start = 0, end = nums.length - 1;
        while (start <= end) {
          int mid = start + (end - start) / 2;
          if (nums[mid] == target) return mid;
          else if (nums[mid] >= nums[start]) {
            if (target >= nums[start] && target < nums[mid]) end = mid - 1;
            else start = mid + 1;
          }
          else {
            if (target <= nums[end] && target > nums[mid]) start = mid + 1;
            else end = mid - 1;
          }
        }
        return -1;
    }
    ```

8. Meeting Rooms II
    - Given an array of meeting time intervals intervals where intervals[i] = [starti, endi], return the minimum number of conference rooms required.
    - 회의실 예약 정보(시작시간, 종료시간)이 입력되면 최소 몇개의 회의실이 있어야 하는가 반환
    - 접근법
        * 우선순위 큐 활용
        * 회의실의 시작시간 기준으로 정렬
        * 첫 회의실의 종료 시간을 일단 최소힙에 넣고 시작
        * 두번째 회의실의 시작시간부터 비교, 최소힙의 최소값(가장 이른 종료 시간)보다 자신의 시작시간이 더 나중이라면 그 회의실을 이어 쓸수 있단 의미 이므로 최소힙에서 최소값 제거
        * 위 로직과 상관 없이 자신의 종료 시간을 최소힙에 추가(회의실을 하나 점유한다는 의미)
        * 최소힙의 갯수 출력

    - 시간 복잡도: O(NlogN)
    - 공간 복잡도: O(N)
    - 코드
    
    ```java
    public int minMeetingRooms(int[][] intervals) {
        
        // Check for the base case. If there are no intervals, return 0
        if (intervals.length == 0) {
          return 0;
        }

        // Min heap
        PriorityQueue<Integer> allocator =
            new PriorityQueue<Integer>(
                intervals.length,
                new Comparator<Integer>() {
                  public int compare(Integer a, Integer b) {
                    return a - b;
                  }
                });

        // Sort the intervals by start time
        Arrays.sort(
            intervals,
            new Comparator<int[]>() {
              public int compare(final int[] a, final int[] b) {
                return a[0] - b[0];
              }
            });

        // Add the first meeting
        allocator.add(intervals[0][1]);

        // Iterate over remaining intervals
        for (int i = 1; i < intervals.length; i++) {

          // If the room due to free up the earliest is free, assign that room to this meeting.
          if (intervals[i][0] >= allocator.peek()) {
            allocator.poll();
          }

          // If a new room is to be assigned, then also we add to the heap,
          // If an old room is allocated, then also we have to add to the heap with updated end time.
          allocator.add(intervals[i][1]);
        }

        // The size of the heap tells us the minimum rooms required for all the meetings.
        return allocator.size();
    }
    ```

9. Search a 2D Matrix II
    - Write an efficient algorithm that searches for a target value in an m x n integer matrix. The matrix has the following properties: Integers in each row are sorted in ascending from left to right. Integers in each column are sorted in ascending from top to bottom.
    - 행이 위에서 아래로 오름차순 정렬되있고, 열도 왼쪽에서 오른쪽으로 오름차순 정렬 되있는 행렬이 주어질때, 행렬안에서 target이 있는지 찾아서 반환
    - 접근법
        * 해당 행렬의 특성을 이용
        * 제일 왼쪽 아래 원소부터 시작, 해당 값이 타겟보다 크면 row --, 크면 col++ 해서, 범위 밖으로 벗어나기전에 찻는것(벗어나면 없음)

    - 시간 복잡도: O(n + m)
    - 공간 복잡도: O(1)
    - 코드

    ```java
    public boolean searchMatrix(int[][] matrix, int target) {
        // start our "pointer" in the bottom-left
        int row = matrix.length-1;
        int col = 0;

        while (row >= 0 && col < matrix[0].length) {
            if (matrix[row][col] > target) {
                row--;
            } else if (matrix[row][col] < target) {
                col++;
            } else { // found it
                return true;
            }
        }

        return false;
    }
    ```


# Dynamic programming

1. Jump Game
    - Given an array of non-negative integers nums, you are initially positioned at the first index of the array. Each element in the array represents your maximum jump length at that position. Determine if you are able to reach the last index.
    - 배열이 주어지고, 해당 배열의 원소값은 그 위치에서 점프할수있는 최대 칸수임. 처음부터 시작했을때 마지막까지 도달할수있는지 없는지 
    - 접근법
        * DP + 메모제이션
        * 일단 메모용 길이가 같은 배열을 하나 선언하고, 해당 배열을 모두 false로 초기화
        * 배열의 맨마지막만 true로 바꾸고(도착할수 있다고 가정), 맨 마지막에서 하나 전꺼부터 하나씩 줄여가면서 처음으로 탐색
        * 인덱스 + 해당 칸의 값(해당 칸에서 갈수 있는 최대 길이)과 길이 -1(마지막 위치)의 min을 비교 -> 해당 칸에서 최대한 갈 수 있는 거리
        * 해당 칸 다음부터 최대한 갈수 있는 거리 사이중에 memo가 true가 있는지 확인. 있으면 해당 칸도 true
    
    - 시간 복잡도: O(N^2)
    - 공간 복잡도: O(N)
    - 코드
    ```java
    public boolean canJump(int[] nums) {
        boolean[] memo = new boolean[nums.length];
        for(int i = 0; i < memo.length; i++) {
            memo[i] = false;
        }
        
        memo[memo.length -1] = true;
        
        for(int i = nums.length -2; i >= 0; i--) {
            int jump = Math.min(i + nums[i], nums.length -1);
            for(int j = i + 1; j <= jump; j++) {
                if(memo[j]) {
                    memo[i] = true;
                    break;
                }
            }
        }
        
        return memo[0];
    }
    ```

2. Unique Paths
    - A robot is located at the top-left corner of a m x n grid (marked 'Start' in the diagram below). The robot can only move either down or right at any point in time. The robot is trying to reach the bottom-right corner of the grid (marked 'Finish' in the diagram below). How many possible unique paths are there?
    - 말은 길지만 결국 m x n 체스판의 좌상단부터 우하단까지 갈수있는 길의 가짓수
    - 접근법
        * 대표적인 DP
        * 첫 행과 첫 열을 1로 초기화 해두고 그 다음부터는 해당칸의 앞칸과 윗칸의 합으로 하면 됨

    - 시간 복잡도: O(N*M)
    - 공간 복잡도: O(N*M)
    - 코드

    ```java
    public int uniquePaths(int m, int n) {
        int arr[][] = new int[m][n];
        for(int i = 0; i < n; i ++ ) arr[0][i] = 1;
        for(int i = 0; i < m; i++ ) arr[i][0] = 1;
        for(int i = 1; i < m; i++) {
            for(int j = 1; j < n; j ++) {
                arr[i][j] = arr[i-1][j] + arr[i][j-1];
            }
        }
        
        return arr[m-1][n-1];
    }
    ```

3. Coin Change
    - You are given an integer array coins representing coins of different denominations and an integer amount representing a total amount of money. Return the fewest number of coins that you need to make up that amount. If that amount of money cannot be made up by any combination of the coins, return -1. You may assume that you have an infinite number of each kind of coin.
    - 동전의 종류가 주어지고 주어진 금액을 가진 동전으로 만들수 있는 가짓수가 몇가지인지 묻는 문제
    - 접근법
        * DP
        * 1원부터 주어진 금액까지 반복 & 주어진 동전의 가짓수 만큼 반복
        * 현재 만들고 있는 금액이 동전으로 만들 수있는 경우, 현재 만들고 있는 금액의 가짓수 = (현재 만들고 있는 금액 - 현재 동전금액)의 가짓수 + 1
    - 시간 복잡도: O(S * n)
    - 공간 복잡도: O(S)
    - 코드

    ```java
    public int coinChange(int[] coins, int amount) {
        int max = amount + 1;
        int[] dp = new int[amount + 1];
        Arrays.fill(dp, max);
        dp[0] = 0;
        for (int i = 1; i <= amount; i++) {
          for (int j = 0; j < coins.length; j++) {
            if (coins[j] <= i) {
              dp[i] = Math.min(dp[i], dp[i - coins[j]] + 1);
            }
          }
        }
        return dp[amount] > amount ? -1 : dp[amount];
    }
    ```

4. Longest Increasing Subsequence
    - Given an integer array nums, return the length of the longest strictly increasing subsequence. A subsequence is a sequence that can be derived from an array by deleting some or no elements without changing the order of the remaining elements. For example, [3,6,2,7] is a subsequence of the array [0,3,1,6,2,2,7].
    - 수열이 주어지면 그 수열의 부분수열중 최대로 증가하는 부분수열 찾기
    - 접근법
        * DP
    - 시간 복잡도: O(n^2)
    - 공간 복잡도: O(n)
    - 코드
    
    ```java
    public int lengthOfLIS(int[] nums) {
        if (nums.length == 0) {
            return 0;
        }
        int[] dp = new int[nums.length];
        dp[0] = 1;
        int maxans = 1;
        for (int i = 1; i < dp.length; i++) {
            int maxval = 0;
            for (int j = 0; j < i; j++) {
                if (nums[i] > nums[j]) {
                    maxval = Math.max(maxval, dp[j]);
                }
            }
            dp[i] = maxval + 1;
            maxans = Math.max(maxans, dp[i]);
        }
        return maxans;
    }
    ```

# Math

1. Happy Number
    - A happy number is a number defined by the following process: Starting with any positive integer, replace the number by the sum of the squares of its digits Repeat the process until the number equals 1 (where it will stay), or it loops endlessly in a cycle which does not include 1 Those numbers for which this process ends in 1 are happy.
    - 숫자를 한자리씩 나눠서 그걸 제곱해서 더해가는걸 반복할때 1이 되는 수인지(100 -> 1^2 + 0^2 + 0^2 = 1)
    - 접근법
        * 싸이클이 생기는지 안생기는지 봐야함
        * 매 스텝 반복하면서 Set에 기록해서 Set에 이미 기록된값이라면 false
        * 아니고 1까지 나오면 true

    - 시간 복잡도: O(logN)
    - 공간 복잡도: O(logN)
    - 코드

    ```java
    private int getNext(int n) {
        int totalSum = 0;
        while (n > 0) {
            int d = n % 10;
            n = n / 10;
            totalSum += d * d;
        }
        return totalSum;
    }

    public boolean isHappy(int n) {
        Set<Integer> seen = new HashSet<>();
        while (n != 1 && !seen.contains(n)) {
            seen.add(n);
            n = getNext(n);
        }
        return n == 1;
    }
    ```

2. Factorial Trailing Zeroes
    - Given an integer n, return the number of trailing zeroes in n!.
    - n! 의 끝에 0이 몇개인지
    - 접근법
        * 끝이 0으로 끝나려면 5가 한번씩 들어가야함
    - 시간 복잡도: O(logN)
    - 공간 복잡도: O(1)
    - 코드

    ```java
    public int trailingZeroes(int n) {
        int zeroCount = 0;
        long currentMultiple = 5;
        while (n > 0) {
            n /= 5;
            zeroCount += n;
        }
        return zeroCount;
    }
    ```

3. Excel Sheet Column Number
    - Given a string columnTitle that represents the column title as appear in an Excel sheet, return its corresponding column number.
    - 엑셀의 시트의 컬럼명이 주어지면 몇번째 시트인지(A->1, B->2, AA -> 27, AB -> 28)
    - 접근법
        * 문자열이 한글자 늘어날때마다 숫자가 26의 배수로 늘어감(A = 26, B = 52 ..)
        * 앞에서 부터 읽어가면서 계산
    - 시간 복잡도: O(N) - N은 문자열의 길이
    - 공간 복잡되: O(1)
    - 코드

    ```java
    public int titleToNumber(String s) {
        int result = 0;
        int n = s.length();
        for (int i = 0; i < n; i++) {
            result = result * 26;
            // In Java, subtracting characters is subtracting ASCII values of characters
            result += (s.charAt(i) - 'A' + 1);
        }
        return result;
    }
    ```

4. Pow(x, n)
    - x의 n승 구하기
    - 접근법
        * 수학적 특징 이용

    - 코드

    ```java
    public double myPow(double x, int n) {
        long N = n;
        if (N < 0) {
            x = 1 / x;
            N = -N;
        }
        double ans = 1;
        double current_product = x;
        for (long i = N; i > 0; i /= 2) {
            if ((i % 2) == 1) {
                ans = ans * current_product;
            }
            current_product = current_product * current_product;
        }
        return ans;
    }
    ```


    




