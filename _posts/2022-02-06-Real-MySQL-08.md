---
layout: post
title: "Real MySQL 11 : 쿼리 작성 및 최적화"
description: Real MySQL 11장 - 쿼리 작성 및 최적화
date: 2022-02-06 15:06:00 +09:00
categories: MySQL RealMySQL Study
---

# 쿼리 작성 및 최적화

## 쿼리 작성과 연관된 시스템 변수

### SQL 모드
- sql_mode 시스템 변수에는 , 를 통해 여러 값이 동시에 할당 될 수 있음
- STRICT_ALL_TABLES & STRICT_TRANS_TABLES: MySQL서버에서 INSERT나 UPDATE 문장으로 데이터로 변경하는 경우, 타입이 다르다면 자동으로 타입 변경을 수행하는데, 이때 타입이 적절히 변환되기 어렵거나, 칼럼에 저장될 값이 없거나, 값의 길이가 칼럼의 최대 길이보다 큰 경우 문장을 계속 실행 시킬지 에러를 발생할지 결정. STRICT_TRANS_TABLES는 InnoDB같은 트랜잭션을 지원하는 스토리지 엔진에만 엄격한 모드, STRICT_ALL_TABLES는 모든 스토리지 엔진에 대해 엄격한 모드
- ANSI_QUOTES: MySQL에서는 문자열 값(리터럴)을 표현하기 위해 홑따옴표, 쌍따옴표 모두 가능한데 이 시스템 변수를 설정하면 홑따옴표만 문자열 값 표기로 사용할 수 있고, 쌍따옴표는 칼럼명이나 테이블명과 같은 식별를 표기하는데만 사용 가능
- ONLY_FULL_GROUP_BY: ONLY_FULL_GROUP_BY옵션이 활성화되면 GROUP_BY절이 사용된 문장의 SELECT 절에는 GROUP_BY절에 명시된 칼럼과 집계 함수(COUNT/SUM 등)만 사용할 수 있다. SELECT절에 집계 함수가 사용되는 경우에는 GROUP BY 절에 명시되지 않은 칼럼도 집계 함수의 인자로 사용할 수 있다
- PIPE_AS_CONCAT: "||"을 OR가 아닌 문자열 연결 연산자(CONCAT)으로 사용
- PAD_CHAR_TO_FULL_LENGTH: CHAR타입의 칼럼 값을 가져 올떄 뒤쪽의 공백이 제거되지 않고 반환
- NO_BACKSLASH_ESCAPE: 백슬래시를 이스케이프 문자로 사용하지 못하도록 함
- IGNORE_SPACE: 프로시저나 함수명과 괄호 사이의 공백은 무시. MySQL내장 함수에만 적용 되며, 이 시스템 변수가 적용되면 내장 함수는 모두 예약어로 간주되어 테이블이나 칼럼의 이름으로 사용될 수 없음
- REAL_AS_FLOAT: REAL타입이 DOUBLE의 동의어에서 FLOAT의 동의어로 바뀜
- NO_ZERO_IN_DATE & NO_ZERO_DATE: 이 두 옵션이 활성화 되면 "2020-00-00"같은 잘못된 날짜를 지정하지 못함
- ANSI: SQL표준에 맞게 동작하도록 REAL_AS_FLOAT, PIPE_AS_CONCAT, ANSI_QUOTES, IGNORE_SPACE, ONLY_FULL_GROUP_BY 모드를 모두 활성화
- TRANDITIONAL: STRICT_TRANS_TABLES, STRICT_ALL_TABLES, NO_ZERO_IN_DATE, NO_ZERO_DATE, ERROR_FOR_DIVISION_BY_ZERO, NO_IGNORE_SUBSTITUTION 모드의 조합

### 영문 대소문자 구분
- 설치된 운영체제에 따라 테이블명의 대소문자를 구분 하는데, 윈도우에 설치된 MySQL은 구분 하지 않지만 유닉스 계열의 MySQL에서는 구분 함
- lower_case_table_names 시스템 변수를 1로 설정 해서 모두 소문자로만 테이블이 저장되게 만들면 문제를 해결 가능

### MySQL 예약어
- 생성하는 데이터베이스나 테이블, 칼럼의 이름을 예약어와 같은 키워드로 생성하면 `나 " 로 감싸야함
- 이런 예약어를 모두 구분해서 기억하기 쉽지않으니 직접 만들어서 테스트 해보기를 권장

## MySQL 연산자와 내장 함수

### 리터럴 표기법 문자열
- 문자열: SQL표준에서 문자열은 항상 홑따옴표(')이지만 MySQL에서는 쌍따옴표도 가능. SQL 표준에서는 문자열 값에 홑따옴표가 포함 되어 있다면 홑따옴표를 두번 연속으로 입력해서 사용 가능하지만, MySQL에서는 쌍따옴표와 조합해서 사용도 가능. 키워드 충돌시 오라클이나 PostgreSQL에서는 쌍따옴표나 대괄호를 사용 하지만, MySQL에서는 역따옴표
- 숫자: 숫자 값을 상수로 SQL에 입력 할떄는 다른 DBMS와 마찬기지로 ', " 없이 숫자값을 입력. 문자열 형태로 비교 하더라도 비교 대상이 숫자값이나 숫자 타입의 칼럼이면 MySQL 서버가 자동으로 변환
- 날짜: DBMS에서 날짜 타입을 비교 하거나 INSERT 하려면 문자열을 DATE로변환하는 코드가 필요. MySQL에서는 정해진 날짜 포맷을 표기하면 MySQL서버가 자동으로 DATE나 DATETIME값으로 변환하기 떄문에 걱정없음
- 불리언: BOOL이나 BOOLEAN이라는 타입이 있지만 이것은 사실상 TINYINT 타입에 대한 동의어일 뿐. FALSE는 0, TRUE는 1. 이 이외의 값은 조회되지 않음

### MySQL 연산자
- 동등비교(=, <=>): 동등비교는 다른 DBMS와 마찬가지로 = 을 사용해 수행. <=>는 NULL값에 대한 비교도 수행하는 NULL-Safe 비교 연산자
- 부정비교(<>, !=): 같지 않다는 일반적으로 <> 많이 사용 하지만 !=도 사용. 통일해서 사용하는것을 권장
- NOT: 부정 연산. !도 사용 가능
- AND와 OR연산: MySQL에서는 AND와 OR이외에도 && 과 || 도 허용
- 나누기와 나머지 연산: 나누기는 /, 나눈 몫의 정수 부분만 가져오려면 DIV, 나머지만 가져오려면 % 또는 MOD
- REGEXP 연산: 문자열이 어떤 패턴을 만족하는지 확인하는 연산자. RLIKE는 REGEXP와 똑같은 비교를 수행하는 연산. REGEXP 연산자 좌측에 비교 대상 문자열, 우측에 검증하고자 하는 정규 표현식을 사용 해야함
- LIKE: 문자열 단순 패턴 비교 연산자. 인덱스를 이용해 처리 할 수 있음. 와일드 카드 문자가 검색어의 뒤에 있다면 인덱스 레인지 스캔이 가능 하지만, 검색어의 앞쪽에 있다면 인덱스 레인지 스캔 사용 불가
- BETWEEN 연산자: 다른 비교 조건과 결합해 하나의 인덱스를 사용할때 주의 해야함. 범위를 읽어야 하는 연산자라서, 조건에 맞는 모든 인덱스의 범위를 읽어야 하니 후속 조건이 범위를 줄이는 역할을 하지 못할수 있음. BETWEEN은 크다 작다 비교를 하나에 묶어둔것에 가까우며 IN은 동등 비교 연산자와 비슷해 이 둘은 처리 과정이 다름
- IN 연산자: 여러개의 값에 대해 동등비교 연산을 수행하는 연산자. 여러번의 동등 비교를 하는 것이기 때문에 일반적으로 빠르게 처리. NOT IN은 인덱스 풀 스캔으로 실행 계획이 표시 되는데, 동등이 아닌 부정형 비교여서 인덱스를 이용해 처리 범위를 줄이는 조건으로는 사용할 수 없기 떄문

### MySQL 내장 함수
- NULL값 비교 및 대체 (IFNULL, ISNULL): IFNULL()은 칼럼이나 표현식의 값이 NULL인지 비교하고, NULL이면 다른 값으로 대체하는 용도. ISNULL()은 인자로 전달한 표현식이나 칼럼의 값이 NULL인지 아닌지를 비교하는 함수
- 현재 시각 조회(NOW, SYSDATE): 하나의 SQL에서 NOW는 모두 같은 값을 갖지만, SYSDATE는 하나의 SQL내에서도 호출되는 시점에 따라 결과 값이 달라짐
- 날짜와 시간 포맷(DATE_FORMAT, STR_TO_DATE): DATETIME 타입의 칼럼이나 값을 원하는 문자열로 변환 해야 할때는 DATE_FORMAT(). 문자열을 DATETIME으로 변환 할떄는 DATE_FORMAT()
- 날짜와 시간의 연산(DATE_ADD, DATE_SUB): 특정 날짜에서 연도나 월일 또는 시간을 더하거나 뺄떄는 DATE_ADD나 DATE_SUB
- 타임스탬프 연산(UNIX_TIMESTAMP, FROM_UNIXTIME): UNIX_TIMESTAMP는 1970년 1월 1일 자정으로부터 경과된 초의 수를 반환하는 함수. FROM_TIMESTAMP는 인자로 전달한 DATETIME값을 DATETIME으로 반환함
- 문자열 처리 함수(RPAD, LPAD / RTRIM, LTRIM, TRIM): RPAD나 LPAD는 문자열의 좌측 또는 우측에 문자를 덧붙여 지정된 길이의 문자열로 만들고, RTIRM과 LTRIM은 문자열 우측 또는 좌측의 연속된 공백문자를 제거. TRIM은 LTRIM과 RTRIM을 동시에 수행
- 문자열 결합(CONCAT): 여러개의 문자열을 연결해서 하나의 문자열로 반환하는 함수
- GROUP BY 문자열 결합(GROUP_CONCAT): COUNT나 MAX, AVG등과 같은 그룹 함수. GROUP_BY와 함꼐 주로 사용하며 GROUP_BY가 없는 SQL에서 사용하면 단 하나의 결괏값만 만들어짐
- 값의 비교와 대체(CASE WHEN ... THEN ... END): 함수가 아니라 SQL 구문이지만, SWITCH와 같은 역할. CASE WHEN절이 일치하는 경우에만 THEN 이하의 표현이 실행된다는것을 이용해 불필요한 작업을 제거하기 위해 쓸수도 있음
- 타입의 변환(CASE, CONVERT): 프리페어드 스테이트먼트를 제외하면 SQL은 텍스트 기반으로 동작하기 떄문에 모든 입력값은 문자열로 취급되고 이떄 명시적인 타입 변환이 필요하다면 CAST 사용. CONVERT도 거의 비슷한데 함수의 인자 사용 규칙이 조금 다를 뿐
- 이진값과 16진수 문자열 변환(HEX, UNHEX): HEX함수는 이진값을 사람이 읽을 수 있는 형태의 16진수 문자열로 변환하는 함수. UNHEX는 16진수 문자열을 읽어서 이진값으로 변환하는 함수
- 암호화 및 해시 함수(MD5, SHA, SHA2): MD5와 SHA 모두 비대칭형 암호화 할고리즘. 인자로 전달한 문자열들을 각각 지정된 비트수의 해시 값을 만들어내는 함수
- 처리 대기(SLEEP): SQL의 개발이나 디버깅 용도로 잠깐 대기하거나 일부러 쿼리의 실행을 오랜시간 유지하고자 할때 사용
- 벤치마크(BENCHMARK): 반복해서 수행할 횟수와 표현식(스칼라 값 - 하나의 칼럼을 가진 하나의 레코드)를 입력 받아, 지정된 횟수만큼 반복을 실행하는데 얼마나 소요되었는지 확인. 벤르마크를 할떄와 실제 쿼리를 같은 횟수만큼 반복하는것과는 실행시간의 차이가 있으니 주의 해야함
- IP주소 변환(INET_ACTION, INET_NTOA): IPv4주소를 문자열이 아닌 부호 없는 정수 타입에 저장 하게 해줌. INET6_ATON/INET6_NTOA는 IPv6 주소용
- JSON포맷(JSON_PRETTY): JSON칼럼의 값을 읽기 쉬운 포맷으로 변환
- JSON필드 크기(JSON_STORAGE_SIZE): JSON은 텍스트 기반이지만 실제 디스크에 저장될때는 BSON(Binary JSON)을 사용. 하지만 BSON으로 변환됫을떄 저장 공간의 크기가 얼마나 될지 알기 힘드므로 JSON_STROAGE_SIZE 함수 사용
- JSON 필드 추출(JSON_EXTRACT): JSON도큐먼트에서 특정 필드의 값을 가져오는데 사용. 인자로 JSON도큐먼트 자체와 가져오가자 하는 필드의 JSON Path를 명시
- JSON 오브젝트 포함 여부 확인(JSON_CONTAINS): JSON 도큐먼트 또는 지정된 JSON 경로에 JSON 필드를 가지고 있는지 여부를 확인하는 함수. 첫번쨰 인자로 주어진 JSON 도큐먼트에서 두번쨰 인자의 JSON 오브젝트가 존재하는지를 검사. 세번째 선택적 인자로 해당 경로에 JSON 오브젝트가 있는지 여부 체크도 가능
- JSON 오브젝트 생성(JSON_OBJECT): RDBMS의 값을 사용해 JSON오브젝트를 생성하는 함수
- JSON 칼럼으로 집계(JSON_OBJECTAGG & JSON_ARRAYAGG): GROUP_BY와 함께 사용되는 집계 함수. RDBMS 칼럼의 값들을 모아 JSON 배열 또는 도큐먼트를 생성하는 함수
- JSON 데이터를 테이블로 변환(JSON_TABLE): JSON 데이터의 값들을 모아서 RDBMS 테이블을 만들어서 반환. JSON_TABLE함수가 만들어서 반환하는 테이블의 레코드 건수는 원본 테이블(JSON_TABLE 함수 직전에 명시한 테이블)과 동일한 레코드 건수