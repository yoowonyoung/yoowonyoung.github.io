---
layout: post
title: "Real MySQL 11 : 쿼리 작성 및 최적화"
description: Real MySQL 11장 - 쿼리 작성 및 최적화
date: 2022-02-06 15:06:00 +09:00
categories: MySQL RealMySQL Study
---

# 쿼리 작성 및 최적화

## 쿼리 작성과 연관된 시스템 변수

### SQL 모드
- sql_mode 시스템 변수에는 , 를 통해 여러 값이 동시에 할당 될 수 있음
- STRICT_ALL_TABLES & STRICT_TRANS_TABLES: MySQL서버에서 INSERT나 UPDATE 문장으로 데이터로 변경하는 경우, 타입이 다르다면 자동으로 타입 변경을 수행하는데, 이때 타입이 적절히 변환되기 어렵거나, 칼럼에 저장될 값이 없거나, 값의 길이가 칼럼의 최대 길이보다 큰 경우 문장을 계속 실행 시킬지 에러를 발생할지 결정. STRICT_TRANS_TABLES는 InnoDB같은 트랜잭션을 지원하는 스토리지 엔진에만 엄격한 모드, STRICT_ALL_TABLES는 모든 스토리지 엔진에 대해 엄격한 모드
- ANSI_QUOTES: MySQL에서는 문자열 값(리터럴)을 표현하기 위해 홑따옴표, 쌍따옴표 모두 가능한데 이 시스템 변수를 설정하면 홑따옴표만 문자열 값 표기로 사용할 수 있고, 쌍따옴표는 칼럼명이나 테이블명과 같은 식별를 표기하는데만 사용 가능
- ONLY_FULL_GROUP_BY: ONLY_FULL_GROUP_BY옵션이 활성화되면 GROUP_BY절이 사용된 문장의 SELECT 절에는 GROUP_BY절에 명시된 칼럼과 집계 함수(COUNT/SUM 등)만 사용할 수 있다. SELECT절에 집계 함수가 사용되는 경우에는 GROUP BY 절에 명시되지 않은 칼럼도 집계 함수의 인자로 사용할 수 있다
- PIPE_AS_CONCAT: "||"을 OR가 아닌 문자열 연결 연산자(CONCAT)으로 사용
- PAD_CHAR_TO_FULL_LENGTH: CHAR타입의 칼럼 값을 가져 올떄 뒤쪽의 공백이 제거되지 않고 반환
- NO_BACKSLASH_ESCAPE: 백슬래시를 이스케이프 문자로 사용하지 못하도록 함
- IGNORE_SPACE: 프로시저나 함수명과 괄호 사이의 공백은 무시. MySQL내장 함수에만 적용 되며, 이 시스템 변수가 적용되면 내장 함수는 모두 예약어로 간주되어 테이블이나 칼럼의 이름으로 사용될 수 없음
- REAL_AS_FLOAT: REAL타입이 DOUBLE의 동의어에서 FLOAT의 동의어로 바뀜
- NO_ZERO_IN_DATE & NO_ZERO_DATE: 이 두 옵션이 활성화 되면 "2020-00-00"같은 잘못된 날짜를 지정하지 못함
- ANSI: SQL표준에 맞게 동작하도록 REAL_AS_FLOAT, PIPE_AS_CONCAT, ANSI_QUOTES, IGNORE_SPACE, ONLY_FULL_GROUP_BY 모드를 모두 활성화
- TRANDITIONAL: STRICT_TRANS_TABLES, STRICT_ALL_TABLES, NO_ZERO_IN_DATE, NO_ZERO_DATE, ERROR_FOR_DIVISION_BY_ZERO, NO_IGNORE_SUBSTITUTION 모드의 조합

### 영문 대소문자 구분
- 설치된 운영체제에 따라 테이블명의 대소문자를 구분 하는데, 윈도우에 설치된 MySQL은 구분 하지 않지만 유닉스 계열의 MySQL에서는 구분 함
- lower_case_table_names 시스템 변수를 1로 설정 해서 모두 소문자로만 테이블이 저장되게 만들면 문제를 해결 가능

### MySQL 예약어
- 생성하는 데이터베이스나 테이블, 칼럼의 이름을 예약어와 같은 키워드로 생성하면 `나 " 로 감싸야함
- 이런 예약어를 모두 구분해서 기억하기 쉽지않으니 직접 만들어서 테스트 해보기를 권장

## MySQL 연산자와 내장 함수

### 리터럴 표기법 문자열
- 문자열: SQL표준에서 문자열은 항상 홑따옴표(')이지만 MySQL에서는 쌍따옴표도 가능. SQL 표준에서는 문자열 값에 홑따옴표가 포함 되어 있다면 홑따옴표를 두번 연속으로 입력해서 사용 가능하지만, MySQL에서는 쌍따옴표와 조합해서 사용도 가능. 키워드 충돌시 오라클이나 PostgreSQL에서는 쌍따옴표나 대괄호를 사용 하지만, MySQL에서는 역따옴표
- 숫자: 숫자 값을 상수로 SQL에 입력 할떄는 다른 DBMS와 마찬기지로 ', " 없이 숫자값을 입력. 문자열 형태로 비교 하더라도 비교 대상이 숫자값이나 숫자 타입의 칼럼이면 MySQL 서버가 자동으로 변환
- 날짜: DBMS에서 날짜 타입을 비교 하거나 INSERT 하려면 문자열을 DATE로변환하는 코드가 필요. MySQL에서는 정해진 날짜 포맷을 표기하면 MySQL서버가 자동으로 DATE나 DATETIME값으로 변환하기 떄문에 걱정없음
- 불리언: BOOL이나 BOOLEAN이라는 타입이 있지만 이것은 사실상 TINYINT 타입에 대한 동의어일 뿐. FALSE는 0, TRUE는 1. 이 이외의 값은 조회되지 않음

### MySQL 연산자
- 동등비교(=, <=>): 동등비교는 다른 DBMS와 마찬가지로 = 을 사용해 수행. <=>는 NULL값에 대한 비교도 수행하는 NULL-Safe 비교 연산자
- 부정비교(<>, !=): 같지 않다는 일반적으로 <> 많이 사용 하지만 !=도 사용. 통일해서 사용하는것을 권장
- NOT: 부정 연산. !도 사용 가능
- AND와 OR연산: MySQL에서는 AND와 OR이외에도 && 과 || 도 허용
- 나누기와 나머지 연산: 나누기는 /, 나눈 몫의 정수 부분만 가져오려면 DIV, 나머지만 가져오려면 % 또는 MOD
- REGEXP 연산: 문자열이 어떤 패턴을 만족하는지 확인하는 연산자. RLIKE는 REGEXP와 똑같은 비교를 수행하는 연산. REGEXP 연산자 좌측에 비교 대상 문자열, 우측에 검증하고자 하는 정규 표현식을 사용 해야함
- LIKE: 문자열 단순 패턴 비교 연산자. 인덱스를 이용해 처리 할 수 있음. 와일드 카드 문자가 검색어의 뒤에 있다면 인덱스 레인지 스캔이 가능 하지만, 검색어의 앞쪽에 있다면 인덱스 레인지 스캔 사용 불가
- BETWEEN 연산자: 다른 비교 조건과 결합해 하나의 인덱스를 사용할때 주의 해야함. 범위를 읽어야 하는 연산자라서, 조건에 맞는 모든 인덱스의 범위를 읽어야 하니 후속 조건이 범위를 줄이는 역할을 하지 못할수 있음. BETWEEN은 크다 작다 비교를 하나에 묶어둔것에 가까우며 IN은 동등 비교 연산자와 비슷해 이 둘은 처리 과정이 다름
- IN 연산자: 여러개의 값에 대해 동등비교 연산을 수행하는 연산자. 여러번의 동등 비교를 하는 것이기 때문에 일반적으로 빠르게 처리. NOT IN은 인덱스 풀 스캔으로 실행 계획이 표시 되는데, 동등이 아닌 부정형 비교여서 인덱스를 이용해 처리 범위를 줄이는 조건으로는 사용할 수 없기 떄문

### MySQL 내장 함수
- NULL값 비교 및 대체 (IFNULL, ISNULL): IFNULL()은 칼럼이나 표현식의 값이 NULL인지 비교하고, NULL이면 다른 값으로 대체하는 용도. ISNULL()은 인자로 전달한 표현식이나 칼럼의 값이 NULL인지 아닌지를 비교하는 함수
- 현재 시각 조회(NOW, SYSDATE): 하나의 SQL에서 NOW는 모두 같은 값을 갖지만, SYSDATE는 하나의 SQL내에서도 호출되는 시점에 따라 결과 값이 달라짐
- 날짜와 시간 포맷(DATE_FORMAT, STR_TO_DATE): DATETIME 타입의 칼럼이나 값을 원하는 문자열로 변환 해야 할때는 DATE_FORMAT(). 문자열을 DATETIME으로 변환 할떄는 DATE_FORMAT()
- 날짜와 시간의 연산(DATE_ADD, DATE_SUB): 특정 날짜에서 연도나 월일 또는 시간을 더하거나 뺄떄는 DATE_ADD나 DATE_SUB
- 타임스탬프 연산(UNIX_TIMESTAMP, FROM_UNIXTIME): UNIX_TIMESTAMP는 1970년 1월 1일 자정으로부터 경과된 초의 수를 반환하는 함수. FROM_TIMESTAMP는 인자로 전달한 DATETIME값을 DATETIME으로 반환함
- 문자열 처리 함수(RPAD, LPAD / RTRIM, LTRIM, TRIM): RPAD나 LPAD는 문자열의 좌측 또는 우측에 문자를 덧붙여 지정된 길이의 문자열로 만들고, RTIRM과 LTRIM은 문자열 우측 또는 좌측의 연속된 공백문자를 제거. TRIM은 LTRIM과 RTRIM을 동시에 수행
- 문자열 결합(CONCAT): 여러개의 문자열을 연결해서 하나의 문자열로 반환하는 함수
- GROUP BY 문자열 결합(GROUP_CONCAT): COUNT나 MAX, AVG등과 같은 그룹 함수. GROUP_BY와 함꼐 주로 사용하며 GROUP_BY가 없는 SQL에서 사용하면 단 하나의 결괏값만 만들어짐
- 값의 비교와 대체(CASE WHEN ... THEN ... END): 함수가 아니라 SQL 구문이지만, SWITCH와 같은 역할. CASE WHEN절이 일치하는 경우에만 THEN 이하의 표현이 실행된다는것을 이용해 불필요한 작업을 제거하기 위해 쓸수도 있음
- 타입의 변환(CASE, CONVERT): 프리페어드 스테이트먼트를 제외하면 SQL은 텍스트 기반으로 동작하기 떄문에 모든 입력값은 문자열로 취급되고 이떄 명시적인 타입 변환이 필요하다면 CAST 사용. CONVERT도 거의 비슷한데 함수의 인자 사용 규칙이 조금 다를 뿐
- 이진값과 16진수 문자열 변환(HEX, UNHEX): HEX함수는 이진값을 사람이 읽을 수 있는 형태의 16진수 문자열로 변환하는 함수. UNHEX는 16진수 문자열을 읽어서 이진값으로 변환하는 함수
- 암호화 및 해시 함수(MD5, SHA, SHA2): MD5와 SHA 모두 비대칭형 암호화 할고리즘. 인자로 전달한 문자열들을 각각 지정된 비트수의 해시 값을 만들어내는 함수
- 처리 대기(SLEEP): SQL의 개발이나 디버깅 용도로 잠깐 대기하거나 일부러 쿼리의 실행을 오랜시간 유지하고자 할때 사용
- 벤치마크(BENCHMARK): 반복해서 수행할 횟수와 표현식(스칼라 값 - 하나의 칼럼을 가진 하나의 레코드)를 입력 받아, 지정된 횟수만큼 반복을 실행하는데 얼마나 소요되었는지 확인. 벤르마크를 할떄와 실제 쿼리를 같은 횟수만큼 반복하는것과는 실행시간의 차이가 있으니 주의 해야함
- IP주소 변환(INET_ACTION, INET_NTOA): IPv4주소를 문자열이 아닌 부호 없는 정수 타입에 저장 하게 해줌. INET6_ATON/INET6_NTOA는 IPv6 주소용
- JSON포맷(JSON_PRETTY): JSON칼럼의 값을 읽기 쉬운 포맷으로 변환
- JSON필드 크기(JSON_STORAGE_SIZE): JSON은 텍스트 기반이지만 실제 디스크에 저장될때는 BSON(Binary JSON)을 사용. 하지만 BSON으로 변환됫을떄 저장 공간의 크기가 얼마나 될지 알기 힘드므로 JSON_STROAGE_SIZE 함수 사용
- JSON 필드 추출(JSON_EXTRACT): JSON도큐먼트에서 특정 필드의 값을 가져오는데 사용. 인자로 JSON도큐먼트 자체와 가져오가자 하는 필드의 JSON Path를 명시
- JSON 오브젝트 포함 여부 확인(JSON_CONTAINS): JSON 도큐먼트 또는 지정된 JSON 경로에 JSON 필드를 가지고 있는지 여부를 확인하는 함수. 첫번쨰 인자로 주어진 JSON 도큐먼트에서 두번쨰 인자의 JSON 오브젝트가 존재하는지를 검사. 세번째 선택적 인자로 해당 경로에 JSON 오브젝트가 있는지 여부 체크도 가능
- JSON 오브젝트 생성(JSON_OBJECT): RDBMS의 값을 사용해 JSON오브젝트를 생성하는 함수
- JSON 칼럼으로 집계(JSON_OBJECTAGG & JSON_ARRAYAGG): GROUP_BY와 함께 사용되는 집계 함수. RDBMS 칼럼의 값들을 모아 JSON 배열 또는 도큐먼트를 생성하는 함수
- JSON 데이터를 테이블로 변환(JSON_TABLE): JSON 데이터의 값들을 모아서 RDBMS 테이블을 만들어서 반환. JSON_TABLE함수가 만들어서 반환하는 테이블의 레코드 건수는 원본 테이블(JSON_TABLE 함수 직전에 명시한 테이블)과 동일한 레코드 건수

## SELECT

### SELECT절의 처리 순서
- SELECT절이란 키워드(SELECT, FROM, JOIN, WHERE, GROUP BY, HAVING, ORDER BY, LIMIT)와 그 뒤에 기술된 표현식을 말함

```mysql
SELECT s.emp_no, COUNT(DISTINCT e.first_name) AS cnt
FROM salaries s
    INNER JOIN employees e ON e.emp_no=s.emp_no
WHERE s.emp_no IN (10001, 10002)
GROUP BY s.emp_no
HAVING AVG(s.salary) > 1000
ORDER BY AVG(s.salary)
LIMIT 10;
```

- 위의 쿼리를 각 절로 나눠 보면 다음과 같다
    * SELECT 절: ```SELECT s.emp_no, COUNT(DISTINCT e.first_name) AS cnt```
    * FROM 절: ```FROM salaries s INNER JOIN employees e ON e.emp_no=s.emp_no```
    * WHERE 절: ```s.emp_no IN (10001, 10002)```
    * GROUP BY절: ```GROUP BY s.emp_no```
    * HAVING 절: ```HAVING AVG(s.salary) > 1000```
    * ORDER BY 절: ```ORDER BY AVG(s.salary)```
    * LIMIT 절: ```LIMIT 10```

- 실행 순서는 드라이브 테이블과 드리븐 테이블들을 읽으며 WHERE 및 조인이 먼저 적용 -> GROUP BY -> DISTINCT -> HAVING -> ORDER BY -> LIMIT
- SQL에 ORDER BY나 GROUP BY절이 있더라도 인덱스를 이용해 처리 할때는 그 단계가 불필요 하므로 생략 됨
- ORDER BY가 예외적으로 먼저 실행되는 경우도 있는데, 드라이브 테이블만 읽어서 정렬을 수행하고 드리븐 테이블을 읽는데 주로 GROUP BY절이 없이 ORDER BY만 사용되는 쿼리에서 보이는 모습
- 위의 실행 순서에서 벗어나는 쿼리가 필요 하다면 서브쿼리로 작성된 인라인 뷰를 사용해야 함. LIMIT을 GROUP BY 전에 실행하고자 할때도 마찬가지(인라인 뷰가 사용되면 임시 테이블이 사용되기에 주의)
- MySQL 8.0에 도입된 WITH절도 항상 제일 먼저 실행되어 임시 테이블로 저장

### WHERE 절과 GROUP BY 절, ORDER BY 절의 인덱스 사용
- 인덱스를 사용하기 위한 기본 규칙
    * WHERE절이나 ORDER BY 절 또는 GROUP BY가 인덱스를 사용 하려면 기본적으로 인덱스된 칼럼의 값 자체를 변환하지 않고 그대로 사용 한다는 조건을 만족 해야함
    * 복잡한 연산을 수행 한다거나 MD5() 함수와 같이 해시 값을 만들어서 비교해야 하는 경우라면 미리 계산된 값을 저장 하도록 MySQL의 가상 칼럼을 추가하고 그 칼럼에 인덱스를 생성하거나 함수 기반의 인덱스를 사용 해야 함
    * WHERE절에 사용 되는 비교 조건에서 연산자 양쪽의 두 비교 대상 값은 데이터 타입이 일치 해야 함

- WHERE절의 인덱스 사용
    * WHERE 조건이 인덱스를 사용하는 방법은 작업 범위 결정조건과 체크 조건의 두가지 방식
    * 작업 범위 결정 조건은 WHERE 절에서 동등 비교 조건이나 IN으로 구성된 조건에 사용된 칼럼들이 인덱스의 칼럼 구성과 좌측에서 부터 비교했을때 얼마나 일치 하는가에 따라 다름(WHERE조건절에 나열된 순사거 인덱스와 다르더라도 MySQL서버 옵티마이저는 최적화 가능)
    * WHERE 조건에 OR 연산자가 있으면 풀테이블 스캔이 발생할수 있으므로 주의

- GROUP BY 절의 인덱스 사용
    * GROUP BY절에 명시된 칼럼의 순서가 인덱스를 구성하는 칼럼의 순서와 같으면 GROUP BY는 일단 인덱스를 이용할 수 있음
        + GROUP BY절에 명시된 칼럼이 인덱스 칼럼의 순서와 위치가 같아야함
        + 인덱스를 구성하는 칼럼중 뒤쪽에 있는 칼럼은 GROUP BY절에 명시되지 않아도 인덱스를 사용 할 수 있지만, 앞쪽에 있는 칼럼이 GROUP BY에 없으면 안됨
        + GROUP BY절에 명시된 칼럼이 하나라도 인덱스에 없으면 안됨

    * WHERE 조건절에 칼럼이 동등 비교 조건으로 사용 된다면 GROUP BY 절에 해당 칼럼이 빠져도 인덱스를 이용한 GROUP BY가 가능할떄도 있음
        + WHERE 조건절에서 동등 비교 조건으로 사용된 칼럼을 GROUP BY 절로 옮겨서 똑같은 결과가 조회 된다면 WHERE절과 GROUP BY 절이 모두 인덱스를 사용할 수 있는 쿼리로 판단하면 됨

- ORDER BY 절의 인덱스 사용
    * ORDER BY절의 인덱스 사용 여부는 GROUP BY절과 거의 흡사하지만, 정렬되는 각 칼럼의 오름차순 및 내림차순 옵션이 인덱스와 같거나 정반대인경우에만 사용 가능
        + MySQL의 인덱스는 모든 칼럼이 오름차순으로만 정렬돼 있기 떄문에 ORDER BY 절의 모든 칼럼이 오름차순이거나 내림차순 일때만 인덱스를 사용 가능
        + 인덱스의 모든 칼럼이 ORDER BY절에 사용되야하는건 아니지만, ORDER BY절의 칼럼들이 인덱스에 정의된 칼러므이 왼쪽부터 일치해야함

- WHERE 조건과 ORDER BY(또는 GROUP BY)절의 인덱스 사용
    * WHERE 절과 ORDER BY절이 같이 사용된 하나의 쿼리 문장은 다음 3가지 방법중 한가지 방법으로만 인덱스를 이용
        + WHERE 절과 ORDER BY절이 동시에 같은 인덱스를 이용: WHERE 절의 비교 조건에사 사용하는 칼럼과 RODER BY절의 정렬 대상 칼럼이 모두 하나의 인덱스에 연속해서 포함돼 있을떄. 다른 2 방법보다 빠름
        + WHERE 절만 인덱스를 이용: ORDER BY절은 인덱스를 이용한 정렬이 불가능해서 인덱스를 통해 검색된 결과 레코드를 별도의 정렬 처리 과정(Using Filesort)을 거쳐서 수행. WHERE 절의 조건에 일치하는 레코드의 건수가 많지 않을떄 유용
        + ORDER BY 절만 인덱스 사용: ORDER BY 절의 순서대로 인덱스를 읽으면서 한건씩 WHERE 조건에 일치하는지 비교하고 일치하지 않을떄엔 버리는 형태로 처리. 아주 많은 레코드를 조회해서 정렬해야 할 때

- GROUP BY절과 ORDER BY 절의 인덱스 사용
    * GROUP BY와 ORDER BY가 같이 사용된 쿼리에서 둘중 하나라도 인덱스를 이용할 수 없을 때는 둘 다 인덱스를 사용하지 못함

- WHERE 조건과 ORDER BY 절, GROUP BY 절의 인덱스 사용
    * WHERE 절이 인덱스를 사용할 수 있는지 -> GROUP BY 절이 인덱스를 사용 할 수있는지 -> GROUP BY 절과 ORDER BY 절이 동시에 인덱스를 사용할 수 있는지 순서에 맞게 판단

### WHERE 절의 비교 조건 사용시 주의 사항
- NULL 비교
    * MySQL에서는 NULL값이 포함된 레코드도 인덱스로 관리. NULL을 하나의 값으로 인정한다는 뜻
    * 쿼리에서 NULL인지 아닌지 비교하려면 IS NULL을 사용 해야함
    * 칼럼의 값이 NULL인지 확인 하기 위해서 ISNULL 함수를 사용 해도 되지만, ```ISNULL(column)=1 ``` 이나, ```ISNULL(column)=true``` 같은 형태의 쿼리는 인덱스 레인지 스캔이 아닌 인덱스 풀스캔이나 테이블 풀스캔으로 처리됨에 주의

- 문자열이나 숫자 비교
    * 문자열이나 숫자칼럼 비교시 반드시 그 타임에 맞는 상숫값을 사용 해야 함. 문자열이면 문자열 리터럴, 숫자 타입이라면 숫자 리터럴

- 날짜 비교
    * DATE 또는 DATETIME과 문자열 비교: 문자열을 자동을 DATETIME 값으로 변환해서 비교 수행. MySQL이 내부적으로 변환을 수행 해주고, DATE나 DATETIME의 칼럼값을 변경하지 않는다면 인덱스도 잘 타짐
    * DATE와 DATETIME 비교: DATETIME값에서 시간부분을 뗴어버리고 비교를 하거나( DATE 함수이용), 그냥 비교 하면 MySQL서버가 DATE를 DATETIME으로 만들어줌. 인덱스 사용 여부에 영향을 미치지 않음
    * DATETIME과 TIMESTAMP 비교: UNIX_TIMESTAMP 함수의 결괏값은 MySQL 내부적으론 단순 숫자값임. 따라서 반드시 비교 값으로 사용되는 상수 리터럴을 비교 대상의 칼럼 타입에 맞게 변환해서 사용해야함

- Short-Cricuit Evaluation
    * MySQL 서버는 쿼리의 WHERE 절에 나열된 조건을 순서대로 Short-circuit Evaluation 방식으로 평가해서 해당 레코드를 반환해야 할지 말지를 결정
    * WHERE 조건중 인덱스를 사용 할 수 있는 조건이 있다면 Short-circuit Evaluation과는 무관하게 그 조건을 최우선으로 사용. 따라서 WHERE 조건절에 나열된 조건의 순서가 인덱스의 사용 여부를 결정하지는 않음
    * 쿼리를 작성할떄 가능한 복잡한 연산 또는 다른 테이블의 레코드를 읽어야 하는 서브 쿼리 조건등은 WHERE 저르이 뒤쪽으로 배치하는것이 성능상 도움이 됨

### DISTINCT
- 특정 칼럼의 유니크한 값을 조회 하기 위해 DISTINCT를 사용 하지만, 레코드가 중복으로 출력되는걸 막기 위해서도 사용하기도 함
- DISTINCT는 성능의 문제도 있지만 쿼리의 결과도 의도와 달라 질 수 있으니 주의

### LIMIT n
- MySQL의 LIMIT은 조건이 아니기 때문에 쿼리의 항상 가장 마지마겡 실행
- LIMIT의 가장 중요한 특성이 LIMIT에서 필요한 레코드 건수만 준비 되면 즉시 쿼리를 종료 한다는것
- 쿼리 문장에 GROUP BY나 ORDER BY 같은 전체 범위 작업이 선행 되더라도 LIMIT절이 있다면 크진 않지만 나름의 성능 향상이 있을 순 있음 
- LIMIT의 인자로 표현식이나 별도 서브쿼리는 사용 불가함에 주의

### COUNT
- COUNT는 결과 레코드의 건수를 반환하는 함수로, 칼럼이나 표현식을 인자로 받으며 *(레코드 자체를 의미) 도 가능
- InnoDB 스토리지 엔진을 사용하는 테이블에서 WHERE 조건이 없는 COUNT(*) 쿼리라도 직접 데이터나 인덱스를 읽어야만 레코드 건수를 가저올 수 있기 때문에 큰 테이블에서 COUNT를 사용하는것은 주의
- COUNT절에서 ORDER BY 절은 어떤 경우에도 필요하지 않으니 포함시키지 않도록 주의
- SELECT 하는 쿼리보다 COUNT 쿼리가 훨씬 더 빠르게 실행될것이라고 생각하지만, 인덱스를 제대로 사용하도록 튜닝되지 못한 COUNT 쿼리는 페이징을 해서 데이터를 가져오는 쿼리보다 몇배 또는 몇십배 더 느릴수 있음
- COUNT함수에 컬럼명이나 표현식이 인자로 사용되면 그 칼럼이나 표현식의 결과가 NULL이 아닌 레코드 건수만 반환

### JOIN
- JOIN의 순서와 인덱스
    * 조인 작업에서 드라이빙 테이블을 읽을때는 인덱스 탐색작업을 단 한번만 수행하고, 그 이후부터는 스캔만 하면 됨
    * 드리븐 테이블에서는 인덱스 탐색 작업과 스캔 작업을 드라이빙 테이블에서 읽은 레코드 건수만큼 반복. 따라서 옵티마이저는 항상 드리븐 테이블을 최적으로 읽을 수 있게 실행 계획을 수립

- JOIN 칼럼의 데이터 타입
    * 조인 칼럼간의 비교에서 각 칼럼의 데이터 타입이 일치하지 않으면 인덱스를 효율적으로 사용할 수없음
    * 인덱스 사용에 영향을 미치는 데이터 타입 불일치는 CHAR 타입과 VARCHAR타입, INT와 BIGINT타입, DATE와 DATETIME사이에선 발생하지 않으나, 같은 INT라도 부호 존재 여부가 다른 경우, 같은 CHAR라도 문자 집합이나 콜레이션이 다른 경우드엔 발생 한다

- OUTER JOIN 성능과 주의사항
    * 테이블 데이터가 일관되지 않은 경우에만 아우터 조인이 필요함
    * MySQL 옵티마이저는 절대로 아우터 조인 되는 테이블을 드라이빙 테이블로 선택하지 못함. 이너조인으로 사용해도 되는 쿼리를 아우터 조인으로 작성하면 MySQL 옵티마이저가 조인 순서를 변경하며 수행할 수 있는 최적화 기회를 뻇는것
    * OUTER로 조인되는 테이블에 대한 조건을 WHERE에 포함 시켜도 안됨. INNER JOIN으로 변환해서 실행해버리기 때문. ON 절로 옮겨야함
    * 예외적으로 안티조인 효과를 기대하는 경우에만 OUTER JOIN으로 연결되는 테이블의 칼럼에 대한 조건을 WHERE 절에 사용 해야 함

- JOIN과 외래키
    * SQL로 테이블간의 조인을 수행하는것은 전혀 무관한 칼럼을 조인 조건으로 사용해도 문법적으로 문제는 없음

- 지연된 조인
    * 조인을 하면 대체적으로 결과 레코드 건수가 늘어나기 때문에 조인의 결과를 GROUP BY 하거나 ORDER BY 하면 조인 실행 하기 전의 레코드에 GROUP BY 나 ORDER BY 를 수행하는것보다 더 많은 레코드를 처리 해야함
    * 지연된 조인이란 조인이 실행되기 이전에 GROUP BY 나 ORDER BY를 처리하는 방식. 주로 LIMIT이 함께 사용된 쿼리에서 더 큰 효과
    * OUTER JOIN과 INNER JOIN에 대해 다음과 같은 조건이 갖춰져야만 지연된 쿼리로 변경 가능
        + LEFT (OUTER) JOIN인 경우 드라이빙 테이블과 드리븐 테이블은 1:1 또는 M:1 관계여야함
        + INNER JOIN인 경우 드라이빙 테이블과 드리븐 테이블은 1:1 또는 M:1의 관계임과 동시에 드라이빙 테이블에 있는 레코드는 모두 드리븐 테이블에 존재 해야 함

- 래터럴 조인
    + MySQL 8.0 부터는 레터럴 조인이라는 기능을 이용해 특정 그룹별로 서브 쿼리를 실행해서 그 결과와 조인 하는것이 가능해짐
    + 래터럴 조인에서 가장 중요한 부분은 FROM절에 사용된 서브 쿼리에서 외부 쿼리의 FROM절에 정의된 테이블의 칼럼을 참조 할 수 있다는 점

- 실행 계획으로 인한 정렬 흐트러짐
    + 쿼리의 실행 계획에서 네스티드 루프 조인 대신 해시 조인이 사용 되면 쿼리 결과의 레코드 정렬 순서가 달라짐. 블록 네스티드 루프 조인이 사용 되는 경우에도 동일
    + 정렬된 결과가 필요한 경우라면 드라이빙 테이블의 순서에 의존하지 말고 ORDER BY 절을 명시적으로 사용하는게 좋음

### GROUP BY
- WITH ROLLUP
    + GROUP BY가 사용된 쿼리에서 그루핑된 그룹별로 소계를 가져올 수 있는 롤업 기능. 단순히 최종 합만 가져오는게 아니라 GROUP BY에 사용된 칼럼의 갯수에 따라 소계의 레벨이 달라짐
    + 소계나 총계 레코드는 항상 해당 그룹의 맨 마지막에 나타남
    + MySQL 8.0 부터는 그룹 레코드에 표시되는 NULL을 사용자가 변경할 수 있게 GROUPING 함수를 지원

- 레코드를 칼럼으로 변환해서 조회
    + 레코드를 칼럼으로 변환: GROUP BY 쿼리의 결과를 COUNT/MIN/MAX/AVG/SUM 구문을 사용해 한번 더 변환하면 됨
    + 하나의 칼럼을 여러 칼럼으로 분리: SUM(CASE WHEN)등을 사용

### ORDER BY
- ORDER BY 절이 없는 SELECT 쿼리 결과의 순서는 처리 절차에 따라 달라질수도 있음
- ORDER BY 사용법 및 주의사항
    + 일반적으로 정렬한 대상은 칼럼명이나 표현식으로 명시 하지만 SELECT 되는 칼럼의 순번도 명시 가능
    + ORDER BY 다음 문자열 상수를 사용하는 경우에는 옵티마이저가 ORDER BY 절 자체를 무시

- 여러 방향으로 동시에 정렬
    + MySQL 8.0 부터 오름 차순과 내림 차순으로 혼합해서 인덱스를 생성할 수 있게 됨. 따라서 여러개의 칼럼을 조합해서 정렬할떄 각 칼럼의 정렬 순서가 오름차순과 내림차순이 혼용되도 인덱스 사용 가능

- 함수나 표현식을 이용한 정렬
    + MySQL 8.0부터는 함수 기반의 인덱스를 지원 하므로, 연산의 결괏값을 기준으로 정렬하는 작업이 인덱스를 사용 하도록 튜닝하는것도 가능

- 서브쿼리
    + SELECT절에 사용된 서브쿼리
        * SELECT절에 사용된 서브쿼리는 내부적으로 임시테이블을 만들거나 쿼리를 비효츌적으로 실행하게 만들지는 않기에 서브쿼리가 적절히 인덱스를 사용할 수 있다면 크게 주의 해야할것은 없음
        * 일반적으로 SELECT절에 서브쿼리를 사용하면 그 서브쿼리는 항상 칼럼과 레코드가 하나인 결과를 반환 해야함
        * 조인으로 처리해도 되는 쿼리를 SELECT절의 서브쿼리를 사용해서 작성할 때도 있는데, 조인으로 처리하는게 더 빠르므로 가능하다면 조인으로 쿼리를 작성

    + FROM절에 사용된 서브쿼리
        * MySQL 5.7 부터는 옵티마이저기 FROM절의 서브쿼리를 외부 쿼리로 병합하는 최적화를 수행하도록 개선
        * FROM절의 모든 서브쿼리를 외부 쿼리로 병합 할수 있는것은 아님 ( 집합함수, DISTINCT, GROUP BY, HAVING, LIMIT, UNION, SELECT절에 서브쿼리, 사용자 변수가 사용되며 사용자 변수에 값이 할당되는 경우는 부락 )
        * 외부쿼리와 병합되는 FROM절의 서브쿼리가 ORDER BY절을 가진 경우에는 외부 쿼리가 GROUP BY나 DISTINCT같은 기능을 사용하지 않는다면 서브 쿼리의 정렬 조건을 외부 쿼리로 같이 병합

    + WHERE 절에 사용된 서브쿼리
        * 동등 또는 크다 작다 비교 - 서브쿼리를 먼저 실행한 후 상수로 변환한 후 상숫값으로 서브 쿼리를 대체해서 나머지 쿼리 부분을 처리. 단일값 비교가 아닌 튜플 비교 방식은 서브쿼리가 먼저 처리되어 상수화 되긴 하지만 외부 쿼리는 인덱스를 사용하지 못하고 풀테이블 스캔
        * IN 비교 - 테이블의 레코드가 다른 테이블의 레코드를 이용한 표현식과 일치하는지 체크하는 형식이여서 세미조인 이라고 함. 테이블 풀 아웃, 퍼스트 매치, 루스 스캔, 구체화, 중복 제거의 최적화 기법
        * NOT IN 비교 - 안티 세미 조인, NOT EXIST, 구체화의 최적화 방법. WHERE절에 단독으로 안티세미조인만 있다면 풀 테이블 스캔을 피할 수 없음

### CTE(Common Table Expression)
- CTE는 이름을 가지는 임시테이블로 SQL문장 내에서 한번 이상 사용될 수있으며 SQL 문장이 종료되면 자동으로 CTE 임시 테이블은 삭제됨
- 비 재귀적 CTE
    * MySQL에서는 WITH를 이용해 CTE를 정의
    * 임시 테이블이 한번만 사용되기 떄문에 FROM절의 서브쿼리로 변경 가능
    * CTE로 생성된 임시 테이블은 다른 CTE쿼리에서 참조 가능. 재사용 가능하기 떄문에 FROM절의 서브쿼리보다 효율적

- 재귀적 CTE 
    * 비 재귀적 쿼리 파트와 재귀적 파트로 구분되며 이 둘을 반드시 UNION(UNION DISTINCT)또는 UNION ALL로 연결하는 형태로 쿼리를 작성해야함
    * CTE임시 테이블의 구조는 CTE 쿼리의 비 재귀적 쿼리 파트의 결과로 결정
    * 재귀적 쿼리 파트를 실행 할 때는 지금까지 모든 단계에서 만들어진 결과 셋이 아니라 직전 단계의 켤과만 재귀 쿼리의 입력으로 사용
    * 실제 재귀 쿼리가 반복을 멈추는 조건은 재귀 파트 쿼리의 결과가 0건이 될 때까지(cte_max_recursion_depth 시스템 변수로 최대 반복 실행 횟수 제한 가능)

### 윈도우 함수
- 윈도우 함수는 조회하는 현재 레코드를 기준으로 연관된 레코드 집합의 연산을 수행
- 윈도우 함수는 조건에 일치하는 레코드 건수는 변하지 않고 그대로 유지하는데 이것이 집계 함수와 가장 큰 차이. 즉, 윈도우 함수는 결과 집합을 그대로 유지 하면서 하나의 레코드 연산에 다른 레코드의 칼럼값을 참조 가능
- 쿼리 각 절의 실행 순서
    * WHERE, FROM, GROUP BY, HAVING -> 윈도우 함수 -> SELECT, ORDER BY, LIMIT
    * 이 순서를 벗어나는 쿼리를 작성하고자 한다면 FROM 절의 서브쿼리(Derived Table)을 사용 해야 함

- 윈도우 함수 기본 사용법
    * 윈도우 함수는 용도별로 다양한 함수들을 사용할 수 있는데, 집계 함수와는 달리 함수 뒤에 OVER 절을 이용해 연산 대상을 파티션 하기 위한 옵션을 명시 할 수 있음. 이렇게 OVER절에 의해 만들어진 그룹을 파티션 또는 윈도우 라고 함
    * 윈도우 함수의 각 파티션 안에서도 연산 대상 레코드별로 연산을 수행할 소그룹이 사용 되는데 이를 프레임 이라고 함
    * 프레임을 만드는 기준은 ROWS / RANGE 이며 시작과 끝을 의미하는 키워드들은 CURRENT ROW, UNBOUNDED PRECEDING 등이 있음
    * 일부 윈도우 함수들은 프레임이 미리 고정되어 있고, SQL문장에서 프레임을 명시해도 무시되어 파티션의 전체 레코드가 되는 경우도 있음(CUME_DIST, DENSE_RANK, LAG, LEAD, NTILE, PRECENT_RANK, RANK, ROW_NUMBER)
    
- 윈도우 함수
    * 윈도우 함수에는 집계함수와 비 집계함수를 모두 사용할 수 있는데, 집계 함수는 GROUP BY절과 함께 사용할 수 있는 함수로 OVER절 없이 단독으로도 사용 될 수 있고 OVER절을 가진 윈도우 함수들로도 사용할 수 있지만, 비 집계 함수는 반드시 OVER절을 가져야 함
    * DENSE_RANK와 RANK, ROW_NUMBER: DENSE_RANK, RANK 모두 ORDER BY 기준으로 매겨진 순위. RANK는 동점이 있으면 그 다음을 동점자 만큼 증가시킨 순위로 반환하지만 DENSE_RANK는 연속된 순위. ROW_NUMBER는 동점에대한 고려 없이 정렬된 순서대로 레코드 번호를 부여
    * LAG와 LEAD: LAG는 파티션 내에서 현재 레코드를 기준으로 N번째 이전 레코드 반환, LEAD는 N번쨰 이후 반환

- 윈도우 함수 성능
    * 쿼리 요건에 따라 GROUP BY나 다른 기존 기능으로 윈도우 함수를 대체할 수 없는 경우를 제외하곤 윈도우 함수에 의존하지 않는게 좋음
    * 윈도우 함수는 느림

### 잠금을 사용하는 SELECT
- FOR SHARE는 SELECT로 읽은 레코드에 대해서 읽기 잠금을 걸고, FOR UPDATE는 SELECT쿼리가 읽은 레코드에 대해서 쓰기 잠금을 검
- 잠금 옵션은 모두 AUTO-COMMIT이 비 활성화 된 상태 또는 BEGIN 명령이나 START TRANSACTION으로 트랜잭션이 시작된 상태에서만 잠금이 유지
- 특정 레코드가 잠겨진 상태라도 FOR SHARE나 FOR UPDATE 절을 가지지 않은 단순 SELECT는 아무런 대기 없이 실행
- 잠금 테이블 실행
    * OF "테이블" 절이 없다면 쿼리 구문 내에 모든 테이블에 잠금이 걸림

- NOWAIT & SKIP LOCKED
    * NOWAIT: SELECT쿼리가 해당 레코드에 대해 즉시 잠금을 획득 하였다면 NOWAIT 옵션이 없을때와 동일 하지만, 해당 레코드가 다른 트랜잭션에 의해 잠긴 상태라면 에러를 반환하며 종료
    * SKIP LOCKED: SELECT 하려는 레코드가 다른 트랜잭션에 의해 이미 잠겨진 상태라면 무시하고 잠금이 걸리지 않은 레코드만 가져옴
    * NOWAIT과 SKIP LOCKED는 쿼리 자체를 비 확정적으로 만들기 때문에 UPDATE나 DELETTE 문장에 사용된다면 실행될 떄 마다 데이터베이스의 상태를 다른 결과로 만들기 때문에 SELECT 에서만 가능

## INSERT

### 고급 옵션
- INSERT IGNORE
    * 저장하는 레코드의 프라이머리 키나 유니크 인덱스 칼럼의 값이 이미 테이블에 존재하는 레코드와 중복된 경우, 저장하는 레코드 칼럼이 테이블 칼럼과 호환되지 않는 경우 모두 무시하고 다음 레코드 처리
    * INSERT 하고자 하는 데이터가 정교하지 않아도 되는 경우 INSERT 이전에 중복체크를 하지 않고 INSERT IGNORE로 처리 하는 방식으로 자주 사용

- INSERT ON DUPLICATED KEY UPDATE
    * 프라이머리키나 유니크 인덱스의 중복이 발생하면 UPDATE 문장의 역할 수행. REPLACE(DELETE와 INSERT의 조합으로 작동)와 달리 기존 레코드 삭제 대신 업데이트가 이뤄짐

### LOAD DATA 주의사항
- LOAD DATA는 INSERT에 비교해 매우 빠르다는 장점이 있지만, 단일 스레드 & 단일 트랜잭션으로 실행된다는 단점이 있음. 데이터가 매우 커서 실행시간이 아주 길어진다면 다른 온라인 트랜잭션 쿼리들의 성능에 영향이 감
- 가능하다면 LOAD DATA로 적재할 데이터 파일을 하나 보다는 여러개로 준비해서 LOAD DATA 문장을 여러 트랜잭션으로 나뉘어 실행되게 하는것이 좋음

### 성능을 위한 테이블 구조
- 대량 INSERT 성능: 프라이머리 키값을 기준으로 미리 정렬해서 INSERT 문장을 구성하는게 좋음
- 프라이머리 키 선정: SELECT는 거의 실행되지 않고 INSERT가 매우 많이 실행되는 테이블이라면 프라이머리 키를 단조 증가 또는 단조 감소하는 패턴의 값을 쓰는게 좋고, 인덱스 갯수를 최소화 하는게 좋음
- Auto-Increment칼럼: Auto-Increment 칼럼을 이용하면 클러스터링 되지 않는 테이블의 효과를 얻을 수 있음. 자동 증가 값을 프라이머리 키로 해서 테이블을 생성하는것은 MySQL서버에서 가장 빠른 INSERT를 보장하는 방법