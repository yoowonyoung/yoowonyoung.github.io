---
layout: post
title: "SK Telecome Interview"
description: SK Telecome Interview
date: 2020-07-25 12:25:00 +09:00
categories: Interview
---

# 코딩테스트
1. 두 int의 곱을 2진수로 나타냈을때 1의 갯수를 반환하는 함수 만들기
- 문제에서 중요한것은 정확도 였음
- 손으로 직접 2진수 변환을 하는것보단 라이브러리를 활용 하는것이 실수를 줄일 수 있을것이라 판단해서 ```toBinaryString``` 을 사용
- int 끼리의 곱셈에서 overflow가 발생 할 수 있기 때문에 Long으로 캐스팅 해서 곱셈
- 계산 결과로 나온 값을 ```toBinaryString``` 으로 변환 후 ```toCharArray```로 배열로 바꿔서 배열 원소를 하나씩 확인 1의 갯수를 세서 return


2. 던진 주사위의 눈들과, 잊어버린 주사위의 갯수, 주사위 눈 합의 평균을 입력받아, 잊어버린 주사위들의 경우중 하나를 반환하는 함수 만들기
- 문제에서 중요한것은 효율성 이였음
- 하지만 문제 자체가 경우의 수 문제였기 때문에 전체를 탐색해볼 필요가 있다고 판단, dfs를 통해 경우의수를 만들면서 적절한 가지치기를 하기로 계획
- 평균 * 주사위를 던진 총 횟수를 통해 주사위 눈의 총합을 구한 후, 알고 있는 주사위 눈의 값들을 빼서 남은 주사위 눈의 총 합을 구함
- dfs를 통해 주사위를 하나씩 던져가며 적절한 가지치기를 통해 경우가 완성되면 바로 탐색을 종료 하도록 만듬
    * dfs종료 조건 : 잊어버린 눈 숫자만큼 주사위를 던졌을 때, 그떄까지 나온 눈의 합이 남은 주사위 눈의 총합과 같을 경우 종료
    * 가지치기1 : 남은 주사위 눈의 합 / 남은 주사위 던진 횟수 가 6을 넘길 경우 종료 -> 불가능한 케이스기 때문
    * 가지치기2 : 전체 flag를 하나 두어, 한 탐색에서 답이 구해졌을 경우 더이상 다른 탐색을 진행 하지 않도록함

```java
    static ArrayList<Integer> res = new ArrayList<Integer>();
    static int maxStep = 0;
    static boolean end = false;
    public static int[] solution(int[] A, int F, int M) {
        maxStep = F;
        int totalRoll = A.length + F;
        int sum = (totalRoll * M);
        int wantSum = sum;

        for(int i = 0 ;i<F;i++) {
            res.add(0);
        }
        for(int i = 0 ;i<A.length;i++) {
            wantSum -= A[i];
        }
        dfs(0,wantSum);

        int[] ret = new int[res.size()];
        for(int i = 0 ;i<ret.length;i++) {
            ret[i] = res.get(i);
        }
        return ret;
    }
    public static void dfs(int pos, int left) {
        if(end) return;
        if(pos == maxStep) {
            if(left != 0) return;
            end = true;
            return;
        }
        int leftNum = maxStep - pos;
        int min = left / leftNum;

        if(min > 6) return;

        for(int i = (int)Math.floor(min); i<=6;i++) {
            res.set(pos,i);
            dfs(pos+1, left - i);
        }

    }
```


3. a와 b로 이루어진 문자열을 입력받아 3등분 했을 때, 각 부분 문자열에 a의 갯수가 모두 같은 부분문자열의 갯수를 구하는 문제
- 문제에서 중요하게 여겼던건 효율성 이였음
- 먼저 문제에서 규칙성을 파악 하려고 했고, 그렇게 파악한 문제의 규칙은 아래와 같았음
    * 입력받은 a의 갯수에 따라 a의 갯수가 0일때, a의 갯수가 3의 배수일때, a의 갯수가 3의 배수가 아닐떄 3개로 나뉨
    * a의 갯수가 0이면 그냥 문자열을 3개로 나누는 것이였음. 이는 조합 공식을 이용하면 해결 가능했음
    * a의 갯수가 3의 배수가 아니면 문제의 성립이 불가능. 0 반환
    * a의 갯수가 3의 배수일 때 경우의 수를 구하는 공식은 다음과 같음
        + 먼저 a의 갯수를 3으로 나눠서 몫 n을 구함
        + n 번째 a와 n+1번째 a 사이의 b 갯수를 구함 => b1
        + 2n 번째의 a와 2n+1번째 a 사이의 갯수를 구함 => b2
        + (b 1+ 1) * (b2 + 1) 하면 경우의 수가 나옴

- 위의 규칙성에 따라 먼저 입력받은 문자열을 검사해서 a의 갯수를 세었고, a의 갯수에 따라서 각 규칙성을 구현한 로직을 따르도록 만듬


# 프로젝트 정리
- Docker: 컨테이너 기반의 오픈소스 가상화 플랫폼. 다양한 프로그램, 실행 환경등을 컨테이너로 추상화 하고 동일한 인터페이스를 제공해 프로그램의 배포 및 관리를 단순화
    * 기존 가상화와 달리 process를 격리시켜서 가상화 하는것이 도커의 핵심
    * 이렇게 격리된 공간에서 프로세스가 동작하는것이 컨테이너
    * 도커 이미지란 컨테이너 실행에 필요한 파일과 설정값 등을 포함하고 있는것으로 생태 값을 가지지 않고 변하지 않음
    * 컨테이너는 이미지를 최초 실행한 상태라고 볼 수 있고, 이후 변하는 값은 컨테이너에 저장되며 컨테이너의 상태가 바뀌거나 삭제되도 이미지는 불변
    * 도커 이미지를 만들기 위해 Dockerfile이라는 파일에 DSL을 통해 이미지 생성 과정을 적음
    * 이 Dockerfile을 관리 함으로써 의존성 패키지 설치 및 설정파일 만들기 같은 과정을 관리 할 수 있게 됨

- REST API: REST라는 HTTP기반으로 필요한 자원에 접근하는 방식을 정해놓은 아키텍처를 구현한 API들을 말함
    * REST의 4개 속성
        + 서버에 있는 모든 Resource는 각 Resource당 클라이언트가 바로 접근 할 수 있는 고유 URL이 존재
        + 모든 요청은 클라이언트가 요청 할 때 마다 필요한 정보를 주기 떄문에 서버에서는 세션 정보를 보관할 필요가 없음
        + 모든 Resource는 http인터페이스인 GET/POST/PUT/DELETE 4개의 메소드로 접근 가능해야함
        + 서비스내에 하나의 resource가 주변에 연관된 리소스들과 연결되어 표현이 되어야함
    * REST의 구성요소 3가지
        + Resource: REST에서 자원에 접근 할 떄 URI로 접근 하게 되며, URI 설계시 기본 설계 규칙 ( /는 계층 관계를 나타냄, _ 보다 - , 소문자 사용, 파일 확장자는 포함하지 않기 등) 을 따른다
        + HTTP메소드: POST(생성), GET(조회), PUT(수정), DELETE(삭제)
        + 메시지: 메시지는 HTTP 헤더와 바디, 응답상태코드로 구성되어 있으며, 헤더와 바디에 포함된 메시지는 메시지를 처리하기 위한 충분한 정보를 포함한다. 바디에는 자원에 대한 정보를, 헤더에는 바디에 어떤 포맷으로 데이터가 담겼는지를 정의

- Provisioning: 사용자 혹은 비즈니스 요구사항에 맞게 자원을 할당, 배치, 배포하여 시스템을 사용 가능하도록 준비하는것
    * 서버 자원 프로비저닝, OS 프로비저닝, 소프트웨어 프로비저닝, 스토리지 프로비저닝, 계정 프로비저닝등의 종류가 존재
    * 이 중 소프트웨어 프로비저닝을 Ansible을 통해서 구현 했음

- Ansible: 환경 구성 자동화 도구로, 환경의 배포와 구성을 규격화된 코드로 정의해서 사용 하는 것. 인프라의 상태를 코드로 선언하고 이를 모든 서버에 배포함으로써 특정 환경을 동일하게 유지 시킬 수 있도록 도움
    * 인벤토리: Ansible에 의해 제어되는 서버들의 목록
    * 플레이북: yaml포맷으로 되어있어, 인벤토리에 정의된 서버에서 어떤 일을 해야 할지를 정의 해놓은 파일
    * 모듈: 플레이북의 task가 어떻게 수행 될 지를 나타내는 요소
    * Ansible은 동일한 플레이북을 사용한다면 멱등성이 보장됨

- CI/CD: Continouse Integration + Continouse Deployment. 지속적인 통합과 지속적인 배포. 빌드 자동화 및 자동화된 유닛테스트 등으로 통합된 코드를 프로덕션으로 릴리즈
  