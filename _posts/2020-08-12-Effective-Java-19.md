---
layout: post
title: "Effective Java - 아이템19: 상속을 고려해 설계하고 문서화 하라. 그러지 않았다면 상속을 금지하라"
description: 상속을 고려해 설계하고 문서화 하라. 그러지 않았다면 상속을 금지하라
date: 2020-08-12 22:49:00 +09:00
categories: EffectiveJava Study
---


# 클래스와 인터페이스

## 아이템 19 : 상속을 고려해 설계하고 문서화 하라. 그러지 않았다면 상속을 금지하라

- 상속을 고려한 설계와 문서화에 대해 알아보자
- 먼저 메서드를 재정의 하면 어떤 일이 일어나는지를 정확히 정리하여 문서로 남겨야 한다. 상속용 클래슨느 재정의 할 수 있는 메서드 들을 내부적으로 어떻게 이용하는지(자기사용) 문서로 남겨야한다
- 클래스의 API로 공개된 메서드에서 클래스 자신의 다른 메서드를 호출할 수 있다. 그때, 호출되는 메서드가 재정의 가능한 메서드라면 그 사실을 호출하는 API설명에 적시 해야 한다
    * 어떤 순서로 호출 되는지, 각각의 호출 결과가 이어지는 처리에 어떤 영향을 주는지도 담아야 한다
    * 재정의 가능 메서드를 호출할 수 있는 모든 상황을 문서로 남겨야 한다

- API문서의 메서드 설명 끝에서 종종 "Implementation Requirement"로 시작하는 부분을 볼 수 있는데, 그 메서드 내부 동작방식을 설명하는 곳이다
    * 이러한 부분은 @implSpec 태그를 달아주면 자바독 도구가 생성해준다
    * 다음은 java.util.AbstractCollection 의 일부이다
        + Implementation Requirements: 이 메서드는 컬렉션을 순회하며 주어진 원소를 찾도록 구현되어있다. 주어진 원소를 찾으면 반복자의 remove 메서드를 사용해 컬렉션에서 제거한다.
        이 컬렉션이 주어진 객체를 갖고 있으나, 이 컬렉션의 iterator 메서드가 반환한 반복자가 remove를 구현하지 않았다면 UnsupportedOperationException을 던진다
    
    * 이 설명에 따르면 iterator 메서드를 재정의 하면 remove 메서드의 동작에 영향을 줌을 확실히 알 수 있다

- 이러한 기술은 "좋은 API 문서란 어떻게가 아닌 무엇을 하는지를 설명해야한다"라는 격언과 대치된다. 상속이 캡슐화를 해치기 떄문에 일어나는 안타까운 현실이다
- 이처럼 내부 매커니즘을 문서로 남기는것만이 상속을 위한 설계의 전부는 아니다
- 효율적인 하위 클래스를 큰 어려움 없이 만들 수 있게 하려면, 클래스의 내부 동작 과정 중간에 끼어들 수 있는 훅(hook)을 잘 선벌하여 protected 메서드 형태로 공개 해야 할 수도 있다(드물게 protected 필드로 공개 해야할수도 있다)
- java.util.AbstractList의 removeRange는 좋은 예가 된다
    * ~~~ 이 리스트 혹은 이 리스트의 부분 리스트에 정의된 clear연산이 이 메서드를 호출한다
    * Implementation Requirements: 이 메서드는 fromIndex에서 시작하는 리스트 반복자를 얻어 모든 원소를 제거 할 때까지 ListIterator.next와 ListIterator.remove를 반복 호출하도록 구현 되어있다.
    주의: ListIterator.remove가 선형 시간이 걸리면 이 구현의 성능은 제곱에 비례한다
    * List 구현체의 최종 사용자는 removeRange 메서드에 관심이 없지만, 그래도 이 메서드를 제공하는 이유는 단지 하위 클래스에서 부분 리스트의 clear 메서드를 고성능으로 쉽게 만들게 하기 위함이다

- 그렇다면 상속용 클래스를 설계할 떄 어떤 메서드를 protected로 노출해야 할지는 어떻게 알까? 안타깝지만 여기에 정답은 없으며 심사숙고해서 잘 예측 해본다음, 실제 하위 클래스륾 만들어 시험해보는것이 최선이다
- 상속용 클래스를 시험하는 방법은 직접 하위 클래스를 만들어보는것이 유일하다. 꼭 필요한 protected 멤버를 놓쳤다면 하위 클래스를 작성 할 떄 그 빈자리가 확연히 드러난다. 반대로 쓰이지 않는 protected는 private여야 할것이다
- 상속용 클래스의 생성자는 직접적으로든 간접적으로든 재정의 가능 메서드를 호출해서는 안된다. 이 규칙을 어기면 프로그램이 오동작 할것이다
    * 상위 클래스의 생성자가 하위 클래스의 생성자보다 먼저 호출 된다. 이 과정에서 재정의한 메서드가 하위 클래스의 생성자에서 초기화하는 값에 의존한다면 의도대로 동작이 되지 않을것이다

```java
public class Super {
    public Super() {
        overrideMe();
    }
    public void overrideMe() {}
}

public class Sub extends Super {
    private final Instant instant;

    Sub() {
        instant = Instant.now();
    }

    @Override
    public void overrideMe() {
        System.out.println(instant);
    }

    public static void main(String[] args) {
        Sub sub = new Sub();
        sub.overrideMe();
    }
}
```

- 위 클래스는 instant를 두번 출력하리라 기대 했겟지만, 첫번째는 null이 출력된다. 상위 클래스의 생성자는 하위 클래스의 생성자가 인스턴스 필드를 초기화 하기도 전에 overrideMe를 호출 하기 떄문이다
- Cloneable과 Serializable 인터페이스는 상속용 설계의 어려움을 한층 더해준다. 따라서 둘중 하나라도 구현한 클래스를 상속할 수 있게 설계하는것은 일반적으로 좋지 않은 생각이다
    * clone와 readObject 메서드는 생성자와 비슷한 효과를 내기 떄문에 이들을 구현할 떄 따르는 제약도 생성자와 비슷하다
    * 즉, clone과 readObject 모두 직접적으로든 간접적으로든 재정의 가능 메서드를 호출 해서는 안된다
    * readObject는 하위 클래스의 상태가 미처 역직렬화 되기전에 재정의한 메서드 부터 호출하게 될것이며, clone도 하위 클래스의 clone메서드가 복제본의 상태를 올바르게 수정하기 전에 재정의한 메서드를 호출한다

- Serializable을 구현한 상속용 클래스가 readResolve나 wirteReplace를 갖는다면 이 메서드들은 private가 아닌 protected로 선언해야 한다. private는 하위클래스에서 무시되기 떄문이다
- 이렇게 클래스를 상속용으로 설계하려면 엄청난 노력이 들고 그 클래스 안에 생기는 제약도 상당하다
- 그렇다면 그 외의 일반 구체 글래스들은 상속용으로 설계되어 있지 않기 떄문에, 클래스에 변화가 있을때 마다 하위 클래스를 오작동 하게 만들 수 있다
- 이 문제를 해결하는 가장 좋은 방법으로는 상속용으로 설계하지 않은 클래스들은 상속을 금지하는 것이다
- 상속을 금지하는 두가지 방법으로는 클래스를 final로 선언 하거나, 모든 생성자를 private나 package-private로 선언하고 public 정적 팩터리를 만들어 주는 것이다
- 구체 클래스가 표준 인터페이스를 구현하지 않았는데, 상속을 금지하면 사용에 상당한 불편함이 따른다. 이럴 경우 클래스 내부에서는 제정의 가능한 메서드를 사용하지 않게 하고 이 사실을 문서화 해둬야 한다
    * 이렇게 하면 상속해도 그리 위험하지 않다. 메서드가 재정의 되더라도 다른 메서드의 동작에 아무런 영향을 주지 않기 떄문이다

- 클래스의 동작을 유지하면서, 재정의 가능 메서드를 사용하는 코드를 제거 할 수 있는 기계적인 방법이 있다
    * 각각의 재정의 가능 메서드는 자신의 본문코드를 private 도우미 메서드로 옮기고 이 도우미 메서드를 호출 하도록 바꾼다
    * 그다음 재정의 가능 메서드를 호출하는 모든 부분들도 이 도우미 메서드를 직접 호출하도록 수정하면 된다
